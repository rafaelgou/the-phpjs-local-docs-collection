<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>A Record of reStructuredText Syntax Alternatives</title>
<meta name="author" content="David Goodger" />
<meta name="date" content="2012-03-19" />
<meta name="copyright" content="This document has been placed in the public domain." />
<link rel="stylesheet" href="../../../docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="a-record-of-restructuredtext-syntax-alternatives">
<h1 class="title">A Record of reStructuredText Syntax Alternatives</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>David Goodger</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference external" href="mailto:docutils-develop&#64;lists.sourceforge.net">docutils-develop&#64;lists.sourceforge.net</a></td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>7383</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2012-03-19</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>This document has been placed in the public domain.</td></tr>
</tbody>
</table>
<p>The following are ideas, alternatives, and justifications that were
considered for reStructuredText syntax, which did not originate with
<a class="reference external" href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> or <a class="reference external" href="http://www.zope.org/DevHome/Members/jim/StructuredTextWiki/FrontPage">StructuredText</a>.  For an analysis of constructs which <em>did</em>
originate with StructuredText or Setext, please see <a class="reference external" href="problems.html">Problems With
StructuredText</a>.  See the <a class="reference external" href="../../ref/rst/restructuredtext.html">reStructuredText Markup Specification</a>
for full details of the established syntax.</p>
<p>The ideas are divided into sections:</p>
<ul class="simple">
<li><a class="reference internal" href="#implemented">Implemented</a>: already done.  The issues and alternatives are
recorded here for posterity.</li>
<li><a class="reference internal" href="#not-implemented">Not Implemented</a>: these ideas won't be implemented.</li>
<li><a class="reference internal" href="#tabled">Tabled</a>: these ideas should be revisited in the future.</li>
<li><a class="reference internal" href="#to-do">To Do</a>: these ideas should be implemented.  They're just waiting
for a champion to resolve issues and get them done.</li>
<li><a class="reference internal" href="#or-not-to-do">... Or Not To Do?</a>: possible but questionable.  These probably
won't be implemented, but you never know.</li>
</ul>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#implemented" id="id24">Implemented</a><ul>
<li><a class="reference internal" href="#field-lists" id="id25">Field Lists</a></li>
<li><a class="reference internal" href="#interpreted-text-roles" id="id26">Interpreted Text &quot;Roles&quot;</a></li>
<li><a class="reference internal" href="#comments" id="id27">Comments</a></li>
<li><a class="reference internal" href="#anonymous-hyperlinks" id="id28">Anonymous Hyperlinks</a></li>
<li><a class="reference internal" href="#reworking-explicit-markup-round-1" id="id29">Reworking Explicit Markup (Round 1)</a></li>
<li><a class="reference internal" href="#backquotes-in-phrase-links" id="id30">Backquotes in Phrase-Links</a></li>
<li><a class="reference internal" href="#substitution-mechanism" id="id31">Substitution Mechanism</a></li>
<li><a class="reference internal" href="#inline-external-targets" id="id32">Inline External Targets</a></li>
<li><a class="reference internal" href="#doctree-representation-of-transitions" id="id33">Doctree Representation of Transitions</a></li>
<li><a class="reference internal" href="#syntax-for-line-blocks" id="id34">Syntax for Line Blocks</a><ul>
<li><a class="reference internal" href="#syntax" id="id35">Syntax</a></li>
<li><a class="reference internal" href="#internal-representation" id="id36">Internal Representation</a></li>
<li><a class="reference internal" href="#output" id="id37">Output</a></li>
<li><a class="reference internal" href="#implementation-plan" id="id38">Implementation Plan</a></li>
</ul>
</li>
<li><a class="reference internal" href="#list-driven-tables" id="id39">List-Driven Tables</a></li>
<li><a class="reference internal" href="#auto-enumerated-lists" id="id40">Auto-Enumerated Lists</a></li>
<li><a class="reference internal" href="#adjacent-citation-references" id="id41">Adjacent citation references</a></li>
<li><a class="reference internal" href="#inline-markup-recognition" id="id42">Inline markup recognition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#not-implemented" id="id43">Not Implemented</a><ul>
<li><a class="reference internal" href="#reworking-footnotes" id="id44">Reworking Footnotes</a></li>
<li><a class="reference internal" href="#syntax-for-questions-answers" id="id45">Syntax for Questions &amp; Answers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tabled" id="id46">Tabled</a><ul>
<li><a class="reference internal" href="#reworking-explicit-markup-round-2" id="id47">Reworking Explicit Markup (Round 2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#to-do" id="id48">To Do</a><ul>
<li><a class="reference internal" href="#nested-inline-markup" id="id49">Nested Inline Markup</a></li>
<li><a class="reference internal" href="#index-entries-indexes" id="id50">Index Entries &amp; Indexes</a><ul>
<li><a class="reference internal" href="#from-2002-06-24-docutils-develop-posts" id="id51">from 2002-06-24 docutils-develop posts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#or-not-to-do" id="id52">... Or Not To Do?</a><ul>
<li><a class="reference internal" href="#compound-enumerated-lists" id="id53">Compound Enumerated Lists</a></li>
<li><a class="reference internal" href="#indented-lists" id="id54">Indented Lists</a></li>
<li><a class="reference internal" href="#sloppy-indentation-of-list-items" id="id55">Sloppy Indentation of List Items</a></li>
<li><a class="reference internal" href="#lazy-indentation-of-list-items" id="id56">Lazy Indentation of List Items</a><ul>
<li><a class="reference internal" href="#david-s-idea-for-lazy-indentation" id="id57">David's Idea for Lazy Indentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiple-roles-in-interpreted-text" id="id58">Multiple Roles in Interpreted Text</a></li>
<li><a class="reference internal" href="#parameterized-interpreted-text" id="id59">Parameterized Interpreted Text</a></li>
<li><a class="reference internal" href="#syntax-for-interpreted-text-role-bindings" id="id60">Syntax for Interpreted Text Role Bindings</a></li>
<li><a class="reference internal" href="#character-processing" id="id61">Character Processing</a></li>
<li><a class="reference internal" href="#page-or-line-breaks" id="id62">Page Or Line Breaks</a></li>
<li><a class="reference internal" href="#superscript-markup" id="id63">Superscript Markup</a></li>
<li><a class="reference internal" href="#code-execution" id="id64">Code Execution</a></li>
<li><a class="reference internal" href="#encoding-directive" id="id65"><tt class="docutils literal">encoding</tt> Directive</a></li>
<li><a class="reference internal" href="#support-for-annotations" id="id66">Support for Annotations</a></li>
<li><a class="reference internal" href="#term-role" id="id67"><tt class="docutils literal">term</tt> Role</a></li>
<li><a class="reference internal" href="#object-references" id="id68">Object references</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="implemented">
<h1><a class="toc-backref" href="#id24">Implemented</a></h1>
<div class="section" id="field-lists">
<h2><a class="toc-backref" href="#id25">Field Lists</a></h2>
<p>Prior to the syntax for field lists being finalized, several
alternatives were proposed.</p>
<ol class="arabic">
<li><p class="first">Unadorned <a class="reference external" href="http://www.rfc-editor.org/rfc/rfc822.txt">RFC822</a> everywhere:</p>
<pre class="literal-block">
Author: Me
Version: 1
</pre>
<p>Advantages: clean, precedent (RFC822-compliant).  Disadvantage:
ambiguous (these paragraphs are a prime example).</p>
<p>Conclusion: rejected.</p>
</li>
<li><p class="first">Special case: use unadorned <a class="reference external" href="http://www.rfc-editor.org/rfc/rfc822.txt">RFC822</a> for the very first or very last
text block of a document:</p>
<pre class="literal-block">
&quot;&quot;&quot;
Author: Me
Version: 1

The rest of the document...
&quot;&quot;&quot;
</pre>
<p>Advantages: clean, precedent (RFC822-compliant).  Disadvantages:
special case, flat (unnested) field lists only, still ambiguous:</p>
<pre class="literal-block">
&quot;&quot;&quot;
Usage: cmdname [options] arg1 arg2 ...

We obviously *don't* want the like above to be interpreted as a
field list item.  Or do we?
&quot;&quot;&quot;
</pre>
<p>Conclusion: rejected for the general case, accepted for specific
contexts (PEPs, email).</p>
</li>
<li><p class="first">Use a directive:</p>
<pre class="literal-block">
.. fields::

   Author: Me
   Version: 1
</pre>
<p>Advantages: explicit and unambiguous, RFC822-compliant.
Disadvantage: cumbersome.</p>
<p>Conclusion: rejected for the general case (but such a directive
could certainly be written).</p>
</li>
<li><p class="first">Use Javadoc-style:</p>
<pre class="literal-block">
&#64;Author: Me
&#64;Version: 1
&#64;param a: integer
</pre>
<p>Advantages: unambiguous, precedent, flexible.  Disadvantages:
non-intuitive, ugly, not RFC822-compliant.</p>
<p>Conclusion: rejected.</p>
</li>
<li><p class="first">Use leading colons:</p>
<pre class="literal-block">
:Author: Me
:Version: 1
</pre>
<p>Advantages: unambiguous, obvious (<em>almost</em> RFC822-compliant),
flexible, perhaps even elegant.  Disadvantages: no precedent, not
quite RFC822-compliant.</p>
<p>Conclusion: accepted!</p>
</li>
<li><p class="first">Use double colons:</p>
<pre class="literal-block">
Author:: Me
Version:: 1
</pre>
<p>Advantages: unambiguous, obvious? (<em>almost</em> RFC822-compliant),
flexible, similar to syntax already used for literal blocks and
directives.  Disadvantages: no precedent, not quite
RFC822-compliant, similar to syntax already used for literal blocks
and directives.</p>
<p>Conclusion: rejected because of the syntax similarity &amp; conflicts.</p>
</li>
</ol>
<p>Why is RFC822 compliance important?  It's a universal Internet
standard, and super obvious.  Also, I'd like to support the PEP format
(ulterior motive: get PEPs to use reStructuredText as their standard).
But it <em>would</em> be easy to get used to an alternative (easy even to
convert PEPs; probably harder to convert python-deviants ;-).</p>
<p>Unfortunately, without well-defined context (such as in email headers:
RFC822 only applies before any blank lines), the RFC822 format is
ambiguous.  It is very common in ordinary text.  To implement field
lists unambiguously, we need explicit syntax.</p>
<p>The following question was posed in a footnote:</p>
<blockquote>
Should &quot;bibliographic field lists&quot; be defined at the parser level,
or at the DPS transformation level?  In other words, are they
reStructuredText-specific, or would they also be applicable to
another (many/every other?) syntax?</blockquote>
<p>The answer is that bibliographic fields are a
reStructuredText-specific markup convention.  Other syntaxes may
implement the bibliographic elements explicitly.  For example, there
would be no need for such a transformation for an XML-based markup
syntax.</p>
</div>
<div class="section" id="interpreted-text-roles">
<h2><a class="toc-backref" href="#id26">Interpreted Text &quot;Roles&quot;</a></h2>
<p>The original purpose of interpreted text was as a mechanism for
descriptive markup, to describe the nature or role of a word or
phrase.  For example, in XML we could say &quot;&lt;function&gt;len&lt;/function&gt;&quot;
to mark up &quot;len&quot; as a function.  It is envisaged that within Python
docstrings (inline documentation in Python module source files, the
primary market for reStructuredText) the role of a piece of
interpreted text can be inferred implicitly from the context of the
docstring within the program source.  For other applications, however,
the role may have to be indicated explicitly.</p>
<p>Interpreted text is enclosed in single backquotes (`).</p>
<ol class="arabic">
<li><p class="first">Initially, it was proposed that an explicit role could be indicated
as a word or phrase within the enclosing backquotes:</p>
<ul>
<li><p class="first">As a prefix, separated by a colon and whitespace:</p>
<pre class="literal-block">
`role: interpreted text`
</pre>
</li>
<li><p class="first">As a suffix, separated by whitespace and a colon:</p>
<pre class="literal-block">
`interpreted text :role`
</pre>
</li>
</ul>
<p>There are problems with the initial approach:</p>
<ul class="simple">
<li>There could be ambiguity with interpreted text containing colons.
For example, an index entry of &quot;Mission: Impossible&quot; would
require a backslash-escaped colon.</li>
<li>The explicit role is descriptive markup, not content, and will
not be visible in the processed output.  Putting it inside the
backquotes doesn't feel right; the <em>role</em> isn't being quoted.</li>
</ul>
</li>
<li><p class="first">Tony Ibbs suggested that the role be placed outside the
backquotes:</p>
<pre class="literal-block">
role:`prefix` or `suffix`:role
</pre>
<p>This removes the embedded-colons ambiguity, but limits the role
identifier to be a single word (whitespace would be illegal).
Since roles are not meant to be visible after processing, the lack
of whitespace support is not important.</p>
<p>The suggested syntax remains ambiguous with respect to ratios and
some writing styles.  For example, suppose there is a &quot;signal&quot;
identifier, and we write:</p>
<pre class="literal-block">
...calculate the `signal`:noise ratio.
</pre>
<p>&quot;noise&quot; looks like a role.</p>
</li>
<li><p class="first">As an improvement on #2, we can bracket the role with colons:</p>
<pre class="literal-block">
:role:`prefix` or `suffix`:role:
</pre>
<p>This syntax is similar to that of field lists, which is fine since
both are doing similar things: describing.</p>
<p>This is the syntax chosen for reStructuredText.</p>
</li>
<li><p class="first">Another alternative is two colons instead of one:</p>
<pre class="literal-block">
role::`prefix` or `suffix`::role
</pre>
<p>But this is used for analogies (&quot;A:B::C:D&quot;: &quot;A is to B as C is to
D&quot;).</p>
<p>Both alternative #2 and #4 lack delimiters on both sides of the
role, making it difficult to parse (by the reader).</p>
</li>
<li><p class="first">Some kind of bracketing could be used:</p>
<ul>
<li><p class="first">Parentheses:</p>
<pre class="literal-block">
(role)`prefix` or `suffix`(role)
</pre>
</li>
<li><p class="first">Braces:</p>
<pre class="literal-block">
{role}`prefix` or `suffix`{role}
</pre>
</li>
<li><p class="first">Square brackets:</p>
<pre class="literal-block">
[role]`prefix` or `suffix`[role]
</pre>
</li>
<li><p class="first">Angle brackets:</p>
<pre class="literal-block">
&lt;role&gt;`prefix` or `suffix`&lt;role&gt;
</pre>
<p>(The overlap of *ML tags with angle brackets would be too
confusing and precludes their use.)</p>
</li>
</ul>
</li>
</ol>
<p>Syntax #3 was chosen for reStructuredText.</p>
</div>
<div class="section" id="comments">
<h2><a class="toc-backref" href="#id27">Comments</a></h2>
<p>A problem with comments (actually, with all indented constructs) is
that they cannot be followed by an indented block -- a block quote --
without swallowing it up.</p>
<p>I thought that perhaps comments should be one-liners only.  But would
this mean that footnotes, hyperlink targets, and directives must then
also be one-liners?  Not a good solution.</p>
<p>Tony Ibbs suggested a &quot;comment&quot; directive.  I added that we could
limit a comment to a single text block, and that a &quot;multi-block
comment&quot; could use &quot;comment-start&quot; and &quot;comment-end&quot; directives.  This
would remove the indentation incompatibility.  A &quot;comment&quot; directive
automatically suggests &quot;footnote&quot; and (hyperlink) &quot;target&quot; directives
as well.  This could go on forever!  Bad choice.</p>
<p>Garth Kidd suggested that an &quot;empty comment&quot;, a &quot;..&quot; explicit markup
start with nothing on the first line (except possibly whitespace) and
a blank line immediately following, could serve as an &quot;unindent&quot;.  An
empty comment does <strong>not</strong> swallow up indented blocks following it,
so block quotes are safe.  &quot;A tiny but practical wart.&quot;  Accepted.</p>
</div>
<div class="section" id="anonymous-hyperlinks">
<h2><a class="toc-backref" href="#id28">Anonymous Hyperlinks</a></h2>
<p>Alan Jaffray came up with this idea, along with the following syntax:</p>
<pre class="literal-block">
Search the `Python DOC-SIG mailing list archives`{}_.

.. _: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>The idea is sound and useful.  I suggested a &quot;double underscore&quot;
syntax:</p>
<pre class="literal-block">
Search the `Python DOC-SIG mailing list archives`__.

.. __: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>But perhaps single underscores are okay?  The syntax looks better, but
the hyperlink itself doesn't explicitly say &quot;anonymous&quot;:</p>
<pre class="literal-block">
Search the `Python DOC-SIG mailing list archives`_.

.. _: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>Mixing anonymous and named hyperlinks becomes confusing.  The order of
targets is not significant for named hyperlinks, but it is for
anonymous hyperlinks:</p>
<pre class="literal-block">
Hyperlinks: anonymous_, named_, and another anonymous_.

.. _named: named
.. _: anonymous1
.. _: anonymous2
</pre>
<p>Without the extra syntax of double underscores, determining which
hyperlink references are anonymous may be difficult.  We'd have to
check which references don't have corresponding targets, and match
those up with anonymous targets.  Keeping to a simple consistent
ordering (as with auto-numbered footnotes) seems simplest.</p>
<p>reStructuredText will use the explicit double-underscore syntax for
anonymous hyperlinks.  An alternative (see <a class="reference internal" href="#reworking-explicit-markup-round-1">Reworking Explicit Markup
(Round 1)</a> below) for the somewhat awkward &quot;.. __:&quot; syntax is &quot;__&quot;:</p>
<pre class="literal-block">
An anonymous__ reference.

__ http://anonymous
</pre>
</div>
<div class="section" id="reworking-explicit-markup-round-1">
<h2><a class="toc-backref" href="#id29">Reworking Explicit Markup (Round 1)</a></h2>
<p>Alan Jaffray came up with the idea of <a class="reference internal" href="#anonymous-hyperlinks">anonymous hyperlinks</a>, added
to reStructuredText.  Subsequently it was asserted that hyperlinks
(especially anonymous hyperlinks) would play an increasingly important
role in reStructuredText documents, and therefore they require a
simpler and more concise syntax.  This prompted a review of the
current and proposed explicit markup syntaxes with regards to
improving usability.</p>
<ol class="arabic">
<li><p class="first">Original syntax:</p>
<pre class="literal-block">
.. _blah:                     internal hyperlink target
.. _blah: http://somewhere    external hyperlink target
.. _blah: blahblah_           indirect hyperlink target
.. __:                        anonymous internal target
.. __: http://somewhere       anonymous external target
.. __: blahblah_              anonymous indirect target
.. [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The comment text was intentionally made to look like a hyperlink
target.</p>
</div>
<p>Origins:</p>
<ul class="simple">
<li>Except for the colon (a delimiter necessary to allow for
phrase-links), hyperlink target <tt class="docutils literal">.. _blah:</tt> comes from Setext.</li>
<li>Comment syntax from Setext.</li>
<li>Footnote syntax from StructuredText (&quot;named links&quot;).</li>
<li>Directives and anonymous hyperlinks original to reStructuredText.</li>
</ul>
<p>Advantages:</p>
<ul class="simple">
<li>Consistent explicit markup indicator: &quot;..&quot;.</li>
<li>Consistent hyperlink syntax: &quot;.. _&quot; &amp; &quot;:&quot;.</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>Anonymous target markup is awkward: &quot;.. __:&quot;.</li>
<li>The explicit markup indicator (&quot;..&quot;) is excessively overloaded?</li>
<li>Comment text is limited (can't look like a footnote, hyperlink,
or directive).  But this is probably not important.</li>
</ul>
</li>
<li><p class="first">Alan Jaffray's proposed syntax #1:</p>
<pre class="literal-block">
__ _blah                      internal hyperlink target
__ blah: http://somewhere     external hyperlink target
__ blah: blahblah_            indirect hyperlink target
__                            anonymous internal target
__ http://somewhere           anonymous external target
__ blahblah_                  anonymous indirect target
__ [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<p>The hyperlink-connoted underscores have become first-level syntax.</p>
<p>Advantages:</p>
<ul class="simple">
<li>Anonymous targets are simpler.</li>
<li>All hyperlink targets are one character shorter.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><p class="first">Inconsistent internal hyperlink targets.  Unlike all other named
hyperlink targets, there's no colon.  There's an extra leading
underscore, but we can't drop it because without it, &quot;blah&quot; looks
like a relative URI.  Unless we restore the colon:</p>
<pre class="literal-block">
__ blah:                      internal hyperlink target
</pre>
</li>
<li><p class="first">Obtrusive markup?</p>
</li>
</ul>
</li>
<li><p class="first">Alan Jaffray's proposed syntax #2:</p>
<pre class="literal-block">
.. _blah                      internal hyperlink target
.. blah: http://somewhere     external hyperlink target
.. blah: blahblah_            indirect hyperlink target
..                            anonymous internal target
.. http://somewhere           anonymous external target
.. blahblah_                  anonymous indirect target
.. [blah] http://somewhere    footnote
!! blah: http://somewhere     directive
## blah: http://somewhere     comment
</pre>
<p>Leading underscores have been (almost) replaced by &quot;..&quot;, while
comments and directives have gained their own syntax.</p>
<p>Advantages:</p>
<ul class="simple">
<li>Anonymous hyperlinks are simpler.</li>
<li>Unique syntax for comments.  Connotation of &quot;comment&quot; from
some programming languages (including our favorite).</li>
<li>Unique syntax for directives.  Connotation of &quot;action!&quot;.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><p class="first">Inconsistent internal hyperlink targets.  Again, unlike all other
named hyperlink targets, there's no colon.  There's a leading
underscore, matching the trailing underscores of references,
which no other hyperlink targets have.  We can't drop that one
leading underscore though: without it, &quot;blah&quot; looks like a
relative URI.  Again, unless we restore the colon:</p>
<pre class="literal-block">
.. blah:                      internal hyperlink target
</pre>
</li>
<li><p class="first">All (except for internal) hyperlink targets lack their leading
underscores, losing the &quot;hyperlink&quot; connotation.</p>
</li>
<li><p class="first">Obtrusive syntax for comments.  Alternatives:</p>
<pre class="literal-block">
;; blah: http://somewhere
   (also comment syntax in Lisp &amp; others)
,, blah: http://somewhere
   (&quot;comma comma&quot;: sounds like &quot;comment&quot;!)
</pre>
</li>
<li><p class="first">Iffy syntax for directives.  Alternatives?</p>
</li>
</ul>
</li>
<li><p class="first">Tony Ibbs' proposed syntax:</p>
<pre class="literal-block">
.. _blah:                     internal hyperlink target
.. _blah: http://somewhere    external hyperlink target
.. _blah: blahblah_           indirect hyperlink target
..                            anonymous internal target
.. http://somewhere           anonymous external target
.. blahblah_                  anonymous indirect target
.. [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<p>This is the same as the current syntax, except for anonymous
targets which drop their &quot;__: &quot;.</p>
<p>Advantage:</p>
<ul class="simple">
<li>Anonymous targets are simpler.</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>Anonymous targets lack their leading underscores, losing the
&quot;hyperlink&quot; connotation.</li>
<li>Anonymous targets are almost indistinguishable from comments.
(Better to know &quot;up front&quot;.)</li>
</ul>
</li>
<li><p class="first">David Goodger's proposed syntax: Perhaps going back to one of
Alan's earlier suggestions might be the best solution.  How about
simply adding &quot;__ &quot; as a synonym for &quot;.. __: &quot; in the original
syntax?  These would become equivalent:</p>
<pre class="literal-block">
.. __:                        anonymous internal target
.. __: http://somewhere       anonymous external target
.. __: blahblah_              anonymous indirect target

__                            anonymous internal target
__ http://somewhere           anonymous external target
__ blahblah_                  anonymous indirect target
</pre>
</li>
</ol>
<p>Alternative 5 has been adopted.</p>
</div>
<div class="section" id="backquotes-in-phrase-links">
<h2><a class="toc-backref" href="#id30">Backquotes in Phrase-Links</a></h2>
<p>[From a 2001-06-05 Doc-SIG post in reply to questions from Doug
Hellmann.]</p>
<p>The first draft of the spec, posted to the Doc-SIG in November 2000,
used square brackets for phrase-links.  I changed my mind because:</p>
<ol class="arabic simple">
<li>In the first draft, I had already decided on single-backquotes for
inline literal text.</li>
<li>However, I wanted to minimize the necessity for backslash escapes,
for example when quoting Python repr-equivalent syntax that uses
backquotes.</li>
<li>The processing of identifiers (function/method/attribute/module
etc. names) into hyperlinks is a useful feature.  PyDoc recognizes
identifiers heuristically, but it doesn't take much imagination to
come up with counter-examples where PyDoc's heuristics would result
in embarassing failure.  I wanted to do it deterministically, and
that called for syntax.  I called this construct &quot;interpreted
text&quot;.</li>
<li>Leveraging off the <tt class="docutils literal"><span class="pre">*emphasis*/**strong**</span></tt> syntax, lead to the
idea of using double-backquotes as syntax.</li>
<li>I worked out some rules for inline markup recognition.</li>
<li>In combination with #5, double backquotes lent themselves to inline
literals, neatly satisfying #2, minimizing backslash escapes.  In
fact, the spec says that no interpretation of any kind is done
within double-backquote inline literal text; backslashes do <em>no</em>
escaping within literal text.</li>
<li>Single backquotes are then freed up for interpreted text.</li>
<li>I already had square brackets required for footnote references.</li>
<li>Since interpreted text will typically turn into hyperlinks, it was
a natural fit to use backquotes as the phrase-quoting syntax for
trailing-underscore hyperlinks.</li>
</ol>
<p>The original inspiration for the trailing underscore hyperlink syntax
was Setext.  But for phrases Setext used a very cumbersome
<tt class="docutils literal">underscores_between_words_like_this_</tt> syntax.</p>
<p>The underscores can be viewed as if they were right-pointing arrows:
<tt class="docutils literal"><span class="pre">--&gt;</span></tt>.  So <tt class="docutils literal">hyperlink_</tt> points away from the reference, and
<tt class="docutils literal">.. _hyperlink:</tt> points toward the target.</p>
</div>
<div class="section" id="substitution-mechanism">
<h2><a class="toc-backref" href="#id31">Substitution Mechanism</a></h2>
<p>Substitutions arose out of a Doc-SIG thread begun on 2001-10-28 by
Alan Jaffray, &quot;reStructuredText inline markup&quot;.  It reminded me of a
missing piece of the reStructuredText puzzle, first referred to in my
contribution to &quot;Documentation markup &amp; processing / PEPs&quot; (Doc-SIG
2001-06-21).</p>
<p>Substitutions allow the power and flexibility of directives to be
shared by inline text.  They are a way to allow arbitrarily complex
inline objects, while keeping the details out of the flow of text.
They are the equivalent of SGML/XML's named entities.  For example, an
inline image (using reference syntax alternative 4d (vertical bars)
and definition alternative 3, the alternatives chosen for inclusion in
the spec):</p>
<pre class="literal-block">
The |biohazard| symbol must be used on containers used to dispose
of medical waste.

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
<p>The <tt class="docutils literal">|biohazard|</tt> substitution reference will be replaced in-line by
whatever the <tt class="docutils literal">.. |biohazard|</tt> substitution definition generates (in
this case, an image).  A substitution definition contains the
substitution text bracketed with vertical bars, followed by a an
embedded inline-compatible directive, such as &quot;image&quot;.  A transform is
required to complete the substitution.</p>
<p>Syntax alternatives for the reference:</p>
<ol class="arabic">
<li><p class="first">Use the existing interpreted text syntax, with a predefined role
such as &quot;sub&quot;:</p>
<pre class="literal-block">
The `biohazard`:sub: symbol...
</pre>
<p>Advantages: existing syntax, explicit.  Disadvantages: verbose,
obtrusive.</p>
</li>
<li><p class="first">Use a variant of the interpreted text syntax, with a new suffix
akin to the underscore in phrase-link references:</p>
<pre class="literal-block">
(a) `name`&#64;
(b) `name`#
(c) `name`&amp;
(d) `name`/
(e) `name`&lt;
(f) `name`::
(g) `name`:
</pre>
<p>Due to incompatibility with other constructs and ordinary text
usage, (f) and (g) are not possible.</p>
</li>
<li><p class="first">Use interpreted text syntax with a fixed internal format:</p>
<pre class="literal-block">
(a) `:name:`
(b) `name:`
(c) `name::`
(d) `::name::`
(e) `%name%`
(f) `#name#`
(g) `/name/`
(h) `&amp;name&amp;`
(i) `|name|`
(j) `[name]`
(k) `&lt;name&gt;`
(l) `&amp;name;`
(m) `'name'`
</pre>
<p>To avoid ML confusion (k) and (l) are definitely out.  Square
brackets (j) won't work in the target (the substitution definition
would be indistinguishable from a footnote).</p>
<p>The <tt class="docutils literal">`/name/`</tt> syntax (g) is reminiscent of &quot;s/find/sub&quot;
substitution syntax in ed-like languages.  However, it may have a
misleading association with regexps, and looks like an absolute
POSIX path.  (i) is visually equivalent and lacking the
connotations.</p>
<p>A disadvantage of all of these is that they limit interpreted text,
albeit only slightly.</p>
</li>
<li><p class="first">Use specialized syntax, something new:</p>
<pre class="literal-block">
(a) #name#
(b) &#64;name&#64;
(c) /name/
(d) |name|
(e) &lt;&lt;name&gt;&gt;
(f) //name//
(g) ||name||
(h) ^name^
(i) [[name]]
(j) ~name~
(k) !name!
(l) =name=
(m) ?name?
(n) &gt;name&lt;
</pre>
<p>&quot;#&quot; (a) and &quot;&#64;&quot; (b) are obtrusive.  &quot;/&quot; (c) without backquotes
looks just like a POSIX path; it is likely for such usage to appear
in text.</p>
<p>&quot;|&quot; (d) and &quot;^&quot; (h) are feasible.</p>
</li>
<li><p class="first">Redefine the trailing underscore syntax.  See definition syntax
alternative 4, below.</p>
</li>
</ol>
<p>Syntax alternatives for the definition:</p>
<ol class="arabic">
<li><p class="first">Use the existing directive syntax, with a predefined directive such
as &quot;sub&quot;.  It contains a further embedded directive resolving to an
inline-compatible object:</p>
<pre class="literal-block">
.. sub:: biohazard
   .. image:: biohazard.png
      [height=20 width=20]

.. sub:: parrot
   That bird wouldn't *voom* if you put 10,000,000 volts
   through it!
</pre>
<p>The advantages and disadvantages are the same as in inline
alternative 1.</p>
</li>
<li><p class="first">Use syntax as in #1, but with an embedded directivecompressed:</p>
<pre class="literal-block">
.. sub:: biohazard image:: biohazard.png
   [height=20 width=20]
</pre>
<p>This is a bit better than alternative 1, but still too much.</p>
</li>
<li><p class="first">Use a variant of directive syntax, incorporating the substitution
text, obviating the need for a special &quot;sub&quot; directive name.  If we
assume reference alternative 4d (vertical bars), the matching
definition would look like this:</p>
<pre class="literal-block">
.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
</li>
<li><p class="first">(Suggested by Alan Jaffray on Doc-SIG from 2001-11-06.)</p>
<p>Instead of adding new syntax, redefine the trailing underscore
syntax to mean &quot;substitution reference&quot; instead of &quot;hyperlink
reference&quot;.  Alan's example:</p>
<pre class="literal-block">
I had lunch with Jonathan_ today.  We talked about Zope_.

.. _Jonathan: lj [user=jhl]
.. _Zope: http://www.zope.org/
</pre>
<p>A problem with the proposed syntax is that URIs which look like
simple reference names (alphanum plus &quot;.&quot;, &quot;-&quot;, &quot;_&quot;) would be
indistinguishable from substitution directive names.  A more
consistent syntax would be:</p>
<pre class="literal-block">
I had lunch with Jonathan_ today.  We talked about Zope_.

.. _Jonathan: lj:: user=jhl
.. _Zope: http://www.zope.org/
</pre>
<p>(<tt class="docutils literal">::</tt> after <tt class="docutils literal">.. _Jonathan: lj</tt>.)</p>
<p>The &quot;Zope&quot; target is a simple external hyperlink, but the
&quot;Jonathan&quot; target contains a directive.  Alan proposed is that the
reference text be replaced by whatever the referenced directive
(the &quot;directive target&quot;) produces.  A directive reference becomes a
hyperlink reference if the contents of the directive target resolve
to a hyperlink.  If the directive target resolves to an icon, the
reference is replaced by an inline icon.  If the directive target
resolves to a hyperlink, the directive reference becomes a
hyperlink reference.</p>
<p>This seems too indirect and complicated for easy comprehension.</p>
<p>The reference in the text will sometimes become a link, sometimes
not.  Sometimes the reference text will remain, sometimes not.  We
don't know <em>at the reference</em>:</p>
<pre class="literal-block">
This is a `hyperlink reference`_; its text will remain.
This is an `inline icon`_; its text will disappear.
</pre>
<p>That's a problem.</p>
</li>
</ol>
<p>The syntax that has been incorporated into the spec and parser is
reference alternative 4d with definition alternative 3:</p>
<pre class="literal-block">
The |biohazard| symbol...

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
<p>We can also combine substitution references with hyperlink references,
by appending a &quot;_&quot; (named hyperlink reference) or &quot;__&quot; (anonymous
hyperlink reference) suffix to the substitution reference.  This
allows us to click on an image-link:</p>
<pre class="literal-block">
The |biohazard|_ symbol...

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
.. _biohazard: http://www.cdc.gov/
</pre>
<p>There have been several suggestions for the naming of these
constructs, originally called &quot;substitution references&quot; and
&quot;substitutions&quot;.</p>
<ol class="arabic simple">
<li>Candidate names for the reference construct:<ol class="loweralpha">
<li>substitution reference</li>
<li>tagging reference</li>
<li>inline directive reference</li>
<li>directive reference</li>
<li>indirect inline directive reference</li>
<li>inline directive placeholder</li>
<li>inline directive insertion reference</li>
<li>directive insertion reference</li>
<li>insertion reference</li>
<li>directive macro reference</li>
<li>macro reference</li>
<li>substitution directive reference</li>
</ol>
</li>
<li>Candidate names for the definition construct:<ol class="loweralpha">
<li>substitution</li>
<li>substitution directive</li>
<li>tag</li>
<li>tagged directive</li>
<li>directive target</li>
<li>inline directive</li>
<li>inline directive definition</li>
<li>referenced directive</li>
<li>indirect directive</li>
<li>indirect directive definition</li>
<li>directive definition</li>
<li>indirect inline directive</li>
<li>named directive definition</li>
<li>inline directive insertion definition</li>
<li>directive insertion definition</li>
<li>insertion definition</li>
<li>insertion directive</li>
<li>substitution definition</li>
<li>directive macro definition</li>
<li>macro definition</li>
<li>substitution directive definition</li>
<li>substitution definition</li>
</ol>
</li>
</ol>
<p>&quot;Inline directive reference&quot; (1c) seems to be an appropriate term at
first, but the term &quot;inline&quot; is redundant in the case of the
reference.  Its counterpart &quot;inline directive definition&quot; (2g) is
awkward, because the directive definition itself is not inline.</p>
<p>&quot;Directive reference&quot; (1d) and &quot;directive definition&quot; (2k) are too
vague.  &quot;Directive definition&quot; could be used to refer to any
directive, not just those used for inline substitutions.</p>
<p>One meaning of the term &quot;macro&quot; (1k, 2s, 2t) is too
programming-language-specific.  Also, macros are typically simple text
substitution mechanisms: the text is substituted first and evaluated
later.  reStructuredText substitution definitions are evaluated in
place at parse time and substituted afterwards.</p>
<p>&quot;Insertion&quot; (1h, 1i, 2n-2q) is almost right, but it implies that
something new is getting added rather than one construct being
replaced by another.</p>
<p>Which brings us back to &quot;substitution&quot;.  The overall best names are
&quot;substitution reference&quot; (1a) and &quot;substitution definition&quot; (2v).  A
long way to go to add one word!</p>
</div>
<div class="section" id="inline-external-targets">
<h2><a class="toc-backref" href="#id32">Inline External Targets</a></h2>
<p>Currently reStructuredText has two hyperlink syntax variations:</p>
<ul>
<li><p class="first">Named hyperlinks:</p>
<pre class="literal-block">
This is a named reference_ of one word (&quot;reference&quot;).  Here is
a `phrase reference`_.  Phrase references may even cross `line
boundaries`_.

.. _reference: http://www.example.org/reference/
.. _phrase reference: http://www.example.org/phrase_reference/
.. _line boundaries: http://www.example.org/line_boundaries/
</pre>
<ul class="simple">
<li>Advantages:<ul>
<li>The plaintext is readable.</li>
<li>Each target may be reused multiple times (e.g., just write
<tt class="docutils literal">&quot;reference_&quot;</tt> again).</li>
<li>No syncronized ordering of references and targets is necessary.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>The reference text must be repeated as target names; could lead
to mistakes.</li>
<li>The target URLs may be located far from the references, and hard
to find in the plaintext.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Anonymous hyperlinks (in current reStructuredText):</p>
<pre class="literal-block">
This is an anonymous reference__.  Here is an anonymous
`phrase reference`__.  Phrase references may even cross `line
boundaries`__.

__ http://www.example.org/reference/
__ http://www.example.org/phrase_reference/
__ http://www.example.org/line_boundaries/
</pre>
<ul class="simple">
<li>Advantages:<ul>
<li>The plaintext is readable.</li>
<li>The reference text does not have to be repeated.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>References and targets must be kept in sync.</li>
<li>Targets cannot be reused.</li>
<li>The target URLs may be located far from the references.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For comparison and historical background, StructuredText also has two
syntaxes for hyperlinks:</p>
<ul>
<li><p class="first">First, <tt class="docutils literal">&quot;reference <span class="pre">text&quot;:URL</span></tt>:</p>
<pre class="literal-block">
This is a &quot;reference&quot;:http://www.example.org/reference/
of one word (&quot;reference&quot;).  Here is a &quot;phrase
reference&quot;:http://www.example.org/phrase_reference/.
</pre>
</li>
<li><p class="first">Second, <tt class="docutils literal">&quot;reference text&quot;, <span class="pre">http://example.com/absolute_URL</span></tt>:</p>
<pre class="literal-block">
This is a &quot;reference&quot;, http://www.example.org/reference/
of one word (&quot;reference&quot;).  Here is a &quot;phrase reference&quot;,
http://www.example.org/phrase_reference/.
</pre>
</li>
</ul>
<p>Both syntaxes share advantages and disadvantages:</p>
<ul class="simple">
<li>Advantages:<ul>
<li>The target is specified immediately adjacent to the reference.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Poor plaintext readability.</li>
<li>Targets cannot be reused.</li>
<li>Both syntaxes use double quotes, common in ordinary text.</li>
<li>In the first syntax, the URL and the last word are stuck
together, exacerbating the line wrap problem.</li>
<li>The second syntax is too magical; text could easily be written
that way by accident (although only absolute URLs are recognized
here, perhaps because of the potential for ambiguity).</li>
</ul>
</li>
</ul>
<p>A new type of &quot;inline external hyperlink&quot; has been proposed.</p>
<ol class="arabic">
<li><p class="first">On 2002-06-28, Simon Budig <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2002-June/002648.html">proposed</a> a new syntax for
reStructuredText hyperlinks:</p>
<pre class="literal-block">
This is a reference_(http://www.example.org/reference/) of one
word (&quot;reference&quot;).  Here is a `phrase
reference`_(http://www.example.org/phrase_reference/).  Are
these examples, (single-underscore), named?  If so, `anonymous
references`__(http://www.example.org/anonymous/) using two
underscores would probably be preferable.
</pre>
<p>The syntax, advantages, and disadvantages are similar to those of
StructuredText.</p>
<ul class="simple">
<li>Advantages:<ul>
<li>The target is specified immediately adjacent to the reference.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Poor plaintext readability.</li>
<li>Targets cannot be reused (unless named, but the semantics are
unclear).</li>
</ul>
</li>
<li>Problems:<ul>
<li>The <tt class="docutils literal">&quot;`ref`_(URL)&quot;</tt> syntax forces the last word of the
reference text to be joined to the URL, making a potentially
very long word that can't be wrapped (URLs can be very long).
The reference and the URL should be separate.  This is a
symptom of the following point:</li>
<li>The syntax produces a single compound construct made up of two
equally important parts, <em>with syntax in the middle</em>, <em>between</em>
the reference and the target.  This is unprecedented in
reStructuredText.</li>
<li>The &quot;inline hyperlink&quot; text is <em>not</em> a named reference (there's
no lookup by name), so it shouldn't look like one.</li>
<li>According to the IETF standards RFC 2396 and RFC 2732,
parentheses are legal URI characters and curly braces are legal
email characters, making their use prohibitively difficult.</li>
<li>The named/anonymous semantics are unclear.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">After an <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2002-July/002670.html">analysis</a> of the syntax of (1) above, we came up with the
following compromise syntax:</p>
<pre class="literal-block">
This is an anonymous reference__
__&lt;http://www.example.org/reference/&gt; of one word
(&quot;reference&quot;).  Here is a `phrase reference`__
__&lt;http://www.example.org/phrase_reference/&gt;.  `Named
references`_ _&lt;http://www.example.org/anonymous/&gt; use single
underscores.
</pre>
<p>The syntax builds on that of the existing &quot;inline internal
targets&quot;: <tt class="docutils literal">an _`inline internal target`.</tt></p>
<ul class="simple">
<li>Advantages:<ul>
<li>The target is specified immediately adjacent to the reference,
improving maintainability:<ul>
<li>References and targets are easily kept in sync.</li>
<li>The reference text does not have to be repeated.</li>
</ul>
</li>
<li>The construct is executed in two parts: references identical to
existing references, and targets that are new but not too big a
stretch from current syntax.</li>
<li>There's overwhelming precedent for quoting URLs with angle
brackets <a class="footnote-reference" href="#id4" id="id3">[1]</a>.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Poor plaintext readability.</li>
<li>Lots of &quot;line noise&quot;.</li>
<li>Targets cannot be reused (unless named; see below).</li>
</ul>
</li>
</ul>
<p>To alleviate the readability issue slightly, we could allow the
target to appear later, such as after the end of the sentence:</p>
<pre class="literal-block">
This is a named reference__ of one word (&quot;reference&quot;).
__&lt;http://www.example.org/reference/&gt;  Here is a `phrase
reference`__.  __&lt;http://www.example.org/phrase_reference/&gt;
</pre>
<p>Problem: this could only work for one reference at a time
(reference/target pairs must be proximate [refA trgA refB trgB],
not interleaved [refA refB trgA trgB] or nested [refA refB trgB
trgA]).  This variation is too problematic; references and inline
external targets will have to be kept imediately adjacent (see (3)
below).</p>
<p>The <tt class="docutils literal">&quot;reference__ __&lt;target&gt;&quot;</tt> syntax is actually for &quot;anonymous
inline external targets&quot;, emphasized by the double underscores.  It
follows that single trailing and leading underscores would lead to
<em>implicitly named</em> inline external targets.  This would allow the
reuse of targets by name.  So after <tt class="docutils literal">&quot;reference_ _&lt;target&gt;&quot;</tt>,
another <tt class="docutils literal">&quot;reference_&quot;</tt> would point to the same target.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><p class="first">From RFC 2396 (URI syntax):</p>
<blockquote>
<p>The angle-bracket &quot;&lt;&quot; and &quot;&gt;&quot; and double-quote (&quot;)
characters are excluded [from URIs] because they are often
used as the delimiters around URI in text documents and
protocol fields.</p>
<p>Using &lt;&gt; angle brackets around each URI is especially
recommended as a delimiting style for URI that contain
whitespace.</p>
</blockquote>
<p>From RFC 822 (email headers):</p>
<blockquote class="last">
<p>Angle brackets (&quot;&lt;&quot; and &quot;&gt;&quot;) are generally used to indicate
the presence of a one machine-usable reference (e.g.,
delimiting mailboxes), possibly including source-routing to
the machine.</p>
</blockquote>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">If it is best for references and inline external targets to be
immediately adjacent, then they might as well be integrated.
Here's an alternative syntax embedding the target URL in the
reference:</p>
<pre class="literal-block">
This is an anonymous `reference &lt;http://www.example.org
/reference/&gt;`__ of one word (&quot;reference&quot;).  Here is a `phrase
reference &lt;http://www.example.org/phrase_reference/&gt;`__.
</pre>
<p>Advantages and disadvantages are similar to those in (2).
Readability is still an issue, but the syntax is a bit less
heavyweight (reduced line noise).  Backquotes are required, even
for one-word references; the target URL is included within the
reference text, forcing a phrase context.</p>
<p>We'll call this variant &quot;embedded URIs&quot;.</p>
<p>Problem: how to refer to a title like &quot;HTML Anchors: &lt;a&gt;&quot; (which
ends with an HTML/SGML/XML tag)?  We could either require more
syntax on the target (like <tt class="docutils literal">&quot;`reference text
<span class="pre">__&lt;http://example.com/&gt;`__&quot;</span></tt>), or require the odd conflicting
title to be escaped (like <tt class="docutils literal">&quot;`HTML Anchors: <span class="pre">\&lt;a&gt;`__&quot;</span></tt>).  The
latter seems preferable, and not too onerous.</p>
<p>Similarly to (2) above, a single trailing underscore would convert
the reference &amp; inline external target from anonymous to implicitly
named, allowing reuse of targets by name.</p>
<p>I think this is the least objectionable of the syntax alternatives.</p>
</li>
</ol>
<p>Other syntax variations have been proposed (by Brett Cannon and Benja
Fallenstein):</p>
<pre class="literal-block">
`phrase reference`-&gt;http://www.example.com

`phrase reference`&#64;http://www.example.com

`phrase reference`__ -&gt;http://www.example.com

`phrase reference` [-&gt; http://www.example.com]

`phrase reference`__ [-&gt; http://www.example.com]

`phrase reference` &lt;http://www.example.com&gt;_
</pre>
<p>None of these variations are clearly superior to #3 above.  Some have
problems that exclude their use.</p>
<p>With any kind of inline external target syntax it comes down to the
conflict between maintainability and plaintext readability.  I don't
see a major problem with reStructuredText's maintainability, and I
don't want to sacrifice plaintext readability to &quot;improve&quot; it.</p>
<p>The proponents of inline external targets want them for easily
maintainable web pages.  The arguments go something like this:</p>
<ul>
<li><p class="first">Named hyperlinks are difficult to maintain because the reference
text is duplicated as the target name.</p>
<p>To which I said, &quot;So use anonymous hyperlinks.&quot;</p>
</li>
<li><p class="first">Anonymous hyperlinks are difficult to maintain becuase the
references and targets have to be kept in sync.</p>
<p>&quot;So keep the targets close to the references, grouped after each
paragraph.  Maintenance is trivial.&quot;</p>
</li>
<li><p class="first">But targets grouped after paragraphs break the flow of text.</p>
<p>&quot;Surely less than URLs embedded in the text!  And if the intent is
to produce web pages, not readable plaintext, then who cares about
the flow of text?&quot;</p>
</li>
</ul>
<p>Many participants have voiced their objections to the proposed syntax:</p>
<blockquote>
<p>Garth Kidd: &quot;I strongly prefer the current way of doing it.
Inline is spectactularly messy, IMHO.&quot;</p>
<p>Tony Ibbs: &quot;I vehemently agree... that the inline alternatives
being suggested look messy - there are/were good reasons they've
been taken out...  I don't believe I would gain from the new
syntaxes.&quot;</p>
<p>Paul Moore: &quot;I agree as well.  The proposed syntax is far too
punctuation-heavy, and any of the alternatives discussed are
ambiguous or too subtle.&quot;</p>
</blockquote>
<p>Others have voiced their support:</p>
<blockquote>
<p>fantasai: &quot;I agree with Simon.  In many cases, though certainly
not in all, I find parenthesizing the url in plain text flows
better than relegating it to a footnote.&quot;</p>
<p>Ken Manheimer: &quot;I'd like to weigh in requesting some kind of easy,
direct inline reference link.&quot;</p>
</blockquote>
<p>(Interesting that those <em>against</em> the proposal have been using
reStructuredText for a while, and those <em>for</em> the proposal are either
new to the list [&quot;fantasai&quot;, background unknown] or longtime
StructuredText users [Ken Manheimer].)</p>
<p>I was initially ambivalent/against the proposed &quot;inline external
targets&quot;.  I value reStructuredText's readability very highly, and
although the proposed syntax offers convenience, I don't know if the
convenience is worth the cost in ugliness.  Does the proposed syntax
compromise readability too much, or should the choice be left up to
the author?  Perhaps if the syntax is <em>allowed</em> but its use strongly
<em>discouraged</em>, for aesthetic/readability reasons?</p>
<p>After a great deal of thought and much input from users, I've decided
that there are reasonable use cases for this construct.  The
documentation should strongly caution against its use in most
situations, recommending independent block-level targets instead.
Syntax #3 above (&quot;embedded URIs&quot;) will be used.</p>
</div>
<div class="section" id="doctree-representation-of-transitions">
<h2><a class="toc-backref" href="#id33">Doctree Representation of Transitions</a></h2>
<p>(Although not reStructuredText-specific, this section fits best in
this document.)</p>
<p>Having added the &quot;horizontal rule&quot; construct to the <a class="reference external" href="../../ref/rst/restructuredtext.html">reStructuredText
Markup Specification</a>, a decision had to be made as to how to reflect
the construct in the implementation of the document tree.  Given this
source:</p>
<pre class="literal-block">
Document
========

Paragraph 1

--------

Paragraph 2
</pre>
<p>The horizontal rule indicates a &quot;transition&quot; (in prose terms) or the
start of a new &quot;division&quot;.  Before implementation, the parsed document
tree would be:</p>
<pre class="literal-block">
&lt;document&gt;
    &lt;section names=&quot;document&quot;&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        --------               &lt;--- error here
        &lt;paragraph&gt;
            Paragraph 2
</pre>
<p>There are several possibilities for the implementation:</p>
<ol class="arabic">
<li><p class="first">Implement horizontal rules as &quot;divisions&quot; or segments.  A
&quot;division&quot; is a title-less, non-hierarchical section.  The first
try at an implementation looked like this:</p>
<pre class="literal-block">
&lt;document&gt;
    &lt;section names=&quot;document&quot;&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 2
</pre>
<p>But the two paragraphs are really at the same level; they shouldn't
appear to be at different levels.  There's really an invisible
&quot;first division&quot;.  The horizontal rule splits the document body
into two segments, which should be treated uniformly.</p>
</li>
<li><p class="first">Treating &quot;divisions&quot; uniformly brings us to the second
possibility:</p>
<pre class="literal-block">
&lt;document&gt;
    &lt;section names=&quot;document&quot;&gt;
        &lt;title&gt;
            Document
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 1
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 2
</pre>
<p>With this change, documents and sections will directly contain
divisions and sections, but not body elements.  Only divisions will
directly contain body elements.  Even without a horizontal rule
anywhere, the body elements of a document or section would be
contained within a division element.  This makes the document tree
deeper.  This is similar to the way <a class="reference external" href="http://www.w3.org/MarkUp/">HTML</a> treats document contents:
grouped within a <tt class="docutils literal">&lt;body&gt;</tt> element.</p>
</li>
<li><p class="first">Implement them as &quot;transitions&quot;, empty elements:</p>
<pre class="literal-block">
&lt;document&gt;
    &lt;section names=&quot;document&quot;&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        &lt;transition&gt;
        &lt;paragraph&gt;
            Paragraph 2
</pre>
<p>A transition would be a &quot;point element&quot;, not containing anything,
only identifying a point within the document structure.  This keeps
the document tree flatter, but the idea of a &quot;point element&quot; like
&quot;transition&quot; smells bad.  A transition isn't a thing itself, it's
the space between two divisions.  However, transitions are a
practical solution.</p>
</li>
</ol>
<p>Solution 3 was chosen for incorporation into the document tree model.</p>
</div>
<div class="section" id="syntax-for-line-blocks">
<h2><a class="toc-backref" href="#id34">Syntax for Line Blocks</a></h2>
<ul>
<li><p class="first">An early idea: How about a literal-block-like prefix, perhaps
&quot;<tt class="docutils literal">;;</tt>&quot;?  (It is, after all, a <em>semi-literal</em> literal block, no?)
Example:</p>
<pre class="literal-block">
Take it away, Eric the Orchestra Leader!  ;;

    A one, two, a one two three four

    Half a bee, philosophically,
    must, *ipso facto*, half not be.
    But half the bee has got to be,
    *vis a vis* its entity.  D'you see?

    But can a bee be said to be
    or not to be an entire bee,
    when half the bee is not a bee,
    due to some ancient injury?

    Singing...
</pre>
<p>Kinda lame.</p>
</li>
<li><p class="first">Another idea: in an ordinary paragraph, if the first line ends with
a backslash (escaping the newline), interpret the entire paragraph
as a verse block?  For example:</p>
<pre class="literal-block">
Add just one backslash\
And this paragraph becomes
An awful haiku
</pre>
<p>(Awful, and arguably invalid, since in Japanese the word &quot;haiku&quot;
contains three syllables not two.)</p>
<p>This idea was superceded by the rules for escaped whitespace, useful
for <a class="reference external" href="../../ref/rst/restructuredtext.html#character-level-inline-markup">character-level inline markup</a>.</p>
</li>
<li><p class="first">In a <a class="reference external" href="http://thread.gmane.org/gmane.text.docutils.devel/1187">2004-02-22 docutils-develop message</a>, Jarno Elonen proposed
a &quot;plain list&quot; syntax (and also provided a patch):</p>
<pre class="literal-block">
| John Doe
| President, SuperDuper Corp.
| jdoe&#64;example.org
</pre>
<p>This syntax is very natural.  However, these &quot;plain lists&quot; seem very
similar to line blocks, and I see so little intrinsic &quot;list-ness&quot;
that I'm loathe to add a new object.  I used the term &quot;blurbs&quot; to
remove the &quot;list&quot; connotation from the originally proposed name.
Perhaps line blocks could be refined to add the two properties they
currently lack:</p>
<ol class="upperalpha simple">
<li>long lines wrap nicely</li>
<li>HTML output doesn't look like program code in non-CSS web
browsers</li>
</ol>
<p>(A) is an issue of all 3 aspects of Docutils: syntax (construct
behaviour), internal representation, and output.  (B) is partly an
issue of internal representation but mostly of output.</p>
</li>
</ul>
<p>ReStructuredText will redefine line blocks with the &quot;|&quot;-quoting
syntax.  The following is my current thinking.</p>
<div class="section" id="syntax">
<h3><a class="toc-backref" href="#id35">Syntax</a></h3>
<p>Perhaps line block syntax like this would do:</p>
<pre class="literal-block">
| M6: James Bond
| MIB: Mr. J.
| IMF: not decided yet, but probably one of the following:
|   Ethan Hunt
|   Jim Phelps
|   Claire Phelps
| CIA: Lea Leiter
</pre>
<p>Note that the &quot;nested&quot; list does not have nested syntax (the &quot;|&quot; are
not further indented); the leading whitespace would still be
significant somehow (more below).  As for long lines in the input,
this could suffice:</p>
<pre class="literal-block">
| John Doe
| Founder, President, Chief Executive Officer, Cook, Bottle
  Washer, and All-Round Great Guy
| SuperDuper Corp.
| jdoe&#64;example.org
</pre>
<p>The lack of &quot;|&quot; on the third line indicates that it's a continuation
of the second line, wrapped.</p>
<p>I don't see much point in allowing arbitrary nested content.  Multiple
paragraphs or bullet lists inside a &quot;blurb&quot; doesn't make sense to me.
Simple nested line blocks should suffice.</p>
</div>
<div class="section" id="internal-representation">
<h3><a class="toc-backref" href="#id36">Internal Representation</a></h3>
<p>Line blocks are currently represented as text blobs as follows:</p>
<pre class="literal-block">
&lt;!ELEMENT line_block %text.model;&gt;
&lt;!ATTLIST line_block
    %basic.atts;
    %fixedspace.att;&gt;
</pre>
<p>Instead, we could represent each line by a separate element:</p>
<pre class="literal-block">
&lt;!ELEMENT line_block (line+)&gt;
&lt;!ATTLIST line_block %basic.atts;&gt;

&lt;!ELEMENT line %text.model;&gt;
&lt;!ATTLIST line %basic.atts;&gt;
</pre>
<p>We'd keep the significance of the leading whitespace of each line
either by converting it to non-breaking spaces at output, or with a
per-line margin.  Non-breaking spaces are simpler (for HTML, anyway)
but kludgey, and wouldn't support indented long lines that wrap.  But
should inter-word whitespace (i.e., not leading whitespace) be
preserved?  Currently it is preserved in line blocks.</p>
<p>Representing a more complex line block may be tricky:</p>
<pre class="literal-block">
| But can a bee be said to be
|     or not to be an entire bee,
|         when half the bee is not a bee,
|             due to some ancient injury?
</pre>
<p>Perhaps the representation could allow for nested line blocks:</p>
<pre class="literal-block">
&lt;!ELEMENT line_block (line | line_block)+&gt;
</pre>
<p>With this model, leading whitespace would no longer be significant.
Instead, left margins are implied by the nesting.  The example above
could be represented as follows:</p>
<pre class="literal-block">
&lt;line_block&gt;
    &lt;line&gt;
        But can a bee be said to be
    &lt;line_block&gt;
        &lt;line&gt;
             or not to be an entire bee,
        &lt;line_block&gt;
            &lt;line&gt;
                when half the bee is not a bee,
            &lt;line_block&gt;
                &lt;line&gt;
                    due to some ancient injury?
</pre>
<p>I wasn't sure what to do about even more complex line blocks:</p>
<pre class="literal-block">
|     Indented
| Not indented
|   Indented a bit
|     A bit more
|  Only one space
</pre>
<p>How should that be parsed and nested?  Should the first line have
the same nesting level (== indentation in the output) as the fourth
line, or the same as the last line?  Mark Nodine suggested that such
line blocks be parsed similarly to complexly-nested block quotes,
which seems reasonable.  In the example above, this would result in
the nesting of first line matching the last line's nesting.  In
other words, the nesting would be relative to neighboring lines
only.</p>
</div>
<div class="section" id="output">
<h3><a class="toc-backref" href="#id37">Output</a></h3>
<p>In HTML, line blocks are currently output as &quot;&lt;pre&gt;&quot; blocks, which
gives us significant whitespace and line breaks, but doesn't allow
long lines to wrap and causes monospaced output without stylesheets.
Instead, we could output &quot;&lt;div&gt;&quot; elements parallelling the
representation above, where each nested &lt;div class=&quot;line_block&quot;&gt; would
have an increased left margin (specified in the stylesheet).</p>
<p>Jarno suggested the following HTML output:</p>
<pre class="literal-block">
&lt;div class=&quot;line_block&quot;&gt;
   &lt;span class=&quot;line&quot;&gt;First, top level line&lt;/span&gt;&lt;br class=&quot;hidden&quot;/&gt;
   &lt;div class=&quot;line_block&quot;&gt;&lt;span class=&quot;hidden&quot;&gt;&amp;nbsp;&lt;/span&gt;
      &lt;span class=&quot;line&quot;&gt;Second, once nested&lt;/span&gt;&lt;br class=&quot;hidden&quot;/&gt;
      &lt;span class=&quot;line&quot;&gt;Third, once nested&lt;/span&gt;&lt;br class=&quot;hidden&quot;/&gt;
      ...
   &lt;/div&gt;
   ...
&lt;/div&gt;
</pre>
<p>The <tt class="docutils literal">&lt;br <span class="pre">class=&quot;hidden&quot;</span> /&gt;</tt> and <tt class="docutils literal">&lt;span
<span class="pre">class=&quot;hidden&quot;&gt;&amp;nbsp;&lt;/span&gt;</span></tt> are meant to support non-CSS and
non-graphical browsers.  I understand the case for &quot;br&quot;, but I'm not
so sure about hidden &quot;&amp;nbsp;&quot;.  I question how much effort should be
put toward supporting non-graphical and especially non-CSS browsers,
at least for html4css1.py output.</p>
<p>Should the lines themselves be <tt class="docutils literal">&lt;span&gt;</tt> or <tt class="docutils literal">&lt;div&gt;</tt>?  I don't like
mixing inline and block-level elements.</p>
</div>
<div class="section" id="implementation-plan">
<h3><a class="toc-backref" href="#id38">Implementation Plan</a></h3>
<p>We'll leave the old implementation in place (via the &quot;line-block&quot;
directive only) until all Writers have been updated to support the new
syntax &amp; implementation.  The &quot;line-block&quot; directive can then be
updated to use the new internal representation, and its documentation
will be updated to recommend the new syntax.</p>
</div>
</div>
<div class="section" id="list-driven-tables">
<h2><a class="toc-backref" href="#id39">List-Driven Tables</a></h2>
<p>The original idea came from Dylan Jay:</p>
<blockquote>
... to use a two level bulleted list with something to
indicate it should be rendered as a table ...</blockquote>
<p>It's an interesting idea.  It could be implemented in as a directive
which transforms a uniform two-level list into a table.  Using a
directive would allow the author to explicitly set the table's
orientation (by column or by row), the presence of row headers, etc.</p>
<p>Alternatives:</p>
<ol class="arabic">
<li><p class="first">(Implemented in Docutils 0.3.8).</p>
<p>Bullet-list-tables might look like this:</p>
<pre class="literal-block">
.. list-table::

   * - Treat
     - Quantity
     - Description
   * - Albatross!
     - 299
     - On a stick!
   * - Crunchy Frog!
     - 1499
     - If we took the bones out, it wouldn't be crunchy,
       now would it?
   * - Gannet Ripple!
     - 199
     - On a stick!
</pre>
<p>This list must be written in two levels.  This wouldn't work:</p>
<pre class="literal-block">
.. list-table::

   * Treat
   * Albatross!
   * Gannet!
   * Crunchy Frog!

   * Quantity
   * 299
   * 199
   * 1499

   * Description
   * On a stick!
   * On a stick!
   * If we took the bones out...
</pre>
<p>The above is a single list of 12 items.  The blank lines are not
significant to the markup.  We'd have to explicitly specify how
many columns or rows to use, which isn't a good idea.</p>
</li>
<li><p class="first">Beni Cherniavsky suggested a field list alternative.  It could look
like this:</p>
<pre class="literal-block">
.. field-list-table::
   :headrows: 1

   - :treat: Treat
     :quantity: Quantity
     :descr: Description

   - :treat: Albatross!
     :quantity: 299
     :descr: On a stick!

   - :treat: Crunchy Frog!
     :quantity: 1499
     :descr: If we took the bones out, it wouldn't be
             crunchy, now would it?
</pre>
<p>Column order is determined from the order of fields in the first
row.  Field order in all other rows is ignored.  As a side-effect,
this allows trivial re-arrangement of columns.  By using named
fields, it becomes possible to omit fields in some rows without
losing track of things, which is important for spans.</p>
</li>
<li><p class="first">An alternative to two-level bullet lists would be to use enumerated
lists for the table cells:</p>
<pre class="literal-block">
.. list-table::

    * 1. Treat
      2. Quantity
      3. Description
    * 1. Albatross!
      2. 299
      3. On a stick!
    * 1. Crunchy Frog!
      2. 1499
      3. If we took the bones out, it wouldn't be crunchy,
         now would it?
</pre>
<p>That provides better correspondence between cells in the same
column than does bullet-list syntax, but not as good as field list
syntax.  I think that were only field-list-tables available, a lot
of users would use the equivalent degenerate case:</p>
<pre class="literal-block">
.. field-list-table::
    - :1: Treat
      :2: Quantity
      :3: Description
    ...
</pre>
</li>
<li><p class="first">Another natural variant is to allow a description list with field
lists as descriptions:</p>
<pre class="literal-block">
.. list-table::
    :headrows: 1

    Treat
        :quantity: Quantity
        :descr: Description
    Albatross!
        :quantity: 299
        :descr: On a stick!
    Crunchy Frog!
        :quantity: 1499
        :descr: If we took the bones out, it wouldn't be
                crunchy, now would it?
</pre>
<p>This would make the whole first column a header column (&quot;stub&quot;).
It's limited to a single column and a single paragraph fitting on
one source line.  Also it wouldn't allow for empty cells or row
spans in the first column.  But these are limitations that we could
live with, like those of simple tables.</p>
</li>
</ol>
<p>The List-driven table feature could be done in many ways.  Each user
will have their preferred usage.  Perhaps a single &quot;list-table&quot;
directive could handle them all, depending on which options and
content are present.</p>
<p>Issues:</p>
<ul>
<li><p class="first">How to indicate that there's 1 header row?  Perhaps two lists?</p>
<pre class="literal-block">
.. list-table::

   + - Treat
     - Quantity
     - Description

   * - Albatross!
     - 299
     - On a stick!
</pre>
<p>This is probably too subtle though.  Better would be a directive
option, like <tt class="docutils literal">:headrows: 1</tt>.  An early suggestion for the header
row(s) was to use a directive option:</p>
<pre class="literal-block">
.. field-list-table::
   :header:
       - :treat: Treat
         :quantity: Quantity
         :descr: Description
   - :treat: Albatross!
     :quantity: 299
     :descr: On a stick!
</pre>
<p>But the table data is at two levels and looks inconsistent.</p>
<p>In general, we cannot extract the header row from field lists' field
names because field names cannot contain everything one might put in
a table cell.  A separate header row also allows shorter field names
and doesn't force one to rewrite the whole table when the header
text changes.  But for simpler cases, we can offer a &quot;:header:
fields&quot; option, which does extract header cells from field names:</p>
<pre class="literal-block">
.. field-list-table::
    :header: fields

    - :Treat: Albatross!
      :Quantity: 299
      :Description: On a stick!
</pre>
</li>
<li><p class="first">How to indicate the column widths?  A directive option?</p>
<pre class="literal-block">
.. list-table::
   :widths: 15 10 35
</pre>
<p>Automatic defaults from the text used?</p>
</li>
<li><p class="first">How to handle row and/or column spans?</p>
<p>In a field list, column-spans can be indicated by specifying the
first and last fields, separated by space-dash-space or ellipsis:</p>
<pre class="literal-block">
- :foo - baz: quuux
- :foo ... baz: quuux
</pre>
<p>Commas were proposed for column spans:</p>
<pre class="literal-block">
- :foo, bar: quux
</pre>
<p>But non-adjacent columns become problematic.  Should we report an
error, or duplicate the value into each span of adjacent columns (as
was suggested)?  The latter suggestion is appealing but may be too
clever.  Best perhaps to simply specify the two ends.</p>
<p>It was suggested that comma syntax should be allowed, too, in order
to allow the user to avoid trouble when changing the column order.
But changing the column order of a table with spans is not trivial;
we shouldn't make it easier to mess up.</p>
<p>One possible syntax for row-spans is to simply treat any row where a
field is missing as a row-span from the last row where it appeared.
Leaving a field empty would still be possible by writing a field
with empty content.  But this is too implicit.</p>
<p>Another way would be to require an explicit continuation marker
(<tt class="docutils literal">...</tt>/<tt class="docutils literal"><span class="pre">-&quot;-</span></tt>/<tt class="docutils literal">&quot;</tt>?) in all but the first row of a spanned
field.  Empty comments could work (&quot;..&quot;).  If implemented, the same
marker could also be supported in simple tables, which lack
row-spanning abilities.</p>
<p>Explicit markup like &quot;:rowspan:&quot; and &quot;:colspan:&quot; was also suggested.</p>
<p>Sometimes in a table, the first header row contains spans.  It may
be necessary to provide a way to specify the column field names
independently of data rows.  A directive option would do it.</p>
</li>
<li><p class="first">We could specify &quot;column-wise&quot; or &quot;row-wise&quot; ordering, with the same
markup structure.  For example, with definition data:</p>
<pre class="literal-block">
.. list-table::
   :column-wise:

   Treat
       - Albatross!
       - Crunchy Frog!
   Quantity
       - 299
       - 1499
   Description
       - On a stick!
       - If we took the bones out, it wouldn't be
         crunchy, now would it?
</pre>
</li>
<li><p class="first">A syntax for <span class="target" id="stubs-in-grid-tables">stubs in grid tables</span> is easy to imagine:</p>
<pre class="literal-block">
+------------------------++------------+----------+
| Header row, column 1   || Header 2   | Header 3 |
+========================++============+==========+
| body row 1, column 1   || column 2   | column 3 |
+------------------------++------------+----------+
</pre>
<p>Or this idea from Nick Moffitt:</p>
<pre class="literal-block">
+-----+---+---+
| XOR # T | F |
+=====+===+===+
|   T # F | T |
+-----+---+---+
|   F # T | F |
+-----+---+---+
</pre>
</li>
</ul>
</div>
<div class="section" id="auto-enumerated-lists">
<h2><a class="toc-backref" href="#id40">Auto-Enumerated Lists</a></h2>
<p>Implemented 2005-03-24: combination of variation 1 &amp; 2.</p>
<p>The advantage of auto-numbered enumerated lists would be similar to
that of auto-numbered footnotes: lists could be written and rearranged
without having to manually renumber them.  The disadvantages are also
the same: input and output wouldn't match exactly; the markup may be
ugly or confusing (depending on which alternative is chosen).</p>
<ol class="arabic">
<li><p class="first">Use the &quot;#&quot; symbol.  Example:</p>
<pre class="literal-block">
#. Item 1.
#. Item 2.
#. Item 3.
</pre>
<p>Advantages: simple, explicit.  Disadvantage: enumeration sequence
cannot be specified (limited to arabic numerals); ugly.</p>
</li>
<li><p class="first">As a variation on #1, first initialize the enumeration sequence?
For example:</p>
<pre class="literal-block">
a) Item a.
#) Item b.
#) Item c.
</pre>
<p>Advantages: simple, explicit, any enumeration sequence possible.
Disadvantages: ugly; perhaps confusing with mixed concrete/abstract
enumerators.</p>
</li>
<li><p class="first">Alternative suggested by Fred Bremmer, from experience with MoinMoin:</p>
<pre class="literal-block">
1. Item 1.
1. Item 2.
1. Item 3.
</pre>
<p>Advantages: enumeration sequence is explicit (could be multiple
&quot;a.&quot; or &quot;(I)&quot; tokens).  Disadvantages: perhaps confusing; otherwise
erroneous input (e.g., a duplicate item &quot;1.&quot;) would pass silently,
either causing a problem later in the list (if no blank lines
between items) or creating two lists (with blanks).</p>
<p>Take this input for example:</p>
<pre class="literal-block">
1. Item 1.

1. Unintentional duplicate of item 1.

2. Item 2.
</pre>
<p>Currently the parser will produce two list, &quot;1&quot; and &quot;1,2&quot; (no
warnings, because of the presence of blank lines).  Using Fred's
notation, the current behavior is &quot;1,1,2 -&gt; 1 1,2&quot; (without blank
lines between items, it would be &quot;1,1,2 -&gt; 1 [WARNING] 1,2&quot;).  What
should the behavior be with auto-numbering?</p>
<p>Fred has produced a <a class="reference external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=548802&amp;group_id=38414&amp;atid=422032">patch</a>, whose initial behavior is as follows:</p>
<pre class="literal-block">
1,1,1   -&gt; 1,2,3
1,2,2   -&gt; 1,2,3
3,3,3   -&gt; 3,4,5
1,2,2,3 -&gt; 1,2,3 [WARNING] 3
1,1,2   -&gt; 1,2 [WARNING] 2
</pre>
<p>(After the &quot;[WARNING]&quot;, the &quot;3&quot; would begin a new list.)</p>
<p>I have mixed feelings about adding this functionality to the spec &amp;
parser.  It would certainly be useful to some users (myself
included; I often have to renumber lists).  Perhaps it's too
clever, asking the parser to guess too much.  What if you <em>do</em> want
three one-item lists in a row, each beginning with &quot;1.&quot;?  You'd
have to use empty comments to force breaks.  Also, I question
whether &quot;1,2,2 -&gt; 1,2,3&quot; is optimal behavior.</p>
<p>In response, Fred came up with &quot;a stricter and more explicit rule
[which] would be to only auto-number silently if <em>all</em> the
enumerators of a list were identical&quot;.  In that case:</p>
<pre class="literal-block">
1,1,1   -&gt; 1,2,3
1,2,2   -&gt; 1,2 [WARNING] 2
3,3,3   -&gt; 3,4,5
1,2,2,3 -&gt; 1,2 [WARNING] 2,3
1,1,2   -&gt; 1,2 [WARNING] 2
</pre>
<p>Should any start-value be allowed (&quot;3,3,3&quot;), or should
auto-numbered lists be limited to begin with ordinal-1 (&quot;1&quot;, &quot;A&quot;,
&quot;a&quot;, &quot;I&quot;, or &quot;i&quot;)?</p>
</li>
<li><p class="first">Alternative proposed by Tony Ibbs:</p>
<pre class="literal-block">
#1. First item.
#3. Aha - I edited this in later.
#2. Second item.
</pre>
<p>The initial proposal required unique enumerators within a list, but
this limits the convenience of a feature of already limited
applicability and convenience.  Not a useful requirement; dropped.</p>
<p>Instead, simply prepend a &quot;#&quot; to a standard list enumerator to
indicate auto-enumeration.  The numbers (or letters) of the
enumerators themselves are not significant, except:</p>
<ul class="simple">
<li>as a sequence indicator (arabic, roman, alphabetic; upper/lower),</li>
<li>and perhaps as a start value (first list item).</li>
</ul>
<p>Advantages: explicit, any enumeration sequence possible.
Disadvantages: a bit ugly.</p>
</li>
</ol>
</div>
<div class="section" id="adjacent-citation-references">
<h2><a class="toc-backref" href="#id41">Adjacent citation references</a></h2>
<p>A special case for inline markup was proposed and implemented:
multiple citation references could be joined into one:</p>
<pre class="literal-block">
[cite1]_[cite2]_ instead of requiring [cite1]_ [cite2]_
</pre>
<p>However, this was rejected as an unwarranted exception to the rules
for inline markup.
(The main motivation for the proposal, grouping citations in the latex writer,
was implemented by recognising the second group in the example above and
transforming it into <tt class="docutils literal">\cite{cite1,cite2}</tt>.)</p>
</div>
<div class="section" id="inline-markup-recognition">
<h2><a class="toc-backref" href="#id42">Inline markup recognition</a></h2>
<p>Implemented 2011-12-05 (version 0.9):
Extended <a class="reference external" href="../../ref/rst/restructuredtext.html#inline-markup-recognition-rules">inline markup recognition rules</a>.</p>
<p>Non-ASCII whitespace, punctuation characters and &quot;international&quot; quotes are
allowed around inline markup (based on <a class="reference external" href="http://www.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values">Unicode categories</a>). The rules for
ASCII characters were not changed.</p>
<p>Rejected alternatives:</p>
<ol class="loweralpha">
<li><p class="first">Use <a class="reference external" href="http://www.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values">Unicode categories</a> for all chars (ASCII or not)</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">+1</span></kbd></td>
<td><p class="first last">comprehensible, standards based,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-1</span></kbd></td>
<td><p class="first last">many &quot;false positives&quot; need escaping,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-1</span></kbd></td>
<td><p class="first last">not backwards compatible.</p>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">full backwards compatibility</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Pi:</th><td class="field-body"><p class="first">only before start-string</p>
</td>
</tr>
<tr class="field"><th class="field-name">Pf:</th><td class="field-body"><p class="first">only behind end-string</p>
</td>
</tr>
<tr class="field"><th class="field-name">Po:</th><td class="field-body"><p class="first">&quot;conservative&quot; sorting of other punctuation:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal"><span class="pre">.,;!?\\</span></tt>:</th><td class="field-body">Close</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal"></tt>:</th><td class="field-body">Open</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">+1</span></kbd></td>
<td><p class="first last">backwards compatible,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">+1</span></kbd></td>
<td><p class="first last">logical extension of the existing rules,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-1</span></kbd></td>
<td><p class="first last">exception list for &quot;other&quot; punctuation needed,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-1</span></kbd></td>
<td><p class="first last">rules even more complicated,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-1</span></kbd></td>
<td><p class="first last">not clear how to sort &quot;other&quot; punctuation that is currently not
recognized,</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-2</span></kbd></td>
<td><p class="first last">international quoting convention like
German angular quotes not recognized.</p>
</td></tr>
</tbody>
</table>
</li>
</ol>
</div>
</div>
<div class="section" id="not-implemented">
<h1><a class="toc-backref" href="#id43">Not Implemented</a></h1>
<div class="section" id="reworking-footnotes">
<h2><a class="toc-backref" href="#id44">Reworking Footnotes</a></h2>
<p>As a further wrinkle (see <a class="reference internal" href="#reworking-explicit-markup-round-1">Reworking Explicit Markup (Round 1)</a>
above), in the wee hours of 2002-02-28 I posted several ideas for
changes to footnote syntax:</p>
<blockquote>
<ul class="simple">
<li>Change footnote syntax from <tt class="docutils literal">.. [1]</tt> to <tt class="docutils literal">_[1]</tt>? ...</li>
<li>Differentiate (with new DTD elements) author-date &quot;citations&quot;
(<tt class="docutils literal">[GVR2002]</tt>) from numbered footnotes? ...</li>
<li>Render footnote references as superscripts without &quot;[]&quot;? ...</li>
</ul>
</blockquote>
<p>These ideas are all related, and suggest changes in the
reStructuredText syntax as well as the docutils tree model.</p>
<p>The footnote has been used for both true footnotes (asides expanding
on points or defining terms) and for citations (references to external
works).  Rather than dealing with one amalgam construct, we could
separate the current footnote concept into strict footnotes and
citations.  Citations could be interpreted and treated differently
from footnotes.  Footnotes would be limited to numerical labels:
manual (&quot;1&quot;) and auto-numbered (anonymous &quot;#&quot;, named &quot;#label&quot;).</p>
<p>The footnote is the only explicit markup construct (starts with &quot;.. &quot;)
that directly translates to a visible body element.  I've always been
a little bit uncomfortable with the &quot;.. &quot; marker for footnotes because
of this; &quot;.. &quot; has a connotation of &quot;special&quot;, but footnotes aren't
especially &quot;special&quot;.  Printed texts often put footnotes at the bottom
of the page where the reference occurs (thus &quot;foot note&quot;).  Some HTML
designs would leave footnotes to be rendered the same positions where
they're defined.  Other online and printed designs will gather
footnotes into a section near the end of the document, converting them
to &quot;endnotes&quot; (perhaps using a directive in our case); but this
&quot;special processing&quot; is not an intrinsic property of the footnote
itself, but a decision made by the document author or processing
system.</p>
<p>Citations are almost invariably collected in a section at the end of a
document or section.  Citations &quot;disappear&quot; from where they are
defined and are magically reinserted at some well-defined point.
There's more of a connection to the &quot;special&quot; connotation of the &quot;.. &quot;
syntax.  The point at which the list of citations is inserted could be
defined manually by a directive (e.g., &quot;.. citations::&quot;), and/or have
default behavior (e.g., a section automatically inserted at the end of
the document) that might be influenced by options to the Writer.</p>
<p>Syntax proposals:</p>
<ul>
<li><p class="first">Footnotes:</p>
<ul>
<li><p class="first">Current syntax:</p>
<pre class="literal-block">
.. [1] Footnote 1
.. [#] Auto-numbered footnote.
.. [#label] Auto-labeled footnote.
</pre>
</li>
<li><p class="first">The syntax proposed in the original 2002-02-28 Doc-SIG post:
remove the &quot;.. &quot;, prefix a &quot;_&quot;:</p>
<pre class="literal-block">
_[1] Footnote 1
_[#] Auto-numbered footnote.
_[#label] Auto-labeled footnote.
</pre>
<p>The leading underscore syntax (earlier dropped because
<tt class="docutils literal">.. _[1]:</tt> was too verbose) is a useful reminder that footnotes
are hyperlink targets.</p>
</li>
<li><p class="first">Minimal syntax: remove the &quot;.. [&quot; and &quot;]&quot;, prefix a &quot;_&quot;, and
suffix a &quot;.&quot;:</p>
<pre class="literal-block">
_1. Footnote 1.
_#. Auto-numbered footnote.
_#label. Auto-labeled footnote.

         ``_1.``, ``_#.``, and ``_#label.`` are markers,
         like list markers.
</pre>
<p>Footnotes could be rendered something like this in HTML</p>
<blockquote>
<div class="line-block">
<div class="line">1. This is a footnote.  The brackets could be dropped</div>
<div class="line-block">
<div class="line">from the label, and a vertical bar could set them</div>
<div class="line">off from the rest of the document in the HTML.</div>
</div>
</div>
</blockquote>
<p>Two-way hyperlinks on the footnote marker (&quot;1.&quot; above) would also
help to differentiate footnotes from enumerated lists.</p>
<p>If converted to endnotes (by a directive/transform), a horizontal
half-line might be used instead.  Page-oriented output formats
would typically use the horizontal line for true footnotes.</p>
</li>
</ul>
</li>
<li><p class="first">Footnote references:</p>
<ul>
<li><p class="first">Current syntax:</p>
<pre class="literal-block">
[1]_, [#]_, [#label]_
</pre>
</li>
<li><p class="first">Minimal syntax to match the minimal footnote syntax above:</p>
<pre class="literal-block">
1_, #_, #label_
</pre>
<p>As a consequence, pure-numeric hyperlink references would not be
possible; they'd be interpreted as footnote references.</p>
</li>
</ul>
</li>
<li><p class="first">Citation references: no change is proposed from the current footnote
reference syntax:</p>
<pre class="literal-block">
[GVR2001]_
</pre>
</li>
<li><p class="first">Citations:</p>
<ul>
<li><p class="first">Current syntax (footnote syntax):</p>
<pre class="literal-block">
.. [GVR2001] Python Documentation; van Rossum, Drake, et al.;
   http://www.python.org/doc/
</pre>
</li>
<li><p class="first">Possible new syntax:</p>
<pre class="literal-block">
_[GVR2001] Python Documentation; van Rossum, Drake, et al.;
           http://www.python.org/doc/

_[DJG2002]
    Docutils: Python Documentation Utilities project; Goodger
    et al.; http://docutils.sourceforge.net/
</pre>
<p>Without the &quot;.. &quot; marker, subsequent lines would either have to
align as in one of the above, or we'd have to allow loose
alignment (I'd rather not):</p>
<pre class="literal-block">
_[GVR2001] Python Documentation; van Rossum, Drake, et al.;
    http://www.python.org/doc/
</pre>
</li>
</ul>
</li>
</ul>
<p>I proposed adopting the &quot;minimal&quot; syntax for footnotes and footnote
references, and adding citations and citation references to
reStructuredText's repertoire.  The current footnote syntax for
citations is better than the alternatives given.</p>
<p>From a reply by Tony Ibbs on 2002-03-01:</p>
<blockquote>
<p>However, I think easier with examples, so let's create one:</p>
<pre class="literal-block">
Fans of Terry Pratchett are perhaps more likely to use
footnotes [1]_ in their own writings than other people
[2]_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style [4]_, particularly in emails (not a medium that
lends itself to footnotes).

.. [1] That is, little bits of referenced text at the
   bottom of the page.
.. [2] Because Terry himself does, of course [3]_.
.. [3] Although he has the distinction of being
   *funny* when he does it, and his fans don't always
   achieve that aim.
.. [4] Presumably because it detracts from linear
   reading of the text - this is, of course, the point.
</pre>
<p>and look at it with the second syntax proposal:</p>
<pre class="literal-block">
Fans of Terry Pratchett are perhaps more likely to use
footnotes [1]_ in their own writings than other people
[2]_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style [4]_, particularly in emails (not a medium that
lends itself to footnotes).

_[1] That is, little bits of referenced text at the
     bottom of the page.
_[2] Because Terry himself does, of course [3]_.
_[3] Although he has the distinction of being
     *funny* when he does it, and his fans don't always
     achieve that aim.
_[4] Presumably because it detracts from linear
     reading of the text - this is, of course, the point.
</pre>
<p>(I note here that if I have gotten the indentation of the
footnotes themselves correct, this is clearly not as nice.  And if
the indentation should be to the left margin instead, I like that
even less).</p>
<p>and the third (new) proposal:</p>
<pre class="literal-block">
Fans of Terry Pratchett are perhaps more likely to use
footnotes 1_ in their own writings than other people
2_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style 4_, particularly in emails (not a medium that
lends itself to footnotes).

_1. That is, little bits of referenced text at the
    bottom of the page.
_2. Because Terry himself does, of course 3_.
_3. Although he has the distinction of being
    *funny* when he does it, and his fans don't always
    achieve that aim.
_4. Presumably because it detracts from linear
    reading of the text - this is, of course, the point.
</pre>
<p>I think I don't, in practice, mind the targets too much (the use
of a dot after the number helps a lot here), but I do have a
problem with the body text, in that I don't naturally separate out
the footnotes as different than the rest of the text - instead I
keep wondering why there are numbers interspered in the text.  The
use of brackets around the numbers ([ and ]) made me somehow parse
the footnote references as &quot;odd&quot; - i.e., not part of the body text
- and thus both easier to skip, and also (paradoxically) easier to
pick out so that I could follow them.</p>
<p>Thus, for the moment (and as always susceptable to argument), I'd
say -1 on the new form of footnote reference (i.e., I much prefer
the existing <tt class="docutils literal">[1]_</tt> over the proposed <tt class="docutils literal">1_</tt>), and ambivalent
over the proposed target change.</p>
<p>That leaves David's problem of wanting to distinguish footnotes
and citations - and the only thing I can propose there is that
footnotes are numeric or # and citations are not (which, as a
human being, I can probably cope with!).</p>
</blockquote>
<p>From a reply by Paul Moore on 2002-03-01:</p>
<blockquote>
<p>I think the current footnote syntax <tt class="docutils literal">[1]_</tt> is <em>exactly</em> the
right balance of distinctness vs unobtrusiveness.  I very
definitely don't think this should change.</p>
<p>On the target change, it doesn't matter much to me.</p>
</blockquote>
<p>From a further reply by Tony Ibbs on 2002-03-01, referring to the
&quot;[1]&quot; form and actual usage in email:</p>
<blockquote>
<p>Clearly this is a form people are used to, and thus we should
consider it strongly (in the same way that the usage of <tt class="docutils literal"><span class="pre">*..*</span></tt>
to mean emphasis was taken partly from email practise).</p>
<p>Equally clearly, there is something &quot;magical&quot; for people in the
use of a similar form (i.e., <tt class="docutils literal">[1]</tt>) for both footnote reference
and footnote target - it seems natural to keep them similar.</p>
<p>...</p>
<p>I think that this established plaintext usage leads me to strongly
believe we should retain square brackets at both ends of a
footnote.  The markup of the reference end (a single trailing
underscore) seems about as minimal as we can get away with.  The
markup of the target end depends on how one envisages the thing -
if &quot;..&quot; means &quot;I am a target&quot; (as I tend to see it), then that's
good, but one can also argue that the &quot;_[1]&quot; syntax has a neat
symmetry with the footnote reference itself, if one wishes (in
which case &quot;..&quot; presumably means &quot;hidden/special&quot; as David seems
to think, which is why one needs a &quot;..&quot; <em>and</em> a leading underline
for hyperlink targets.</p>
</blockquote>
<p>Given the persuading arguments voiced, we'll leave footnote &amp; footnote
reference syntax alone.  Except that these discussions gave rise to
the &quot;auto-symbol footnote&quot; concept, which has been added.  Citations
and citation references have also been added.</p>
</div>
<div class="section" id="syntax-for-questions-answers">
<h2><a class="toc-backref" href="#id45">Syntax for Questions &amp; Answers</a></h2>
<p>Implement as a generic two-column marked list?  As a standalone
(non-directive) construct?  (Is the markup ambiguous?)  Add support to
parts.contents?</p>
<p>New elements would be required.  Perhaps:</p>
<pre class="literal-block">
&lt;!ELEMENT question_list (question_list_item+)&gt;
&lt;!ATTLIST question_list
    numbering  (none | local | global)
                        #IMPLIED
    start     NUMBER    #IMPLIED&gt;
&lt;!ELEMENT question_list_item (question, answer*)&gt;
&lt;!ELEMENT question %text.model;&gt;
&lt;!ELEMENT answer (%body.elements;)+&gt;
</pre>
<p>Originally I thought of implementing a Q&amp;A list with special syntax:</p>
<pre class="literal-block">
Q: What am I?

A: You are a question-and-answer
   list.

Q: What are you?

A: I am the omniscient &quot;we&quot;.
</pre>
<p>Where each &quot;Q&quot; and &quot;A&quot; could also be numbered (e.g., &quot;Q1&quot;).  However,
a simple enumerated or bulleted list will do just fine for syntax.  A
directive could treat the list specially; e.g. the first paragraph
could be treated as a question, the remainder as the answer (multiple
answers could be represented by nested lists).  Without special
syntax, this directive becomes low priority.</p>
<p>As described in the <a class="reference external" href="http://docutils.sf.net/FAQ.html#how-can-i-mark-up-a-faq-or-other-list-of-questions-answers">FAQ</a>, no special syntax or directive is needed
for this application.</p>
</div>
</div>
<div class="section" id="tabled">
<h1><a class="toc-backref" href="#id46">Tabled</a></h1>
<div class="section" id="reworking-explicit-markup-round-2">
<h2><a class="toc-backref" href="#id47">Reworking Explicit Markup (Round 2)</a></h2>
<p>See <a class="reference internal" href="#reworking-explicit-markup-round-1">Reworking Explicit Markup (Round 1)</a> for an earlier discussion.</p>
<p>In April 2004, a new thread becan on docutils-develop: <a class="reference external" href="http://thread.gmane.org/gmane.text.docutils.devel/1386">Inconsistency
in RST markup</a>.  Several arguments were made; the first argument
begat later arguments.  Below, the arguments are paraphrased &quot;in
quotes&quot;, with responses.</p>
<ol class="arabic">
<li><p class="first">References and targets take this form:</p>
<pre class="literal-block">
targetname_

.. _targetname: stuff
</pre>
<p>But footnotes, &quot;which generate links just like targets do&quot;, are
written as:</p>
<pre class="literal-block">
[1]_

.. [1] stuff
</pre>
<p>&quot;Footnotes should be written as&quot;:</p>
<pre class="literal-block">
[1]_

.. _[1]: stuff
</pre>
<p>But they're not the same type of animal.  That's not a &quot;footnote
target&quot;, it's a <em>footnote</em>.  Being a target is not a footnote's
primary purpose (an arguable point).  It just happens to grow a
target automatically, for convenience.  Just as a section title:</p>
<pre class="literal-block">
Title
=====
</pre>
<p>isn't a &quot;title target&quot;, it's a <em>title</em>, which happens to grow a
target automatically.  The consistency is there, it's just deeper
than at first glance.</p>
<p>Also, &quot;.. [1]&quot; was chosen for footnote syntax because it closely
resembles one form of actual footnote rendering.  &quot;.. _[1]:&quot; is too
verbose; excessive punctuation is required to get the job done.</p>
<p>For more of the reasoning behind the syntax, see <a class="reference external" href="problems.html#hyperlinks">Problems With
StructuredText (Hyperlinks)</a> and
<a class="reference internal" href="#reworking-footnotes">Reworking Footnotes</a>.</p>
</li>
<li><p class="first">&quot;I expect directives to also look like <tt class="docutils literal">.. this:</tt> [one colon]
because that also closely parallels the link and footnote target
markup.&quot;</p>
<p>There are good reasons for the two-colon syntax:</p>
<blockquote>
<p>Two colons are used after the directive type for these reasons:</p>
<ul>
<li><p class="first">Two colons are distinctive, and unlikely to be used in common
text.</p>
</li>
<li><p class="first">Two colons avoids clashes with common comment text like:</p>
<pre class="literal-block">
.. Danger: modify at your own risk!
</pre>
</li>
<li><p class="first">If an implementation of reStructuredText does not recognize a
directive (i.e., the directive-handler is not installed), a
level-3 (error) system message is generated, and the entire
directive block (including the directive itself) will be
included as a literal block.  Thus &quot;::&quot; is a natural choice.</p>
</li>
</ul>
<p class="attribution">&mdash;<a class="reference external" href="../../ref/rst/restructuredtext.html#directives">restructuredtext.html#directives</a></p>
</blockquote>
<p>The last reason is not particularly compelling; it's more of a
convenient coincidence or mnemonic.</p>
</li>
<li><p class="first">&quot;Comments always seemed too easy.  I almost never write comments.
I'd have no problem writing '.. comment:' in front of my comments.
In fact, it would probably be more readable, as comments <em>should</em>
be set off strongly, because they are very different from normal
text.&quot;</p>
<p>Many people do use comments though, and some applications of
reStructuredText require it.  For example, all reStructuredText
PEPs (and this document!) have an Emacs stanza at the bottom, in a
comment.  Having to write &quot;.. comment::&quot; would be very obtrusive.</p>
<p>Comments <em>should</em> be dirt-easy to do.  It should be easy to
&quot;comment out&quot; a block of text.  Comments in programming languages
and other markup languages are invariably easy.</p>
<p>Any author is welcome to preface their comments with &quot;Comment:&quot; or
&quot;Do Not Print&quot; or &quot;Note to Editor&quot; or anything they like.  A
&quot;comment&quot; directive could easily be implemented.  It might be
confused with admonition directives, like &quot;note&quot; and &quot;caution&quot;
though.  In unrelated (and unpublished and unfinished) work, adding
a &quot;comment&quot; directive as a true document element was considered:</p>
<pre class="literal-block">
If structure is necessary, we could use a &quot;comment&quot; directive
(to avoid nonsensical DTD changes, the &quot;comment&quot; directive
could produce an untitled topic element).
</pre>
</li>
<li><p class="first">&quot;One of the goals of reStructuredText is to be <em>readable</em> by people
who don't know it.  This construction violates that: it is not at
all obvious to the uninitiated that text marked by '..' is a
comment.  On the other hand, '.. comment:' would be totally
transparent.&quot;</p>
<p>Totally transparent, perhaps, but also very obtrusive.  Another of
<a class="reference external" href="../../ref/rst/introduction.html#goals">reStructuredText's goals</a> is to be unobtrusive, and
&quot;.. comment::&quot; would violate that.  The goals of reStructuredText
are many, and they conflict.  Determining the right set of goals
and finding solutions that best fit is done on a case-by-case
basis.</p>
<p>Even readability is has two aspects.  Being readable without any
prior knowledge is one.  Being as easily read in raw form as in
processed form is the other.  &quot;..&quot; may not contribute to the former
aspect, but &quot;.. comment::&quot; would certainly detract from the latter.</p>
</li>
<li><p class="first">&quot;Recently I sent someone an rst document, and they got confused; I
had to explain to them that '..' marks comments, <em>unless</em> it's a
directive, etc...&quot;</p>
<p>The explanation of directives <em>is</em> roundabout, defining comments in
terms of not being other things.  That's definitely a wart.</p>
</li>
<li><p class="first">&quot;Under the current system, a mistyped directive (with ':' instead
of '::') will be silently ignored.  This is an error that could
easily go unnoticed.&quot;</p>
<p>A parser option/setting like &quot;--comments-on-stderr&quot; would help.</p>
</li>
<li><p class="first">&quot;I'd prefer to see double-dot-space / command / double-colon as the
standard Docutils markup-marker.  It's unusual enough to avoid
being accidently used.  Everything that starts with a double-dot
should end with a double-colon.&quot;</p>
<p>That would increase the punctuation verbosity of some constructs
considerably.</p>
</li>
<li><p class="first">Edward Loper proposed the following plan for backwards
compatibility:</p>
<blockquote>
<ol class="arabic simple">
<li>&quot;.. foo&quot; will generate a deprecation warning to stderr, and
nothing in the output (no system messages).</li>
<li>&quot;.. foo: bar&quot; will be treated as a directive foo.  If there
is no foo directive, then do the normal error output.</li>
<li>&quot;.. foo:: bar&quot; will generate a deprecation warning to
stderr, and be treated as a directive.  Or leave it valid?</li>
</ol>
<p>So some existing documents might start printing deprecation
warnings, but the only existing documents that would <em>break</em>
would be ones that say something like:</p>
<pre class="literal-block">
.. warning: this should be a comment
</pre>
<p>instead of:</p>
<pre class="literal-block">
.. warning:: this should be a comment
</pre>
<p>Here, we're trading fairly common a silent error (directive
falsely treated as a comment) for a fairly uncommon explicitly
flagged error (comment falsely treated as directive).  To make
things even easier, we could add a sentence to the
unknown-directive error.  Something like &quot;If you intended to
create a comment, please use '.. comment:' instead&quot;.</p>
</blockquote>
</li>
</ol>
<p>On one hand, I understand and sympathize with the points raised.  On
the other hand, I think the current syntax strikes the right balance
(but I acknowledge a possible lack of objectivity).  On the gripping
hand, the comment and directive syntax has become well established, so
even if it's a wart, it may be a wart we have to live with.</p>
<p>Making any of these changes would cause a lot of breakage or at least
deprecation warnings.  I'm not sure the benefit is worth the cost.</p>
<p>For now, we'll treat this as an unresolved legacy issue.</p>
</div>
</div>
<div class="section" id="to-do">
<h1><a class="toc-backref" href="#id48">To Do</a></h1>
<div class="section" id="nested-inline-markup">
<h2><a class="toc-backref" href="#id49">Nested Inline Markup</a></h2>
<p>These are collected notes on a long-discussed issue.  The original
mailing list messages should be referred to for details.</p>
<ul>
<li><p class="first">In a 2001-10-31 discussion I wrote:</p>
<blockquote>
<p>Try, for example, <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-March/001487.html">Ed Loper's 2001-03-21 post</a>, which details
some rules for nested inline markup. I think the complexity is
prohibitive for the marginal benefit. (And if you can understand
that tree without going mad, you're a better man than I. ;-)</p>
<p>Inline markup is already fragile. Allowing nested inline markup
would only be asking for trouble IMHO. If it proves absolutely
necessary, it can be added later. The rules for what can appear
inside what must be well thought out first though.</p>
<p class="attribution">&mdash;<a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-October/002354.html">http://mail.python.org/pipermail/doc-sig/2001-October/002354.html</a></p>
</blockquote>
</li>
<li><p class="first">In a 2001-11-09 Doc-SIG post, I wrote:</p>
<blockquote>
<p>The problem is that in the
what-you-see-is-more-or-less-what-you-get markup language that
is reStructuredText, the symbols used for inline markup (&quot;*&quot;,
&quot;**&quot;, &quot;`&quot;, &quot;``&quot;, etc.) may preclude nesting.</p>
</blockquote>
<p>I've rethought this position.  Nested markup is not precluded, just
tricky.  People and software parse &quot;double and 'single' quotes&quot; all
the time.  Continuing,</p>
<blockquote>
<p>I've thought over how we might implement nested inline
markup. The first algorithm (&quot;first identify the outer inline
markup as we do now, then recursively scan for nested inline
markup&quot;) won't work; counterexamples were given in my <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-November/002363.html">last post</a>.</p>
<p>The second algorithm makes my head hurt:</p>
<pre class="literal-block">
while 1:
    scan for start-string
    if found:
        push on stack
        scan for start or end string
        if new start string found:
            recurse
        elif matching end string found:
            pop stack
        elif non-matching end string found:
            if its a markup error:
                generate warning
            elif the initial start-string was misinterpreted:
                # e.g. in this case: ***strong** in emphasis*
                restart with the other interpretation
                # but it might be several layers back ...
    ...
</pre>
<p>This is similar to how the parser does section title
recognition, but sections are much more regular and
deterministic.</p>
<p>Bottom line is, I don't think the benefits are worth the effort,
even if it is possible. I'm not going to try to write the code,
at least not now. If somebody codes up a consistent, working,
general solution, I'll be happy to consider it.</p>
<p class="attribution">&mdash;<a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-November/002388.html">http://mail.python.org/pipermail/doc-sig/2001-November/002388.html</a></p>
</blockquote>
</li>
<li><p class="first">In a <a class="reference external" href="http://article.gmane.org/gmane.text.docutils.user/317">2003-05-06 Docutils-Users post</a> Paul Tremblay proposed a new
syntax to allow for easier nesting.  It eventually evolved into
this:</p>
<pre class="literal-block">
:role:[inline text]
</pre>
<p>The duplication with the existing interpreted text syntax is
problematic though.</p>
</li>
<li><p class="first">Could the parser be extended to parse nested interpreted text?</p>
<pre class="literal-block">
:emphasis:`Some emphasized text with :strong:`some more
emphasized text` in it and **perhaps** :reference:`a link``
</pre>
</li>
<li><p class="first">In a <a class="reference external" href="http://article.gmane.org/gmane.text.docutils.devel/795">2003-06-18 Docutils-Develop post</a>, Mark Nodine reported on
his implementation of a form of nested inline markup in his
Perl-based parser (unpublished).  He brought up some interesting
ideas.  The implementation was flawed, however, by the change in
semantics required for backslash escapes.</p>
</li>
<li><p class="first">Docutils-develop threads between David Abrahams, David Goodger, and
Mark Nodine (beginning <a class="reference external" href="http://thread.gmane.org/gmane.text.docutils.devel/1102">2004-01-16</a> and <a class="reference external" href="http://thread.gmane.org/gmane.text.docutils.devel/1125">2004-01-19</a>) hashed out
many of the details of a potentially successful implementation, as
described below.  David Abrahams checked in code to the &quot;nesting&quot;
branch of CVS, awaiting thorough review.</p>
</li>
</ul>
<p>It may be possible to accomplish nested inline markup in general with
a more powerful inline markup parser.  There may be some issues, but
I'm not averse to the idea of nested inline markup in general.  I just
don't have the time or inclination to write a new parser now.  Of
course, a good patch would be welcome!</p>
<p>I envisage something like this.  Explicit-role interpreted text must
be nestable.  Prefix-based is probably preferred, since suffix-based
will look like inline literals:</p>
<pre class="literal-block">
``text`:role1:`:role2:
</pre>
<p>But it can be disambiguated, so it ought to be left up to the author:</p>
<pre class="literal-block">
`\ `text`:role1:`:role2:
</pre>
<p>In addition, other forms of inline markup may be nested if
unambiguous:</p>
<pre class="literal-block">
*emphasized ``literal`` and |substitution ref| and link_*
</pre>
<p>IOW, the parser ought to be as permissive as possible.</p>
</div>
<div class="section" id="index-entries-indexes">
<h2><a class="toc-backref" href="#id50">Index Entries &amp; Indexes</a></h2>
<p>Were I writing a book with an index, I guess I'd need two
different kinds of index targets: inline/implicit and
out-of-line/explicit.  For example:</p>
<pre class="literal-block">
In this `paragraph`:index:, several words are being
`marked`:index: inline as implicit `index`:index:
entries.

.. index:: markup
.. index:: syntax

The explicit index directives above would refer to
this paragraph.  It might also make sense to allow multiple
entries in an ``index`` directive:

.. index::
    markup
    syntax
</pre>
<p>The words &quot;paragraph&quot;, &quot;marked&quot;, and &quot;index&quot; would become index
entries pointing at the words in the first paragraph.  The index
entry words appear verbatim in the text.  (Don't worry about the
ugly &quot;:index:&quot; part; if indexing is the only/main application of
interpreted text in your documents, it can be implicit and
omitted.)  The two directives provide manual indexing, where the
index entry words (&quot;markup&quot; and &quot;syntax&quot;) do not appear in the
main text.  We could combine the two directives into one:</p>
<pre class="literal-block">
.. index:: markup; syntax
</pre>
<p>Semicolons instead of commas because commas could <em>be</em> part of the
index target, like:</p>
<pre class="literal-block">
.. index:: van Rossum, Guido
</pre>
<p>Another reason for index directives is because other inline markup
wouldn't be possible within inline index targets.</p>
<p>Sometimes index entries have multiple levels.  Given:</p>
<pre class="literal-block">
.. index:: statement syntax: expression statements
</pre>
<p>In a hypothetical index, combined with other entries, it might
look like this:</p>
<pre class="literal-block">
statement syntax
    expression statements ..... 56
    assignment ................ 57
    simple statements ......... 58
    compound statements ....... 60
</pre>
<p>Inline multi-level index targets could be done too.  Perhaps
something like:</p>
<pre class="literal-block">
When dealing with `expression statements &lt;statement syntax:&gt;`,
we must remember ...
</pre>
<p>The opposite sense could also be possible:</p>
<pre class="literal-block">
When dealing with `index entries &lt;:multi-level&gt;`, there are
many permutations to consider.
</pre>
<p>Also &quot;see / see also&quot; index entries.</p>
<p>Given:</p>
<pre class="literal-block">
Here's a paragraph.

.. index:: paragraph
</pre>
<p>(The &quot;index&quot; directive above actually targets the <em>preceding</em>
object.)  The directive should produce something like this XML:</p>
<pre class="literal-block">
&lt;paragraph&gt;
&lt;index_entry text=&quot;paragraph&quot;/&gt;
Here's a paragraph.
&lt;/paragraph&gt;
</pre>
<p>This kind of content model would also allow true inline
index-entries:</p>
<pre class="literal-block">
Here's a `paragraph`:index:.
</pre>
<p>If the &quot;index&quot; role were the default for the application, it could be
dropped:</p>
<pre class="literal-block">
Here's a `paragraph`.
</pre>
<p>Both of these would result in this XML:</p>
<pre class="literal-block">
&lt;paragraph&gt;
Here's a &lt;index_entry&gt;paragraph&lt;/index_entry&gt;.
&lt;/paragraph&gt;
</pre>
<div class="section" id="from-2002-06-24-docutils-develop-posts">
<h3><a class="toc-backref" href="#id51">from 2002-06-24 docutils-develop posts</a></h3>
<blockquote>
If all of your index entries will appear verbatim in the text,
this should be sufficient.  If not (e.g., if you want &quot;Van Rossum,
Guido&quot; in the index but &quot;Guido van Rossum&quot; in the text), we'll
have to figure out a supplemental mechanism, perhaps using
substitutions.</blockquote>
<p>I've thought a bit more on this, and I came up with two possibilities:</p>
<ol class="arabic">
<li><p class="first">Using interpreted text, embed the index entry text within the
interpreted text:</p>
<pre class="literal-block">
... by `Guido van Rossum [Van Rossum, Guido]` ...
</pre>
<p>The problem with this is obvious: the text becomes cluttered and
hard to read.  The processed output would drop the text in
brackets, which goes against the spirit of interpreted text.</p>
</li>
<li><p class="first">Use substitutions:</p>
<pre class="literal-block">
... by |Guido van Rossum| ...

.. |Guido van Rossum| index:: Van Rossum, Guido
</pre>
<p>A problem with this is that each substitution definition must have
a unique name.  A subsequent <tt class="docutils literal">.. |Guido van Rossum| index:: BDFL</tt>
would be illegal.  Some kind of anonymous substitution definition
mechanism would be required, but I think that's going too far.</p>
</li>
</ol>
<p>Both of these alternatives are flawed.  Any other ideas?</p>
</div>
</div>
</div>
<div class="section" id="or-not-to-do">
<h1><a class="toc-backref" href="#id52">... Or Not To Do?</a></h1>
<p>This is the realm of the possible but questionably probable.  These
ideas are kept here as a record of what has been proposed, for
posterity and in case any of them prove to be useful.</p>
<div class="section" id="compound-enumerated-lists">
<h2><a class="toc-backref" href="#id53">Compound Enumerated Lists</a></h2>
<p>Allow for compound enumerators, such as &quot;1.1.&quot; or &quot;1.a.&quot; or &quot;1(a)&quot;, to
allow for nested enumerated lists without indentation?</p>
</div>
<div class="section" id="indented-lists">
<h2><a class="toc-backref" href="#id54">Indented Lists</a></h2>
<p>Allow for variant styles by interpreting indented lists as if they
weren't indented?  For example, currently the list below will be
parsed as a list within a block quote:</p>
<pre class="literal-block">
paragraph

  * list item 1
  * list item 2
</pre>
<p>But a lot of people seem to write that way, and HTML browsers make it
look as if that's the way it should be.  The parser could check the
contents of block quotes, and if they contain only a single list,
remove the block quote wrapper.  There would be two problems:</p>
<ol class="arabic simple">
<li>What if we actually <em>do</em> want a list inside a block quote?</li>
<li>What if such a list comes immediately after an indented construct,
such as a literal block?</li>
</ol>
<p>Both could be solved using empty comments (problem 2 already exists
for a block quote after a literal block).  But that's a hack.</p>
<p>Perhaps a runtime setting, allowing or disabling this convenience,
would be appropriate.  But that raises issues too:</p>
<blockquote>
User A, who writes lists indented (and their config file is set up
to allow it), sends a file to user B, who doesn't (and their
config file disables indented lists).  The result of processing by
the two users will be different.</blockquote>
<p>It may seem minor, but it adds ambiguity to the parser, which is bad.</p>
<p>See the <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-April/001776.html">Doc-SIG discussion starting 2001-04-18</a> with Ed Loper's
&quot;Structuring: a summary; and an attempt at EBNF&quot;, item 4 (and
follow-ups, <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-April/001789.html">here</a> and <a class="reference external" href="http://mail.python.org/pipermail/doc-sig/2001-April/001793.html">here</a>).  Also <a class="reference external" href="http://sourceforge.net/mailarchive/message.php?msg_id=3838913">docutils-users, 2003-02-17</a>
and <a class="reference external" href="http://sf.net/mailarchive/forum.php?thread_id=2957175&amp;forum_id=11444">beginning 2003-08-04</a>.</p>
</div>
<div class="section" id="sloppy-indentation-of-list-items">
<h2><a class="toc-backref" href="#id55">Sloppy Indentation of List Items</a></h2>
<p>Perhaps the indentation shouldn't be so strict.  Currently, this is
required:</p>
<pre class="literal-block">
1. First line,
   second line.
</pre>
<p>Anything wrong with this?</p>
<pre class="literal-block">
1. First line,
 second line.
</pre>
<p>Problem?</p>
<pre class="literal-block">
1. First para.

   Block quote.  (no good: requires some indent relative to first
   para)

 Second Para.

2. Have to carefully define where the literal block ends::

     Literal block

   Literal block?
</pre>
<p>Hmm...  Non-strict indentation isn't such a good idea.</p>
</div>
<div class="section" id="lazy-indentation-of-list-items">
<h2><a class="toc-backref" href="#id56">Lazy Indentation of List Items</a></h2>
<p>Another approach: Going back to the first draft of reStructuredText
(2000-11-27 post to Doc-SIG):</p>
<pre class="literal-block">
- This is the fourth item of the main list (no blank line above).
The second line of this item is not indented relative to the
bullet, which precludes it from having a second paragraph.
</pre>
<p>Change that to <em>require</em> a blank line above and below, to reduce
ambiguity.  This &quot;loosening&quot; may be added later, once the parser's
been nailed down.  However, a serious drawback of this approach is to
limit the content of each list item to a single paragraph.</p>
<div class="section" id="david-s-idea-for-lazy-indentation">
<h3><a class="toc-backref" href="#id57">David's Idea for Lazy Indentation</a></h3>
<p>Consider a paragraph in a word processor.  It is a single logical line
of text which ends with a newline, soft-wrapped arbitrarily at the
right edge of the page or screen.  We can think of a plaintext
paragraph in the same way, as a single logical line of text, ending
with two newlines (a blank line) instead of one, and which may contain
arbitrary line breaks (newlines) where it was accidentally
hard-wrapped by an application.  We can compensate for the accidental
hard-wrapping by &quot;unwrapping&quot; every unindented second and subsequent
line.  The indentation of the first line of a paragraph or list item
would determine the indentation for the entire element.  Blank lines
would be required between list items when using lazy indentation.</p>
<p>The following example shows the lazy indentation of multiple body
elements:</p>
<pre class="literal-block">
- This is the first paragraph
of the first list item.

  Here is the second paragraph
of the first list item.

- This is the first paragraph
of the second list item.

  Here is the second paragraph
of the second list item.
</pre>
<p>A more complex example shows the limitations of lazy indentation:</p>
<pre class="literal-block">
- This is the first paragraph
of the first list item.

  Next is a definition list item:

  Term
      Definition.  The indentation of the term is
required, as is the indentation of the definition's
first line.

      When the definition extends to more than
one line, lazy indentation may occur.  (This is the second
paragraph of the definition.)

- This is the first paragraph
of the second list item.

  - Here is the first paragraph of
the first item of a nested list.

  So this paragraph would be outside of the nested list,
but inside the second list item of the outer list.

But this paragraph is not part of the list at all.
</pre>
<p>And the ambiguity remains:</p>
<pre class="literal-block">
- Look at the hyphen at the beginning of the next line
- is it a second list item marker, or a dash in the text?

Similarly, we may want to refer to numbers inside enumerated
lists:

1. How many socks in a pair? There are
2. How many pants in a pair? Exactly
1. Go figure.
</pre>
<p>Literal blocks and block quotes would still require consistent
indentation for all their lines.  For block quotes, we might be able
to get away with only requiring that the first line of each contained
element be indented.  For example:</p>
<pre class="literal-block">
Here's a paragraph.

    This is a paragraph inside a block quote.
Second and subsequent lines need not be indented at all.

    - A bullet list inside
the block quote.

      Second paragraph of the
bullet list inside the block quote.
</pre>
<p>Although feasible, this form of lazy indentation has problems.  The
document structure and hierarchy is not obvious from the indentation,
making the source plaintext difficult to read.  This will also make
keeping track of the indentation while writing difficult and
error-prone.  However, these problems may be acceptable for Wikis and
email mode, where we may be able to rely on less complex structure
(few nested lists, for example).</p>
</div>
</div>
<div class="section" id="multiple-roles-in-interpreted-text">
<h2><a class="toc-backref" href="#id58">Multiple Roles in Interpreted Text</a></h2>
<p>In reStructuredText, inline markup cannot be nested (yet; <a class="reference internal" href="#nested-inline-markup">see
above</a>).  This also applies to interpreted text.  In order to
simultaneously combine multiple roles for a single piece of text, a
syntax extension would be necessary.  Ideas:</p>
<ol class="arabic">
<li><p class="first">Initial idea:</p>
<pre class="literal-block">
`interpreted text`:role1,role2:
</pre>
</li>
<li><p class="first">Suggested by Jason Diamond:</p>
<pre class="literal-block">
`interpreted text`:role1:role2:
</pre>
</li>
</ol>
<p>If a document is so complex as to require nested inline markup,
perhaps another markup system should be considered.  By design,
reStructuredText does not have the flexibility of XML.</p>
</div>
<div class="section" id="parameterized-interpreted-text">
<h2><a class="toc-backref" href="#id59">Parameterized Interpreted Text</a></h2>
<p>In some cases it may be expedient to pass parameters to interpreted
text, analogous to function calls.  Ideas:</p>
<ol class="arabic">
<li><p class="first">Parameterize the interpreted text role itself (suggested by Jason
Diamond):</p>
<pre class="literal-block">
`interpreted text`:role1(foo=bar):
</pre>
<p>Positional parameters could also be supported:</p>
<pre class="literal-block">
`CSS`:acronym(Cascading Style Sheets): is used for HTML, and
`CSS`:acronym(Content Scrambling System): is used for DVDs.
</pre>
<p>Technical problem: current interpreted text syntax does not
recognize roles containing whitespace.  Design problem: this smells
like programming language syntax, but reStructuredText is not a
programming language.</p>
</li>
<li><p class="first">Put the parameters inside the interpreted text:</p>
<pre class="literal-block">
`CSS (Cascading Style Sheets)`:acronym: is used for HTML, and
`CSS (Content Scrambling System)`:acronym: is used for DVDs.
</pre>
<p>Although this could be defined on an individual basis (per role),
we ought to have a standard.  Hyperlinks with embedded URIs already
use angle brackets; perhaps they could be used here too:</p>
<pre class="literal-block">
`CSS &lt;Cascading Style Sheets&gt;`:acronym: is used for HTML, and
`CSS &lt;Content Scrambling System&gt;`:acronym: is used for DVDs.
</pre>
<p>Do angle brackets connote URLs too much for this to be acceptable?
How about the &quot;tag&quot; connotation -- does it save them or doom them?</p>
</li>
<li><p class="first"><a class="reference internal" href="#nested-inline-markup">Nested inline markup</a> could prove useful here:</p>
<pre class="literal-block">
`CSS :def:`Cascading Style Sheets``:acronym: is used for HTML,
and `CSS :def:`Content Scrambling System``:acronym: is used for
DVDs.
</pre>
<p>Inline markup roles could even define the default roles of nested
inline markup, allowing this cleaner syntax:</p>
<pre class="literal-block">
`CSS `Cascading Style Sheets``:acronym: is used for HTML, and
`CSS `Content Scrambling System``:acronym: is used for DVDs.
</pre>
</li>
</ol>
<p>Does this push inline markup too far?  Readability becomes a serious
issue.  Substitutions may provide a better alternative (at the expense
of verbosity and duplication) by pulling the details out of the text
flow:</p>
<pre class="literal-block">
|CSS| is used for HTML, and |CSS-DVD| is used for DVDs.

.. |CSS| acronym:: Cascading Style Sheets
.. |CSS-DVD| acronym:: Content Scrambling System
   :text: CSS
</pre>
<hr class="docutils" />
<p>This whole idea may be going beyond the scope of reStructuredText.
Documents requiring this functionality may be better off using XML or
another markup system.</p>
<p>This argument comes up regularly when pushing the envelope of
reStructuredText syntax.  I think it's a useful argument in that it
provides a check on creeping featurism.  In many cases, the resulting
verbosity produces such unreadable plaintext that there's a natural
desire <em>not</em> to use it unless absolutely necessary.  It's a matter of
finding the right balance.</p>
</div>
<div class="section" id="syntax-for-interpreted-text-role-bindings">
<h2><a class="toc-backref" href="#id60">Syntax for Interpreted Text Role Bindings</a></h2>
<p>The following syntax (idea from Jeffrey C. Jacobs) could be used to
associate directives with roles:</p>
<pre class="literal-block">
.. :rewrite: class:: rewrite

`She wore ribbons in her hair and it lay with streaks of
grey`:rewrite:
</pre>
<p>The syntax is similar to that of substitution declarations, and the
directive/role association may resolve implementation issues.  The
semantics, ramifications, and implementation details would need to be
worked out.</p>
<p>The example above would implement the &quot;rewrite&quot; role as adding a
<tt class="docutils literal"><span class="pre">class=&quot;rewrite&quot;</span></tt> attribute to the interpreted text (&quot;inline&quot;
element).  The stylesheet would then pick up on the &quot;class&quot; attribute
to do the actual formatting.</p>
<p>The advantage of the new syntax would be flexibility.  Uses other than
&quot;class&quot; may present themselves.  The disadvantage is complexity:
having to implement new syntax for a relatively specialized operation,
and having new semantics in existing directives (&quot;class::&quot; would do
something different).</p>
<p>The <a class="reference external" href="../../ref/rst/directives.html#role">&quot;role&quot; directive</a> has been implemented.</p>
</div>
<div class="section" id="character-processing">
<h2><a class="toc-backref" href="#id61">Character Processing</a></h2>
<p>Several people have suggested adding some form of character processing
to reStructuredText:</p>
<ul class="simple">
<li>Some sort of automated replacement of ASCII sequences:<ul>
<li><tt class="docutils literal"><span class="pre">--</span></tt> to em-dash (or <tt class="docutils literal"><span class="pre">--</span></tt> to en-dash, and <tt class="docutils literal"><span class="pre">---</span></tt> to em-dash).</li>
<li>Convert quotes to curly quote entities.  (Essentially impossible
for HTML?  Unnecessary for TeX.)</li>
<li>Various forms of <tt class="docutils literal"><span class="pre">:-)</span></tt> to smiley icons.</li>
<li><tt class="docutils literal">&quot;\ &quot;</tt> to &amp;nbsp;.  Problem with line-wrapping though: it could
end up escaping the newline.</li>
<li>Escaped newlines to &lt;BR&gt;.</li>
<li>Escaped period or quote or dash as a disappearing catalyst to
allow character-level inline markup?</li>
</ul>
</li>
<li>XML-style character entities, such as &quot;&amp;copy;&quot; for the copyright
symbol.</li>
</ul>
<p>Docutils has no need of a character entity subsystem.  Supporting
Unicode and text encodings, character entities should be directly
represented in the text: a copyright symbol should be represented by
the copyright symbol character.  If this is not possible in an
authoring environment, a pre-processing stage can be added, or a table
of substitution definitions can be devised.</p>
<p>A &quot;unicode&quot; directive has been implemented to allow direct
specification of esoteric characters.  In combination with the
substitution construct, &quot;include&quot; files defining common sets of
character entities can be defined and used.  <a class="reference external" href="http://docutils.sf.net/tmp/charents/">A set of character
entity set definition files have been defined</a> (<a class="reference external" href="http://docutils.sf.net/tmp/charents.tgz">tarball</a>).
There's also <a class="reference external" href="http://docutils.sf.net/tmp/charents/README.html">a description and instructions for use</a>.</p>
<p>To allow for <a class="reference external" href="../../ref/rst/restructuredtext.html#character-level-inline-markup">character-level inline markup</a>, a limited form of
character processing has been added to the spec and parser: escaped
whitespace characters are removed from the processed document.  Any
further character processing will be of this functional type, rather
than of the character-encoding type.</p>
<ul>
<li><p class="first">Directive idea:</p>
<pre class="literal-block">
.. text-replace:: &quot;pattern&quot; &quot;replacement&quot;
</pre>
<ul class="simple">
<li>Support Unicode &quot;U+XXXX&quot; codes.</li>
<li>Support regexps, perhaps with alternative &quot;regexp-replace&quot;
directive.</li>
<li>Flags for regexps; &quot;:flags:&quot; option, or individuals.</li>
<li>Specifically, should the default be case-sensistive or
-insensitive?</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="page-or-line-breaks">
<h2><a class="toc-backref" href="#id62">Page Or Line Breaks</a></h2>
<ul>
<li><p class="first">Should ^L (or something else in reST) be defined to mean
force/suggest page breaks in whatever output we have?</p>
<p>A &quot;break&quot; or &quot;page-break&quot; directive would be easy to add.  A new
doctree element would be required though (perhaps &quot;break&quot;).  The
final behavior would be up to the Writer.  The directive argument
could be one of page/column/recto/verso for added flexibility.</p>
<p>Currently ^L (Python's <tt class="docutils literal">\f</tt>) characters are treated as whitespace.
They're converted to single spaces, actually, as are vertical tabs
(^K, Python's <tt class="docutils literal">\v</tt>).  It would be possible to recognize form feeds
as markup, but it requires some thought and discussion first.  Are
there any downsides?  Many editing environments do not allow the
insertion of control characters.  Will it cause any harm?  It would
be useful as a shorthand for the directive.</p>
<p>It's common practice to use ^L before Emacs &quot;Local Variables&quot;
lists:</p>
<pre class="literal-block">
^L
..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
</pre>
<p>These are already present in many PEPs and Docutils project
documents.  From the Emacs manual (info):</p>
<blockquote>
<p>A &quot;local variables list&quot; goes near the end of the file, in the
last page.  (It is often best to put it on a page by itself.)</p>
</blockquote>
<p>It would be unfortunate if this construct caused a final blank page
to be generated (for those Writers that recognize the page breaks).
We'll have to add a transform that looks for a &quot;break&quot; plus zero or
more comments at the end of a document, and removes them.</p>
<p>Probably a bad idea because there is no such thing as a page in a
generic document format.</p>
</li>
<li><p class="first">Could the &quot;break&quot; concept above be extended to inline forms?
E.g. &quot;^L&quot; in the middle of a sentence could cause a line break.
Only recognize it at the end of a line (i.e., <tt class="docutils literal">\f\n</tt>)?</p>
<p>Or is formfeed inappropriate?  Perhaps vertical tab (<tt class="docutils literal">\v</tt>), but
even that's a stretch.  Can't use carriage returns, since they're
commonly used for line endings.</p>
<p>Probably a bad idea as well because we do not want to use control
characters for well-readable and well-writable markup, and after all
we have the line block syntax for line breaks.</p>
</li>
</ul>
</div>
<div class="section" id="superscript-markup">
<h2><a class="toc-backref" href="#id63">Superscript Markup</a></h2>
<p>Add <tt class="docutils literal">^superscript^</tt> inline markup?  The only common non-markup uses
of &quot;^&quot; I can think of are as short hand for &quot;superscript&quot; itself and
for describing control characters (&quot;^C to cancel&quot;).  The former
supports the proposed syntax, and it could be argued that the latter
ought to be literal text anyhow (e.g. &quot;<tt class="docutils literal">^C</tt> to cancel&quot;).</p>
<p>However, superscripts are seldom needed, and new syntax would break
existing documents.  When it's needed, the <tt class="docutils literal">:superscript:</tt>
(<tt class="docutils literal">:sup:</tt>) role can we used as well.</p>
</div>
<div class="section" id="code-execution">
<h2><a class="toc-backref" href="#id64">Code Execution</a></h2>
<p>Add the following directives?</p>
<ul>
<li><p class="first">&quot;exec&quot;: Execute Python code &amp; insert the results.  Call it
&quot;python&quot; to allow for other languages?</p>
</li>
<li><p class="first">&quot;system&quot;: Execute an <tt class="docutils literal">os.system()</tt> call, and insert the results
(possibly as a literal block).  Definitely dangerous!  How to make
it safe?  Perhaps such processing should be left outside of the
document, in the user's production system (a makefile or a script or
whatever).  Or, the directive could be disabled by default and only
enabled with an explicit command-line option or config file setting.
Even then, an interactive prompt may be useful, such as:</p>
<blockquote>
<p>The file.txt document you are processing contains a &quot;system&quot;
directive requesting that the <tt class="docutils literal">sudo rm <span class="pre">-rf</span> /</tt> command be
executed.  Allow it to execute?  (y/N)</p>
</blockquote>
</li>
<li><p class="first">&quot;eval&quot;: Evaluate an expression &amp; insert the text.  At parse
time or at substitution time?  Dangerous?  Perhaps limit to canned
macros; see <a class="reference external" href="../todo.html#text-date">text.date</a>.</p>
</li>
</ul>
<p>It's too dangerous (or too complicated in the case of &quot;eval&quot;).  We do
not want to have such things in the core.</p>
</div>
<div class="section" id="encoding-directive">
<h2><a class="toc-backref" href="#id65"><tt class="docutils literal">encoding</tt> Directive</a></h2>
<p>Add an &quot;encoding&quot; directive to specify the character encoding of the
input data?  Not a good idea for the following reasons:</p>
<ul class="simple">
<li>When it sees the directive, the parser will already have read the
input data, and encoding determination will already have been done.</li>
<li>If a file with an &quot;encoding&quot; directive is edited and saved with
a different encoding, the directive may cause data corruption.</li>
</ul>
</div>
<div class="section" id="support-for-annotations">
<h2><a class="toc-backref" href="#id66">Support for Annotations</a></h2>
<p>Add an &quot;annotation&quot; role, as the equivalent of the HTML &quot;title&quot;
attribute?  This is secondary information that may &quot;pop up&quot; when the
pointer hovers over the main text.  A corresponding directive would be
required to associate annotations with the original text (by name, or
positionally as in anonymous targets?).</p>
<p>There have not been many requests for such feature, though.  Also,
cluttering WYSIWYG plaintext with annotations may not seem like a good
idea, and there is no &quot;tool tip&quot; in formats other than HTML.</p>
</div>
<div class="section" id="term-role">
<h2><a class="toc-backref" href="#id67"><tt class="docutils literal">term</tt> Role</a></h2>
<p>Add a &quot;term&quot; role for unfamiliar or specialized terminology?  Probably
not; there is no real use case, and emphasis is enough for most cases.</p>
</div>
<div class="section" id="object-references">
<h2><a class="toc-backref" href="#id68">Object references</a></h2>
<p>We need syntax for <a class="reference external" href="../todo.html#object-numbering-and-object-references">object references</a>.</p>
<blockquote>
<ul>
<li><p class="first">Parameterized substitutions?  For example:</p>
<pre class="literal-block">
See |figure (figure name)| on |page (figure name)|.

.. |figure (name)| figure-ref:: (name)
.. |page (name)| page-ref:: (name)
</pre>
<p>The result would be:</p>
<pre class="literal-block">
See figure 3.11 on page 157.
</pre>
<p>But this would require substitution directives to be processed at
reference-time, not at definition-time as they are now.  Or,
perhaps the directives could just leave <tt class="docutils literal">pending</tt> elements
behind, and the transforms do the work?  How to pass the data
through? Too complicated. Use interpreted text roles.</p>
</li>
</ul>
</blockquote>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="alternatives.txt">View document source</a>.
Generated on: 2013-03-22 08:22 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
