<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Chapter 18. Partitioning</title>
<link rel="stylesheet" href="mvl.css" type="text/css" />
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1 + chunker.py v1.9.1" />
<link rel="start" href="index.html" title="{book-title}" />
<link rel="up" href="" title="" />
<link rel="prev" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3" />
<link rel="next" href="stored-programs-views.html" title="Chapter 19. Stored Programs and Views" />
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1377579534+*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">Chapter 18. Partitioning</th>
</tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="mysql-cluster.html">Prev</a> </td>
<th width="60%" align="center"></th>
<td width="20%" align="right"> <a accesskey="n" href="stored-programs-views.html">Next</a></td>
</tr>
</table>
<hr>
</div>
<div class="chapter">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a name="partitioning"></a>Chapter 18. Partitioning</h1>

</div>

</div>

</div>
<div class="toc">
<p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="partitioning.html#partitioning-overview">18.1. Overview of Partitioning in MySQL</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-types">18.2. Partitioning Types</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-range">18.2.1. <code class="literal">RANGE</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">18.2.2. <code class="literal">LIST</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">18.2.3. <code class="literal">COLUMNS</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">18.2.4. <code class="literal">HASH</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">18.2.5. <code class="literal">KEY</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">18.2.6. Subpartitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">18.2.7. How MySQL Partitioning Handles <code class="literal">NULL</code></a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-management">18.3. Partition Management</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">18.3.1. Management of <code class="literal">RANGE</code> and <code class="literal">LIST</code>
        Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">18.3.2. Management of <code class="literal">HASH</code> and <code class="literal">KEY</code>
Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">18.3.3. Exchanging Partitions and Subpartitions with Tables</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">18.3.4. Maintenance of Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">18.3.5. Obtaining Information About Partitions</a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-pruning">18.4. Partition Pruning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-selection">18.5. Partition Selection</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations">18.6. Restrictions and Limitations on Partitioning</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">18.6.1. Partitioning Keys, Primary Keys, and Unique Keys</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">18.6.2. Partitioning Limitations Relating to Storage Engines</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">18.6.3. Partitioning Limitations Relating to Functions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-locking">18.6.4. Partitioning and Locking</a></span></dt></dl></dd></dl>
</div>
<a class="indexterm" name="idp126653264"></a><a class="indexterm" name="idp126654336"></a><a class="indexterm" name="idp126655408"></a><a class="indexterm" name="idp126656896"></a><p>
    This chapter discusses MySQL's implementation of
    <em class="firstterm">user-defined partitioning</em>. You can determine
    whether your MySQL Server supports partitioning by checking the
    output of the <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.26. SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> statement,
    as shown here:
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PLUGINS;</code></strong>
+------------+----------+----------------+---------+---------+
| Name       | Status   | Type           | Library | License |
+------------+----------+----------------+---------+---------+
| binlog     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
<span class="bold"><strong>| partition  | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |</strong></span>
| ARCHIVE    | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| BLACKHOLE  | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| CSV        | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| FEDERATED  | DISABLED | STORAGE ENGINE | NULL    | GPL     |
| MEMORY     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| InnoDB     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| MRG_MYISAM | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| MyISAM     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| ndbcluster | DISABLED | STORAGE ENGINE | NULL    | GPL     |
+------------+----------+----------------+---------+---------+
11 rows in set (0.00 sec)
</pre><p>
    You can also check the
    <a class="link" href="information-schema.html#plugins-table" title="20.15. The INFORMATION_SCHEMA PLUGINS Table"><code class="literal">INFORMATION_SCHEMA.PLUGINS</code></a> table with a
    query similar to this one:
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_NAME as Name,</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_VERSION as Version,</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_STATUS as Status</code></strong> 
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong> 
    -&gt; <strong class="userinput"><code>WHERE PLUGIN_TYPE='STORAGE ENGINE';</code></strong>
+--------------------+---------+--------+
| Name               | Version | Status |
+--------------------+---------+--------+
| binlog             | 1.0     | ACTIVE |
| CSV                | 1.0     | ACTIVE |
| MEMORY             | 1.0     | ACTIVE |
| MRG_MYISAM         | 1.0     | ACTIVE |
| MyISAM             | 1.0     | ACTIVE |
| PERFORMANCE_SCHEMA | 0.1     | ACTIVE |
| BLACKHOLE          | 1.0     | ACTIVE |
| ARCHIVE            | 3.0     | ACTIVE |
| InnoDB             | 5.6     | ACTIVE |
<span class="bold"><strong>| partition          | 1.0     | ACTIVE |</strong></span>
+--------------------+---------+--------+
10 rows in set (0.00 sec)
</pre><p>
    In either case, if you do not see the <code class="literal">partition</code>
    plugin listed with the value <code class="literal">ACTIVE</code> for the
    <code class="literal">Status</code> column in the output (shown in bold text
    in each of the examples just given), then your version of MySQL was
    not built with partitioning support.
  </p><p>
    MySQL 5.6 Community binaries provided by Oracle include
    partitioning support. For information about partitioning support
    offered in commercial MySQL Server binaries, see <em class="citetitle">MySQL
    Enterprise Server 5.1</em> on the MySQL Web site at
    <code class="uri">http://www.mysql.com/products/enterprise/server.html</code>.
  </p><p>
    To enable partitioning if you are compiling MySQL 5.6
    from source, the build must be configured with the
    <a class="link" href="installing.html#option_cmake_storage_engine_options" title="2.9.4.  Storage Engine Options"><code class="option">-DWITH_PARTITION_STORAGE_ENGINE</code></a>
    option. For more information about building MySQL, see
    <a class="xref" href="installing.html#source-installation" title="2.9. Installing MySQL from Source">Section 2.9, “Installing MySQL from Source”</a>.
  </p><p>
    If your MySQL binary is built with partitioning support, nothing
    further needs to be done to enable it (for example, no special
    entries are required in your <code class="filename">my.cnf</code> file).
  </p><p>
    If you want to disable partitioning support, you can start the MySQL
    Server with the <a class="link" href="server-administration.html#option_mysqld_skip-partition"><code class="option">--skip-partition</code></a>
    option, in which case the value of
    <a class="link" href="server-administration.html#sysvar_have_partitioning"><code class="literal">have_partitioning</code></a> is
    <code class="literal">DISABLED</code>. When partitioning support is disabled,
    you can see any existing partitioned tables and drop them (although
    doing this is not advised), but you cannot otherwise manipulate them
    or access their data.
  </p><p>
    An introduction to partitioning and partitioning concepts may be
    found in <a class="xref" href="partitioning.html#partitioning-overview" title="18.1. Overview of Partitioning in MySQL">Section 18.1, “Overview of Partitioning in MySQL”</a>.
  </p><p>
    MySQL supports several types of partitioning, which are discussed in
    <a class="xref" href="partitioning.html#partitioning-types" title="18.2. Partitioning Types">Section 18.2, “Partitioning Types”</a>, as well as subpartitioning,
    which is described in <a class="xref" href="partitioning.html#partitioning-subpartitions" title="18.2.6. Subpartitioning">Section 18.2.6, “Subpartitioning”</a>.
  </p><p>
    Methods of adding, removing, and altering partitions in existing
    partitioned tables are covered in
    <a class="xref" href="partitioning.html#partitioning-management" title="18.3. Partition Management">Section 18.3, “Partition Management”</a>.
  </p><p>
    Table maintenance commands for use with partitioned tables are
    discussed in <a class="xref" href="partitioning.html#partitioning-maintenance" title="18.3.4. Maintenance of Partitions">Section 18.3.4, “Maintenance of Partitions”</a>.
  </p><p>
    The <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table in the
    <code class="literal">INFORMATION_SCHEMA</code> database provides information
    about partitions and partitioned tables. See
    <a class="xref" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table">Section 20.14, “The <code class="literal">INFORMATION_SCHEMA PARTITIONS</code> Table”</a>, for more information; for some
    examples of queries against this table, see
    <a class="xref" href="partitioning.html#partitioning-handling-nulls" title="18.2.7. How MySQL Partitioning Handles NULL">Section 18.2.7, “How MySQL Partitioning Handles <code class="literal">NULL</code>”</a>.
  </p><p>
    For known issues with partitioning in MySQL 5.6, see
    <a class="xref" href="partitioning.html#partitioning-limitations" title="18.6. Restrictions and Limitations on Partitioning">Section 18.6, “Restrictions and Limitations on Partitioning”</a>.
  </p><p>
    You may also find the following resources to be useful when working
    with partitioned tables.
  </p><a class="indexterm" name="idp126691408"></a><p><b>Additional Resources. </b>
      Other sources of information about user-defined partitioning in
      MySQL include the following:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="ulink" href="http://forums.mysql.com/list.php?106" target="_top">MySQL Partitioning
        Forum</a>
      </p><p>
        This is the official discussion forum for those interested in or
        experimenting with MySQL Partitioning technology. It features
        announcements and updates from MySQL developers and others. It
        is monitored by members of the Partitioning Development and
        Documentation Teams.
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://mikaelronstrom.blogspot.com/" target="_top">Mikael
        Ronström's Blog</a>
      </p><p>
        MySQL Partitioning Architect and Lead Developer Mikael Ronström
        frequently posts articles here concerning his work with MySQL
        Partitioning and MySQL Cluster.
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://www.planetmysql.org/" target="_top">PlanetMySQL</a>
      </p><p>
        A MySQL news site featuring MySQL-related blogs, which should be
        of interest to anyone using my MySQL. We encourage you to check
        here for links to blogs kept by those working with MySQL
        Partitioning, or to have your own blog added to those covered.
</p></li></ul>
</div>
<p>
    MySQL 5.6 binaries are available from
    <a class="ulink" href="http://dev.mysql.com/downloads/mysql/5.6.html" target="_top">http://dev.mysql.com/downloads/mysql/5.6.html</a>.
    However, for the latest partitioning bugfixes and feature additions,
    you can obtain the source from our Bazaar repository. To enable
    partitioning, the build must be configured with the
    <a class="link" href="installing.html#option_cmake_storage_engine_options" title="2.9.4.  Storage Engine Options"><code class="option">-DWITH_PARTITION_STORAGE_ENGINE</code></a>
    option. For more information about building MySQL, see
    <a class="xref" href="installing.html#source-installation" title="2.9. Installing MySQL from Source">Section 2.9, “Installing MySQL from Source”</a>. If you have problems
    compiling a partitioning-enabled MySQL 5.6 build, check
    the <a class="ulink" href="http://forums.mysql.com/list.php?106" target="_top">MySQL Partitioning
    Forum</a> and ask for assistance there if you do not find a
    solution to your problem already posted.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-overview"></a>18.1. Overview of Partitioning in MySQL</h2>
</div>
</div>
</div>
<a class="indexterm" name="idp126705856"></a><p>
      This section provides a conceptual overview of partitioning in
      MySQL 5.6.
    </p><p>
      For information on partitioning restrictions and feature
      limitations, see <a class="xref" href="partitioning.html#partitioning-limitations" title="18.6. Restrictions and Limitations on Partitioning">Section 18.6, “Restrictions and Limitations on Partitioning”</a>.
    </p><p>
      The SQL standard does not provide much in the way of guidance
      regarding the physical aspects of data storage. The SQL language
      itself is intended to work independently of any data structures or
      media underlying the schemas, tables, rows, or columns with which
      it works. Nonetheless, most advanced database management systems
      have evolved some means of determining the physical location to be
      used for storing specific pieces of data in terms of the file
      system, hardware or even both. In MySQL, the
      <code class="literal">InnoDB</code> storage engine has long supported the
      notion of a tablespace, and the MySQL Server, even prior to the
      introduction of partitioning, could be configured to employ
      different physical directories for storing different databases
      (see <a class="xref" href="optimization.html#symbolic-links" title="8.11.3.1. Using Symbolic Links">Section 8.11.3.1, “Using Symbolic Links”</a>, for an explanation of how
      this is done).
    </p><p>
      <em class="firstterm">Partitioning</em> takes this notion a step
      further, by enabling you to distribute portions of individual
      tables across a file system according to rules which you can set
      largely as needed. In effect, different portions of a table are
      stored as separate tables in different locations. The
      user-selected rule by which the division of data is accomplished
      is known as a <em class="firstterm">partitioning function</em>, which
      in MySQL can be the modulus, simple matching against a set of
      ranges or value lists, an internal hashing function, or a linear
      hashing function. The function is selected according to the
      partitioning type specified by the user, and takes as its
      parameter the value of a user-supplied expression. This expression
      can be a column value, a function acting on one or more column
      values, or a set of one or more column values, depending on the
      type of partitioning that is used.
    </p><p>
      In the case of <code class="literal">RANGE</code>, <code class="literal">LIST</code>,
      and [<code class="literal">LINEAR</code>] <code class="literal">HASH</code>
      partitioning, the value of the partitioning column is passed to
      the partitioning function, which returns an integer value
      representing the number of the partition in which that particular
      record should be stored. This function must be nonconstant and
      nonrandom. It may not contain any queries, but may use an SQL
      expression that is valid in MySQL, as long as that expression
      returns either <code class="literal">NULL</code> or an integer
      <em class="replaceable"><code>intval</code></em> such that
    </p><pre class="programlisting">-MAXVALUE &lt;= <em class="replaceable"><code>intval</code></em> &lt;= MAXVALUE
</pre><p>
      (<code class="literal">MAXVALUE</code> is used to represent the least upper
      bound for the type of integer in question.
      <code class="literal">-MAXVALUE</code> represents the greatest lower bound.)
    </p><p>
      For [<code class="literal">LINEAR</code>] <code class="literal">KEY</code>,
      <code class="literal">RANGE COLUMNS</code>, and <code class="literal">LIST
      COLUMNS</code> partitioning, the partitioning expression
      consists of a list of one or more columns.
    </p><p>
      For [<code class="literal">LINEAR</code>] <code class="literal">KEY</code>
      partitioning, the partitioning function is supplied by MySQL.
    </p><p>
      For more information about permitted partitioning column types and
      partitioning functions, see <a class="xref" href="partitioning.html#partitioning-types" title="18.2. Partitioning Types">Section 18.2, “Partitioning Types”</a>,
      as well as <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>, which provides
      partitioning syntax descriptions and additional examples. For
      information about restrictions on partitioning functions, see
      <a class="xref" href="partitioning.html#partitioning-limitations-functions" title="18.6.3. Partitioning Limitations Relating to Functions">Section 18.6.3, “Partitioning Limitations Relating to Functions”</a>.
    </p><p>
      This is known as <em class="firstterm">horizontal
      partitioning</em>—that is, different rows of a table
      may be assigned to different physical partitions. MySQL
      5.6 does not support <em class="firstterm">vertical
      partitioning</em>, in which different columns of a table
      are assigned to different physical partitions. There are not at
      this time any plans to introduce vertical partitioning into MySQL
      5.6.
    </p><p>
      For information about determining whether your MySQL Server binary
      supports user-defined partitioning, see
      <a class="xref" href="partitioning.html" title="Chapter 18. Partitioning">Chapter 18, <i>Partitioning</i></a>.
    </p><p>
      For creating partitioned tables, you can use most storage engines
      that are supported by your MySQL server; the MySQL partitioning
      engine runs in a separate layer and can interact with any of
      these. In MySQL 5.6, all partitions of the same
      partitioned table must use the same storage engine; for
      example, you cannot use <code class="literal">MyISAM</code> for one
      partition and <code class="literal">InnoDB</code> for another. However,
      there is nothing preventing you from using different storage
      engines for different partitioned tables on the same MySQL server
      or even in the same database.
    </p><p>
      MySQL partitioning cannot be used with the
      <code class="literal">MERGE</code>, <code class="literal">CSV</code>, or
      <code class="literal">FEDERATED</code> storage engines.
    </p><p>
      Partitioning by <code class="literal">KEY</code> or <code class="literal">LINEAR
      KEY</code> is possible with <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a>,
      but other types of user-defined partitioning are not supported for
      tables using this storage engine. In addition, an
      <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table that employs user-defined
      partitioning must have an explicit primary key, and any columns
      referenced in the table's partitioning expression must be
      part of the primary key. However, if no columns are listed in the
      <code class="literal">PARTITION BY KEY</code> or <code class="literal">PARTITION BY
      LINEAR KEY</code> clause of the <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
      TABLE</code></a> or
      <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
      TABLE</code></a> statement used to create or modify a
      user-partitioned <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table, then the
      table is not required to have an explicit primary key. For more
      information, see
      <a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-syntax" title="17.1.6.1. Noncompliance with SQL Syntax in MySQL Cluster">Section 17.1.6.1, “Noncompliance with SQL Syntax in MySQL Cluster”</a>.
    </p><p>
      To employ a particular storage engine for a partitioned table, it
      is necessary only to use the <code class="literal">[STORAGE] ENGINE</code>
      option just as you would for a nonpartitioned table. However, you
      should keep in mind that <code class="literal">[STORAGE] ENGINE</code> (and
      other table options) need to be listed <span class="emphasis"><em>before</em></span>
      any partitioning options are used in a <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
      TABLE</code></a> statement. This example shows how to create a
      table that is partitioned by hash into 6 partitions and which uses
      the <code class="literal">InnoDB</code> storage engine:
    </p><pre class="programlisting">CREATE TABLE ti (id INT, amount DECIMAL(7,2), tr_date DATE)
    ENGINE=INNODB
    PARTITION BY HASH( MONTH(tr_date) )
    PARTITIONS 6;</pre><p>
      Each <code class="literal">PARTITION</code> clause can include a
      <code class="literal">[STORAGE] ENGINE</code> option, but in MySQL
      5.6 this has no effect.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p xmlns="">
        Partitioning applies to all data and indexes of a table; you
        cannot partition only the data and not the indexes, or
        <span class="foreignphrase"><em class="foreignphrase">vice versa</em></span>, nor can you partition
        only a portion of the table.
</p>
</div>
<p>
      Data and indexes for each partition can be assigned to a specific
      directory using the <code class="literal">DATA DIRECTORY</code> and
      <code class="literal">INDEX DIRECTORY</code> options for the
      <code class="literal">PARTITION</code> clause of the
      <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement used to
      create the partitioned table.
    </p><p>
      The <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
      DIRECTORY</code> options have no effect when defining
      partitions for tables using the <code class="literal">InnoDB</code> storage
      engine.
    </p><p>
      <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
      DIRECTORY</code> are not supported for individual partitions or
      subpartitions on Windows. These options are ignored on Windows,
      except that a warning is generated.
    </p><a class="indexterm" name="idp126762160"></a><p>
      In addition, <code class="literal">MAX_ROWS</code> and
      <code class="literal">MIN_ROWS</code> can be used to determine the maximum
      and minimum numbers of rows, respectively, that can be stored in
      each partition. The <code class="literal">MAX_ROWS</code> option can be
      useful for causing MySQL Cluster tables to be created with extra
      partitions, thus allowing for greater storage of hash indexes. See
      the documentation for the
      <a class="link" href="mysql-cluster.html#ndbparam-ndbd-datamemory"><code class="literal">DataMemory</code></a> data node
      configuration parameter, as well as
      <a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups" title="17.1.2. MySQL Cluster Nodes, Node Groups, Replicas, and Partitions">Section 17.1.2, “MySQL Cluster Nodes, Node Groups, Replicas, and Partitions”</a>, for more
      information.
    </p><a class="indexterm" name="idp126768016"></a><p>
      Some advantages of partitioning are listed here:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Partitioning makes it possible to store more data in one table
          than can be held on a single disk or file system partition.
        </p></li><li class="listitem"><p>
          Data that loses its usefulness can often be easily removed
          from a partitioned table by dropping the partition (or
          partitions) containing only that data. Conversely, the process
          of adding new data can in some cases be greatly facilitated by
          adding one or more new partitions for storing specifically
          that data.
        </p></li><li class="listitem"><p>
          Some queries can be greatly optimized in virtue of the fact
          that data satisfying a given <code class="literal">WHERE</code> clause
          can be stored only on one or more partitions, which
          automatically excluding any remaining partitions from the
          search. Because partitions can be altered after a partitioned
          table has been created, you can reorganize your data to
          enhance frequent queries that may not have been often used
          when the partitioning scheme was first set up. This ability to
          exclude non-matching partitions (and thus any rows they
          contain) is often referred to as <em class="firstterm">partition
          pruning</em>. For more information, see
          <a class="xref" href="partitioning.html#partitioning-pruning" title="18.4. Partition Pruning">Section 18.4, “Partition Pruning”</a>.
        </p><p>
          In addition, MySQL 5.6 supports explicit
          partition selection for queries. For example,
          <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT * FROM t
          PARTITION (p0,p1) WHERE c &lt; 5</code></a> selects only those
          rows in partitions <code class="literal">p0</code> and
          <code class="literal">p1</code> that match the <code class="literal">WHERE</code>
          condition. In this case, MySQL does not check any other
          partitions of table <code class="literal">t</code>; this can greatly
          speed up queries when you already know which partition or
          partitions you wish to examine. Partition selection is also
          supported for the data modification statements
          <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a>,
          <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a>,
          <a class="link" href="sql-syntax.html#replace" title="13.2.8. REPLACE Syntax"><code class="literal">REPLACE</code></a>,
          <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
          <a class="link" href="sql-syntax.html#load-data" title="13.2.6. LOAD DATA INFILE Syntax"><code class="literal">LOAD DATA</code></a>,
          <a class="link" href="sql-syntax.html#load-xml" title="13.2.7. LOAD XML Syntax"><code class="literal">LOAD XML</code></a>. See the descriptions
          of these statements for more information and examples.
</p></li></ul>
</div>
<p>
      Other benefits usually associated with partitioning include those
      in the following list. These features are not currently
      implemented in MySQL Partitioning, but are high on our list of
      priorities.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Queries involving aggregate functions such as
          <a class="link" href="functions.html#function_sum"><code class="literal">SUM()</code></a> and
          <a class="link" href="functions.html#function_count"><code class="literal">COUNT()</code></a> can easily be
          parallelized. A simple example of such a query might be
          <code class="literal">SELECT salesperson_id, COUNT(orders) as order_total
          FROM sales GROUP BY salesperson_id;</code>. By
          <span class="quote">“<span class="quote">parallelized,</span>”</span> we mean that the query can be run
          simultaneously on each partition, and the final result
          obtained merely by summing the results obtained for all
          partitions.
        </p></li><li class="listitem"><p>
          Achieving greater query throughput in virtue of spreading data
          seeks over multiple disks.
</p></li></ul>
</div>
<p>
      Be sure to check this section and chapter frequently for updates
      as MySQL Partitioning development continues.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-types"></a>18.2. Partitioning Types</h2>

</div>

</div>

</div>
<div class="toc">
<dl><dt><span class="section"><a href="partitioning.html#partitioning-range">18.2.1. <code class="literal">RANGE</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">18.2.2. <code class="literal">LIST</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">18.2.3. <code class="literal">COLUMNS</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">18.2.4. <code class="literal">HASH</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">18.2.5. <code class="literal">KEY</code> Partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">18.2.6. Subpartitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">18.2.7. How MySQL Partitioning Handles <code class="literal">NULL</code></a></span></dt></dl>
</div>
<a class="indexterm" name="idp126792912"></a><p>
      This section discusses the types of partitioning which are
      available in MySQL 5.6. These include the types
      listed here:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b><code class="literal">RANGE</code> partitioning. </b>
            This type of partitioning assigns rows to partitions based
            on column values falling within a given range. See
            <a class="xref" href="partitioning.html#partitioning-range" title="18.2.1. RANGE Partitioning">Section 18.2.1, “<code class="literal">RANGE</code> Partitioning”</a>. For information about
            an extension to this type, <code class="literal">RANGE COLUMNS</code>,
            see <a class="xref" href="partitioning.html#partitioning-columns-range" title="18.2.3.1. RANGE COLUMNS partitioning">Section 18.2.3.1, “<code class="literal">RANGE COLUMNS</code> partitioning”</a>.
          </p></li><li class="listitem"><p><b><code class="literal">LIST</code> partitioning. </b>
            Similar to partitioning by <code class="literal">RANGE</code>, except
            that the partition is selected based on columns matching one
            of a set of discrete values. See
            <a class="xref" href="partitioning.html#partitioning-list" title="18.2.2. LIST Partitioning">Section 18.2.2, “<code class="literal">LIST</code> Partitioning”</a>. For information about
            an extension to this type, <code class="literal">LIST COLUMNS</code>,
            see <a class="xref" href="partitioning.html#partitioning-columns-list" title="18.2.3.2. LIST COLUMNS partitioning">Section 18.2.3.2, “<code class="literal">LIST COLUMNS</code> partitioning”</a>.
          </p></li><li class="listitem"><p><b><code class="literal">HASH</code> partitioning. </b>
            With this type of partitioning, a partition is selected
            based on the value returned by a user-defined expression
            that operates on column values in rows to be inserted into
            the table. The function may consist of any expression valid
            in MySQL that yields a nonnegative integer value. An
            extension to this type, <code class="literal">LINEAR HASH</code>, is
            also available. See <a class="xref" href="partitioning.html#partitioning-hash" title="18.2.4. HASH Partitioning">Section 18.2.4, “<code class="literal">HASH</code> Partitioning”</a>.
          </p></li><li class="listitem"><p><b><code class="literal">KEY</code> partitioning. </b>
            This type of partitioning is similar to partitioning by
            <code class="literal">HASH</code>, except that only one or more
            columns to be evaluated are supplied, and the MySQL server
            provides its own hashing function. These columns can contain
            other than integer values, since the hashing function
            supplied by MySQL guarantees an integer result regardless of
            the column data type. An extension to this type,
            <code class="literal">LINEAR KEY</code>, is also available. See
            <a class="xref" href="partitioning.html#partitioning-key" title="18.2.5. KEY Partitioning">Section 18.2.5, “<code class="literal">KEY</code> Partitioning”</a>.
</p></li></ul>
</div>
<a class="indexterm" name="idp126812864"></a><a class="indexterm" name="idp126814352"></a><p>
      A very common use of database partitioning is to segregate data by
      date. Some database systems support explicit date partitioning,
      which MySQL does not implement in 5.6. However, it is
      not difficult in MySQL to create partitioning schemes based on
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
      <a class="link" href="data-types.html#time" title="11.3.2. The TIME Type"><code class="literal">TIME</code></a>, or
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns, or based on
      expressions making use of such columns.
    </p><p>
      When partitioning by <code class="literal">KEY</code> or <code class="literal">LINEAR
      KEY</code>, you can use a <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
      <a class="link" href="data-types.html#time" title="11.3.2. The TIME Type"><code class="literal">TIME</code></a>, or
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column as the partitioning
      column without performing any modification of the column value.
      For example, this table creation statement is perfectly valid in
      MySQL:
    </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY KEY(joined)
PARTITIONS 6;</pre><p>
      In MySQL 5.6, it is also possible to use a
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column as the partitioning
      column using <code class="literal">RANGE COLUMNS</code> and <code class="literal">LIST
      COLUMNS</code> partitioning.
    </p><p>
      MySQL's other partitioning types, however, require a partitioning
      expression that yields an integer value or
      <code class="literal">NULL</code>. If you wish to use date-based
      partitioning by <code class="literal">RANGE</code>, <code class="literal">LIST</code>,
      <code class="literal">HASH</code>, or <code class="literal">LINEAR HASH</code>, you
      can simply employ a function that operates on a
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
      <a class="link" href="data-types.html#time" title="11.3.2. The TIME Type"><code class="literal">TIME</code></a>, or
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column and returns such a
      value, as shown here:
    </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);</pre><p>
      Additional examples of partitioning using dates may be found in
      the following sections of this chapter:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-range" title="18.2.1. RANGE Partitioning">Section 18.2.1, “<code class="literal">RANGE</code> Partitioning”</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-hash" title="18.2.4. HASH Partitioning">Section 18.2.4, “<code class="literal">HASH</code> Partitioning”</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-linear-hash" title="18.2.4.1. LINEAR HASH Partitioning">Section 18.2.4.1, “<code class="literal">LINEAR HASH</code> Partitioning”</a>
</p></li></ul>
</div>
<p>
      For more complex examples of date-based partitioning, see the
      following sections:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-pruning" title="18.4. Partition Pruning">Section 18.4, “Partition Pruning”</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-subpartitions" title="18.2.6. Subpartitioning">Section 18.2.6, “Subpartitioning”</a>
</p></li></ul>
</div>
<p>
      MySQL partitioning is optimized for use with the
      <a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS()</code></a>,
      <a class="link" href="functions.html#function_year"><code class="literal">YEAR()</code></a>, and
      <a class="link" href="functions.html#function_to-seconds"><code class="literal">TO_SECONDS()</code></a> functions. However,
      you can use other date and time functions that return an integer
      or <code class="literal">NULL</code>, such as
      <a class="link" href="functions.html#function_weekday"><code class="literal">WEEKDAY()</code></a>,
      <a class="link" href="functions.html#function_dayofyear"><code class="literal">DAYOFYEAR()</code></a>, or
      <a class="link" href="functions.html#function_month"><code class="literal">MONTH()</code></a>. See
      <a class="xref" href="functions.html#date-and-time-functions" title="12.7. Date and Time Functions">Section 12.7, “Date and Time Functions”</a>, for more information
      about such functions.
    </p><p>
      It is important to remember—regardless of the type of
      partitioning that you use—that partitions are always
      numbered automatically and in sequence when created, starting with
      <code class="literal">0</code>. When a new row is inserted into a
      partitioned table, it is these partition numbers that are used in
      identifying the correct partition. For example, if your table uses
      4 partitions, these partitions are numbered <code class="literal">0</code>,
      <code class="literal">1</code>, <code class="literal">2</code>, and
      <code class="literal">3</code>. For the <code class="literal">RANGE</code> and
      <code class="literal">LIST</code> partitioning types, it is necessary to
      ensure that there is a partition defined for each partition
      number. For <code class="literal">HASH</code> partitioning, the user
      function employed must return an integer value greater than
      <code class="literal">0</code>. For <code class="literal">KEY</code> partitioning,
      this issue is taken care of automatically by the hashing function
      which the MySQL server employs internally.
    </p><p>
      Names of partitions generally follow the rules governing other
      MySQL identifiers, such as those for tables and databases.
      However, you should note that partition names are not
      case-sensitive. For example, the following
      <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement fails as
      shown:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (val INT)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(val)(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION mypart VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION MyPart VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
ERROR 1488 (HY000): Duplicate partition name mypart
</pre><p>
      Failure occurs because MySQL sees no difference between the
      partition names <code class="literal">mypart</code> and
      <code class="literal">MyPart</code>.
    </p><p>
      When you specify the number of partitions for the table, this must
      be expressed as a positive, nonzero integer literal with no
      leading zeros, and may not be an expression such as
      <code class="literal">0.8E+01</code> or <code class="literal">6-2</code>, even if it
      evaluates to an integer value. Decimal fractions are not
      permitted.
    </p><p>
      In the sections that follow, we do not necessarily provide all
      possible forms for the syntax that can be used for creating each
      partition type; this information may be found in
      <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-range"></a>18.2.1. <code class="literal">RANGE</code> Partitioning</h3>
</div>
</div>
</div>
<a class="indexterm" name="idp126872160"></a><a class="indexterm" name="idp126873648"></a><p>
        A table that is partitioned by range is partitioned in such a
        way that each partition contains rows for which the partitioning
        expression value lies within a given range. Ranges should be
        contiguous but not overlapping, and are defined using the
        <code class="literal">VALUES LESS THAN</code> operator. For the next few
        examples, suppose that you are creating a table such as the
        following to hold personnel records for a chain of 20 video
        stores, numbered 1 through 20:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);</pre><p>
        This table can be partitioned by range in a number of ways,
        depending on your needs. One way would be to use the
        <code class="literal">store_id</code> column. For instance, you might
        decide to partition the table 4 ways by adding a
        <code class="literal">PARTITION BY RANGE</code> clause as shown here:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN (21)
);</pre><p>
        In this partitioning scheme, all rows corresponding to employees
        working at stores 1 through 5 are stored in partition
        <code class="literal">p0</code>, to those employed at stores 6 through 10
        are stored in partition <code class="literal">p1</code>, and so on. Note
        that each partition is defined in order, from lowest to highest.
        This is a requirement of the <code class="literal">PARTITION BY
        RANGE</code> syntax; you can think of it as being analogous
        to a series of <code class="literal">if ... elseif ...</code> statements
        in C or Java in this regard.
      </p><p>
        It is easy to determine that a new row containing the data
        <code class="literal">(72, 'Michael', 'Widenius', '1998-06-25', NULL,
        13)</code> is inserted into partition <code class="literal">p2</code>,
        but what happens when your chain adds a
        21<sup>st</sup> store? Under this scheme, there
        is no rule that covers a row whose <code class="literal">store_id</code>
        is greater than 20, so an error results because the server does
        not know where to place it. You can keep this from occurring by
        using a <span class="quote">“<span class="quote">catchall</span>”</span> <code class="literal">VALUES LESS
        THAN</code> clause in the <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
        TABLE</code></a> statement that provides for all values greater
        than the highest value explicitly named:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    <span class="emphasis"><em>PARTITION p3 VALUES LESS THAN MAXVALUE</em></span>
);
</pre>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          Another way to avoid an error when no matching value is found
          is to use the <code class="literal">IGNORE</code> keyword as part of the
          <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statement. For an
          example, see <a class="xref" href="partitioning.html#partitioning-list" title="18.2.2. LIST Partitioning">Section 18.2.2, “<code class="literal">LIST</code> Partitioning”</a>. Also see
          <a class="xref" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax">Section 13.2.5, “<code class="literal">INSERT</code> Syntax”</a>, for general information about
          <code class="literal">IGNORE</code>.
</p>
</div>
<p>
        <code class="literal">MAXVALUE</code> represents an integer value that is
        always greater than the largest possible integer value (in
        mathematical language, it serves as a <em class="firstterm">least upper
        bound</em>). Now, any rows whose
        <code class="literal">store_id</code> column value is greater than or
        equal to 16 (the highest value defined) are stored in partition
        <code class="literal">p3</code>. At some point in the future—when
        the number of stores has increased to 25, 30, or more—you
        can use an
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement to add new partitions for stores
        21-25, 26-30, and so on (see
        <a class="xref" href="partitioning.html#partitioning-management" title="18.3. Partition Management">Section 18.3, “Partition Management”</a>, for details of how to
        do this).
      </p><p>
        In much the same fashion, you could partition the table based on
        employee job codes—that is, based on ranges of
        <code class="literal">job_code</code> column values. For
        example—assuming that two-digit job codes are used for
        regular (in-store) workers, three-digit codes are used for
        office and support personnel, and four-digit codes are used for
        management positions—you could create the partitioned
        table using the following statement:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (1000),
    PARTITION p2 VALUES LESS THAN (10000)
);</pre><p>
        In this instance, all rows relating to in-store workers would be
        stored in partition <code class="literal">p0</code>, those relating to
        office and support staff in <code class="literal">p1</code>, and those
        relating to managers in partition <code class="literal">p2</code>.
      </p><p>
        It is also possible to use an expression in <code class="literal">VALUES LESS
        THAN</code> clauses. However, MySQL must be able to evaluate
        the expression's return value as part of a <code class="literal">LESS
        THAN</code> (<code class="literal">&lt;</code>) comparison.
      </p><a class="indexterm" name="idp126908864"></a><p>
        Rather than splitting up the table data according to store
        number, you can use an expression based on one of the two
        <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> columns instead. For
        example, let us suppose that you wish to partition based on the
        year that each employee left the company; that is, the value of
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(separated)</code></a>. An example of a
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement that
        implements such a partitioning scheme is shown here:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);</pre><p>
        In this scheme, for all employees who left before 1991, the rows
        are stored in partition <code class="literal">p0</code>; for those who
        left in the years 1991 through 1995, in <code class="literal">p1</code>;
        for those who left in the years 1996 through 2000, in
        <code class="literal">p2</code>; and for any workers who left after the
        year 2000, in <code class="literal">p3</code>.
      </p><p>
        It is also possible to partition a table by
        <code class="literal">RANGE</code>, based on the value of a
        <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column, using the
        <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> function, as
        shown in this example:
      </p><pre class="programlisting">CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);</pre><p>
        Any other expressions involving
        <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values are not
        permitted. (See Bug #42849.)
      </p><p>
        Range partitioning is particularly useful when one or more of
        the following conditions is true:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            You want or need to delete <span class="quote">“<span class="quote">old</span>”</span> data. If you
            are using the partitioning scheme shown immediately above,
            you can simply use <code class="literal">ALTER TABLE employees DROP
            PARTITION p0;</code> to delete all rows relating to
            employees who stopped working for the firm prior to 1991.
            (See <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>, and
            <a class="xref" href="partitioning.html#partitioning-management" title="18.3. Partition Management">Section 18.3, “Partition Management”</a>, for more
            information.) For a table with a great many rows, this can
            be much more efficient than running a
            <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a> query such as
            <code class="literal">DELETE FROM employees WHERE YEAR(separated) &lt;=
            1990;</code>.
          </p></li><li class="listitem"><p>
            You want to use a column containing date or time values, or
            containing values arising from some other series.
          </p></li><li class="listitem"><p>
            You frequently run queries that depend directly on the
            column used for partitioning the table. For example, when
            executing a query such as
            <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN PARTITIONS
            SELECT COUNT(*) FROM employees WHERE separated BETWEEN
            '2000-01-01' AND '2000-12-31' GROUP BY store_id;</code></a>,
            MySQL can quickly determine that only partition
            <code class="literal">p2</code> needs to be scanned because the
            remaining partitions cannot contain any records satisfying
            the <code class="literal">WHERE</code> clause. See
            <a class="xref" href="partitioning.html#partitioning-pruning" title="18.4. Partition Pruning">Section 18.4, “Partition Pruning”</a>, for more information
            about how this is accomplished.
</p></li></ul>
</div>
<p>
        A variant on this type of partitioning is <code class="literal">RANGE
        COLUMNS</code> partitioning. Partitioning by <code class="literal">RANGE
        COLUMNS</code> makes it possible to employ multiple columns
        for defining partitioning ranges that apply both to placement of
        rows in partitions and for determining the inclusion or
        exclusion of specific partitions when performing partition
        pruning. See <a class="xref" href="partitioning.html#partitioning-columns-range" title="18.2.3.1. RANGE COLUMNS partitioning">Section 18.2.3.1, “<code class="literal">RANGE COLUMNS</code> partitioning”</a>, for
        more information.
      </p><p><a name="partitioning-time-intervals"></a><b>Partitioning schemes based on time intervals. </b>
          If you wish to implement a partitioning scheme based on ranges
          or intervals of time in MySQL 5.6, you have two
          options:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
            Partition the table by <code class="literal">RANGE</code>, and for the
            partitioning expression, employ a function operating on a
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
            <a class="link" href="data-types.html#time" title="11.3.2. The TIME Type"><code class="literal">TIME</code></a>, or
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column and returning
            an integer value, as shown here:
          </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);</pre><p>
            In MySQL 5.6, it is also possible to partition
            a table by <code class="literal">RANGE</code> based on the value of a
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column, using the
            <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> function, as
            shown in this example:
          </p><pre class="programlisting">CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);</pre><p>
            In MySQL 5.6, any other expressions involving
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values are not
            permitted. (See Bug #42849.)
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
              It is also possible in MySQL 5.6 to use
              <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP(timestamp_column)</code></a>
              as a partitioning expression for tables that are
              partitioned by <code class="literal">LIST</code>. However, it is
              usually not practical to do so.
</p>
</div>
</li><li class="listitem"><p>
            Partition the table by <code class="literal">RANGE COLUMNS</code>,
            using a <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column as the
            partitioning column. For example, the
            <code class="literal">members</code> table could be defined using the
            <code class="literal">joined</code> column directly, as shown here:
          </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS(joined) (
    PARTITION p0 VALUES LESS THAN ('1960-01-01'),
    PARTITION p1 VALUES LESS THAN ('1970-01-01'),
    PARTITION p2 VALUES LESS THAN ('1980-01-01'),
    PARTITION p3 VALUES LESS THAN ('1990-01-01'),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);</pre></li></ol>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Note
</div>
<p xmlns="">
          The use of partitioning columns employing date or time types
          other than <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> is not supported with
          <code class="literal">RANGE COLUMNS</code>.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-list"></a>18.2.2. <code class="literal">LIST</code> Partitioning</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp126965872"></a><a class="indexterm" name="idp126967360"></a><p>
        List partitioning in MySQL is similar to range partitioning in
        many ways. As in partitioning by <code class="literal">RANGE</code>, each
        partition must be explicitly defined. The chief difference
        between the two types of partitioning is that, in list
        partitioning, each partition is defined and selected based on
        the membership of a column value in one of a set of value lists,
        rather than in one of a set of contiguous ranges of values. This
        is done by using <code class="literal">PARTITION BY
        LIST(<em class="replaceable"><code>expr</code></em>)</code> where
        <em class="replaceable"><code>expr</code></em> is a column value or an
        expression based on a column value and returning an integer
        value, and then defining each partition by means of a
        <code class="literal">VALUES IN
        (<em class="replaceable"><code>value_list</code></em>)</code>, where
        <em class="replaceable"><code>value_list</code></em> is a comma-separated list
        of integers.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          In MySQL 5.6, it is possible to match against
          only a list of integers (and possibly
          <code class="literal">NULL</code>—see
          <a class="xref" href="partitioning.html#partitioning-handling-nulls" title="18.2.7. How MySQL Partitioning Handles NULL">Section 18.2.7, “How MySQL Partitioning Handles <code class="literal">NULL</code>”</a>) when
          partitioning by <code class="literal">LIST</code>.
        </p><p xmlns="">
          However, other column types may be used in value lists when
          employing <code class="literal">LIST COLUMN</code> partitioning, which
          is described later in this section.
</p>
</div>
<p>
        Unlike the case with partitions defined by range, list
        partitions do not need to be declared in any particular order.
        For more detailed syntactical information, see
        <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>.
      </p><p>
        For the examples that follow, we assume that the basic
        definition of the table to be partitioned is provided by the
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement shown
        here:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
);</pre><p>
        (This is the same table used as a basis for the examples in
        <a class="xref" href="partitioning.html#partitioning-range" title="18.2.1. RANGE Partitioning">Section 18.2.1, “<code class="literal">RANGE</code> Partitioning”</a>.)
      </p><p>
        Suppose that there are 20 video stores distributed among 4
        franchises as shown in the following table.
</p>
<div class="informaltable">
<table summary="This table illustrates an example of 20 video stores
          distributed among 4 regional franchises, as described in the
preceding text." border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Region</th><th scope="col">Store ID Numbers</th></tr></thead><tbody><tr><td scope="row">North</td><td>3, 5, 6, 9, 17</td></tr><tr><td scope="row">East</td><td>1, 2, 10, 11, 19, 20</td></tr><tr><td scope="row">West</td><td>4, 12, 13, 14, 18</td></tr><tr><td scope="row">Central</td><td>7, 8, 15, 16</td></tr></tbody></table>
</div>
<p>
        To partition this table in such a way that rows for stores
        belonging to the same region are stored in the same partition,
        you could use the <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
        statement shown here:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);</pre><p>
        This makes it easy to add or drop employee records relating to
        specific regions to or from the table. For instance, suppose
        that all stores in the West region are sold to another company.
        In MySQL 5.6, all rows relating to employees
        working at stores in that region can be deleted with the query
        <code class="literal">ALTER TABLE employees TRUNCATE PARTITION
        pWest</code>, which can be executed much more efficiently
        than the equivalent <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a>
        statement <code class="literal">DELETE FROM employees WHERE store_id IN
        (4,12,13,14,18);</code>. (Using <code class="literal">ALTER TABLE
        employees DROP PARTITION pWest</code> would also delete all
        of these rows, but would also remove the partition
        <code class="literal">pWest</code> from the definition of the table; you
        would need to use an <code class="literal">ALTER TABLE ... ADD
        PARTITION</code> statement to restore the table's
        original partitioning scheme.)
      </p><p>
        As with <code class="literal">RANGE</code> partitioning, it is possible to
        combine <code class="literal">LIST</code> partitioning with partitioning
        by hash or key to produce a composite partitioning
        (subpartitioning). See
        <a class="xref" href="partitioning.html#partitioning-subpartitions" title="18.2.6. Subpartitioning">Section 18.2.6, “Subpartitioning”</a>.
      </p><p>
        Unlike the case with <code class="literal">RANGE</code> partitioning,
        there is no <span class="quote">“<span class="quote">catch-all</span>”</span> such as
        <code class="literal">MAXVALUE</code>; all expected values for the
        partitioning expression should be covered in <code class="literal">PARTITION
        ... VALUES IN (...)</code> clauses. An
        <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statement containing an
        unmatched partitioning column value fails with an error, as
        shown in this example:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE h2 (</code></strong>
    -&gt;   <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;   <strong class="userinput"><code>c2 INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p0 VALUES IN (1, 4, 7),</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p1 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.11 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO h2 VALUES (3, 5);</code></strong>
<span class="errortext">ERROR 1525 (HY000): Table has no partition for value 3</span>
</pre><p>
        When inserting multiple rows using a single
        <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statement, any rows coming
        before the row containing the unmatched value are inserted, but
        any coming after it are not:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO h2 VALUES (4, 7), (3, 5), (6, 0);</code></strong>
<span class="errortext">ERROR 1525 (HY000): Table has no partition for value 3</span>
mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
+------+------+
| c1   | c2   |
+------+------+
|    4 |    7 |
+------+------+
1 row in set (0.00 sec)
</pre><p>
        You can cause this type of error to be ignored by using the
        <code class="literal">IGNORE</code> keyword. If you do so, rows containing
        unmatched partitioning column values are not inserted, but any
        rows with matching values <span class="emphasis"><em>are</em></span> inserted, and
        no errors are reported:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE h2;</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 5  Duplicates: 2  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
3 rows in set (0.00 sec)
</pre><p>
        MySQL 5.6 provides support for <code class="literal">LIST
        COLUMNS</code> partitioning. This is a variant of
        <code class="literal">LIST</code> partitioning that enables you to use
        columns of types other than integer types for partitioning
        columns, as well as to use multiple columns as partitioning
        keys. For more information, see
        <a class="xref" href="partitioning.html#partitioning-columns-list" title="18.2.3.2. LIST COLUMNS partitioning">Section 18.2.3.2, “<code class="literal">LIST COLUMNS</code> partitioning”</a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-columns"></a>18.2.3. <code class="literal">COLUMNS</code> Partitioning</h3>

</div>

</div>

</div>
<div class="toc">
<dl><dt><span class="section"><a href="partitioning.html#partitioning-columns-range">18.2.3.1. <code class="literal">RANGE COLUMNS</code> partitioning</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns-list">18.2.3.2. <code class="literal">LIST COLUMNS</code> partitioning</a></span></dt></dl>
</div>
<a class="indexterm" name="idp127029904"></a><a class="indexterm" name="idp127031392"></a><a class="indexterm" name="idp127032464"></a><a class="indexterm" name="idp127033552"></a><a class="indexterm" name="idp127034640"></a><a class="indexterm" name="idp127035712"></a><p>
        The next two sections discuss
        <em class="firstterm"><code class="literal">COLUMNS</code> partitioning</em>,
        which are variants on <code class="literal">RANGE</code> and
        <code class="literal">LIST</code> partitioning. <code class="literal">COLUMNS</code>
        partitioning enables the use of multiple columns in partitioning
        keys. All of these columns are taken into account both for the
        purpose of placing rows in partitions and for the determination
        of which partitions are to be checked for matching rows in
        partition pruning.
      </p><p>
        In addition, both <code class="literal">RANGE COLUMNS</code> partitioning
        and <code class="literal">LIST COLUMNS</code> partitioning support the use
        of non-integer columns for defining value ranges or list
        members. The permitted data types are shown in the following
        list:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            All integer types: <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a>,
            <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a>,
            <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a>,
            <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>
            (<a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a>), and
            <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>. (This is the same as
            with partitioning by <code class="literal">RANGE</code> and
            <code class="literal">LIST</code>.)
          </p><p>
            Other numeric data types (such as
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2. Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> or
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3. Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a>) are not supported as
            partitioning columns.
          </p></li><li class="listitem"><p>
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>.
          </p><p>
            Columns using other data types relating to dates or times
            are not supported as partitioning columns.
          </p></li><li class="listitem"><p>
            The following string types:
            <a class="link" href="data-types.html#char" title="11.4.1. The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
            <a class="link" href="data-types.html#char" title="11.4.1. The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2. The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>, and
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2. The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>.
          </p><p>
            <a class="link" href="data-types.html#blob" title="11.4.3. The BLOB and TEXT Types"><code class="literal">TEXT</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3. The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns are not
            supported as partitioning columns.
</p></li></ul>
</div>
<p>
        The discussions of <code class="literal">RANGE COLUMNS</code> and
        <code class="literal">LIST COLUMNS</code> partitioning in the next two
        sections assume that you are already familiar with partitioning
        based on ranges and lists as supported in MySQL 5.1 and later;
        for more information about these, see
        <a class="xref" href="partitioning.html#partitioning-range" title="18.2.1. RANGE Partitioning">Section 18.2.1, “<code class="literal">RANGE</code> Partitioning”</a>, and
        <a class="xref" href="partitioning.html#partitioning-list" title="18.2.2. LIST Partitioning">Section 18.2.2, “<code class="literal">LIST</code> Partitioning”</a>, respectively.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="partitioning-columns-range"></a>18.2.3.1. <code class="literal">RANGE COLUMNS</code> partitioning</h4>
</div>
</div>
</div>
<p>
          Range columns partitioning is similar to range partitioning,
          but enables you to define partitions using ranges based on
          multiple column values. In addition, you can define the ranges
          using columns of types other than integer types.
        </p><p>
          <code class="literal">RANGE COLUMNS</code> partitioning differs
          significantly from <code class="literal">RANGE</code> partitioning in
          the following ways:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> does not accept
              expressions, only names of columns.
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> accepts a list of one or
              more columns.
            </p><p>
              <code class="literal">RANGE COLUMNS</code> partitions are based on
              comparisons between <em class="firstterm">tuples</em> (lists
              of column values) rather than comparisons between scalar
              values. Placement of rows in <code class="literal">RANGE
              COLUMNS</code> partitions is also based on comparisons
              between tuples; this is discussed further later in this
              section.
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> partitioning columns are
              not restricted to integer columns; string,
              <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> and
              <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns can also
              be used as partitioning columns. (See
              <a class="xref" href="partitioning.html#partitioning-columns" title="18.2.3. COLUMNS Partitioning">Section 18.2.3, “<code class="literal">COLUMNS</code> Partitioning”</a>, for details.)
</p></li></ul>
</div>
<p>
          The basic syntax for creating a table partitioned by
          <code class="literal">RANGE COLUMNS</code> is shown here:
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>table_name</code></em>
PARTITIONED BY RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>) (
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)[,
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)][,
    ...]
) 

<em class="replaceable"><code>column_list</code></em>:
    <em class="replaceable"><code>column_name</code></em>[, <em class="replaceable"><code>column_name</code></em>][, ...]

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em>[, <em class="replaceable"><code>value</code></em>][, ...]
</pre>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
            Not all <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> options
            that can be used when creating partitioned tables are shown
            here. For complete information, see
            <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>.
</p>
</div>
<p>
          In the syntax just shown,
          <em class="replaceable"><code>column_list</code></em> is a list of one or
          more columns (sometimes called a <em class="firstterm">partitioning
          column list</em>), and
          <em class="replaceable"><code>value_list</code></em> is a list of values
          (that is, it is a <em class="firstterm">partition definition value
          list</em>). A <em class="replaceable"><code>value_list</code></em>
          must be supplied for each partition definition, and each
          <em class="replaceable"><code>value_list</code></em> must have the same
          number of values as the <em class="replaceable"><code>column_list</code></em>
          has columns. Generally speaking, if you use
          <em class="replaceable"><code>N</code></em> columns in the
          <code class="literal">COLUMNS</code> clause, then each <code class="literal">VALUES
          LESS THAN</code> clause must also be supplied with a list
          of <em class="replaceable"><code>N</code></em> values.
        </p><p>
          The elements in the partitioning column list and in the value
          list defining each partition must occur in the same order. In
          addition, each element in the value list must be of the same
          data type as the corresponding element in the column list.
          However, the order of the column names in the partitioning
          column list and the value lists does not have to be the same
          as the order of the table column definitions in the main part
          of the <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
          As with table partitioned by <code class="literal">RANGE</code>, you can
          use <code class="literal">MAXVALUE</code> to represent a value such that
          any legal value inserted into a given column is always less
          than this value. Here is an example of a
          <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement that
          helps to illustrate all of these points:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE rcx (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c CHAR(3),</code></strong>
    -&gt;     <strong class="userinput"><code>d INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,d,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5,10,'ggg'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10,20,'mmmm'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15,30,'sss'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.15 sec)
</pre><p>
          Table <code class="literal">rcx</code> contains the columns
          <code class="literal">a</code>, <code class="literal">b</code>,
          <code class="literal">c</code>, <code class="literal">d</code>. The partitioning
          column list supplied to the <code class="literal">COLUMNS</code> clause
          uses 3 of these columns, in the order <code class="literal">a</code>,
          <code class="literal">d</code>, <code class="literal">c</code>. Each value list
          used to define a partition contains 3 values in the same
          order; that is, each value list tuple has the form
          (<code class="literal">INT</code>, <code class="literal">INT</code>,
          <code class="literal">CHAR(3)</code>), which corresponds to the data
          types used by columns <code class="literal">a</code>,
          <code class="literal">d</code>, and <code class="literal">c</code> (in that
          order).
        </p><p>
          Placement of rows into partitions is determined by comparing
          the tuple from a row to be inserted that matches the column
          list in the <code class="literal">COLUMNS</code> clause with the tuples
          used in the <code class="literal">VALUES LESS THAN</code> clauses to
          define partitions of the table. Because we are comparing
          tuples (that is, lists or sets of values) rather than scalar
          values, the semantics of <code class="literal">VALUES LESS THAN</code>
          as used with <code class="literal">RANGE COLUMNS</code> partitions
          differs somewhat from the case with simple
          <code class="literal">RANGE</code> partitions. In
          <code class="literal">RANGE</code> partitioning, a row generating an
          expression value that is equal to a limiting value in a
          <code class="literal">VALUES LESS THAN</code> is never placed in the
          corresponding partition; however, when using <code class="literal">RANGE
          COLUMNS</code> partitioning, it is sometimes possible for a
          row whose partitioning column list's first element is
          equal in value to the that of the first element in a
          <code class="literal">VALUES LESS THAN</code> value list to be placed in
          the corresponding partition.
        </p><p>
          Consider the <code class="literal">RANGE</code> partitioned table
          created by this statement:
        </p><pre class="programlisting">CREATE TABLE r1 (
    a INT,
    b INT
)
PARTITION BY RANGE (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
);</pre><p>
          If we insert 3 rows into this table such that the column value
          for <code class="literal">a</code> is <code class="literal">5</code> for each row,
          all 3 rows are stored in partition <code class="literal">p1</code>
          because the <code class="literal">a</code> column value is in each case
          not less than 5, as we can see by executing the proper query
          against the
          <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>
          table:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO r1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'r1';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          Now consider a similar table <code class="literal">rc1</code> that uses
          <code class="literal">RANGE COLUMNS</code> partitioning with both
          columns <code class="literal">a</code> and <code class="literal">b</code>
          referenced in the <code class="literal">COLUMNS</code> clause, created
          as shown here:
        </p><pre class="programlisting">CREATE TABLE rc1 (
    a INT, 
    b INT
) 
PARTITION BY RANGE COLUMNS(a, b) (
    PARTITION p0 VALUES LESS THAN (5, 12),
    PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);</pre><p>
          If we insert exactly the same rows into <code class="literal">rc1</code>
          as we just inserted into <code class="literal">r1</code>, the
          distribution of the rows is quite different:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rc1';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          2 |
| p            | p1             |          1 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          This is because we are comparing rows rather than scalar
          values. We can compare the row values inserted with the
          limiting row value from the <code class="literal">VALUES THAN LESS
          THAN</code> clause used to define partition
          <code class="literal">p0</code> in table <code class="literal">rc1</code>, like
          this:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);</code></strong>
+-----------------+-----------------+-----------------+
| (5,10) &lt; (5,12) | (5,11) &lt; (5,12) | (5,12) &lt; (5,12) |
+-----------------+-----------------+-----------------+
|               1 |               1 |               0 |
+-----------------+-----------------+-----------------+
1 row in set (0.00 sec)
</pre><p>
          The 2 tuples <code class="literal">(5,10)</code> and
          <code class="literal">(5,11)</code> evaluate as less than
          <code class="literal">(5,12)</code>, so they are stored in partition
          <code class="literal">p0</code>. Since 5 is not less than 5 and 12 is
          not less than 12, <code class="literal">(5,12)</code> is considered not
          less than <code class="literal">(5,12)</code>, and is stored in
          partition <code class="literal">p1</code>.
        </p><p>
          The <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement in the
          preceding example could also have been written using explicit
          row constructors, like this:
        </p><pre class="programlisting">SELECT ROW(5,10) &lt; ROW(5,12), ROW(5,11) &lt; ROW(5,12), ROW(5,12) &lt; ROW(5,12);</pre><p>
          For more information about the use of row constructors in
          MySQL, see <a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5. Row Subqueries">Section 13.2.10.5, “Row Subqueries”</a>.
        </p><p>
          For a table partitioned by <code class="literal">RANGE COLUMNS</code>
          using only a single partitioning column, the storing of rows
          in partitions is the same as that of an equivalent table that
          is partitioned by <code class="literal">RANGE</code>. The following
          <code class="literal">CREATE TABLE</code> statement creates a table
          partitioned by <code class="literal">RANGE COLUMNS</code> using 1
          partitioning column:
        </p><pre class="programlisting">CREATE TABLE rx (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
); </pre><p>
          If we insert the rows <code class="literal">(5,10)</code>,
          <code class="literal">(5,11)</code>, and <code class="literal">(5,12)</code> into
          this table, we can see that their placement is the same as it
          is for the table <code class="literal">r</code> we created and populated
          earlier:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO rx VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rx';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          0 |
| p            | p1             |          3 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          It is also possible to create tables partitioned by
          <code class="literal">RANGE COLUMNS</code> where limiting values for one
          or more columns are repeated in successive partition
          definitions. You can do this as long as the tuples of column
          values used to define the partitions are strictly increasing.
          For example, each of the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
          TABLE</code></a> statements is valid:
        </p><pre class="programlisting">CREATE TABLE rc2 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );
 
CREATE TABLE rc3 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (10,35),
    PARTITION p4 VALUES LESS THAN (20,40),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );</pre><p>
          The following statement also succeeds, even though it might
          appear at first glance that it would not, since the limiting
          value of column <code class="literal">b</code> is 25 for partition
          <code class="literal">p0</code> and 20 for partition
          <code class="literal">p1</code>, and the limiting value of column
          <code class="literal">c</code> is 100 for partition
          <code class="literal">p1</code> and 50 for partition
          <code class="literal">p2</code>:
        </p><pre class="programlisting">CREATE TABLE rc4 (
    a INT,
    b INT,
    c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
    PARTITION p0 VALUES LESS THAN (0,25,50),
    PARTITION p1 VALUES LESS THAN (10,20,100),
    PARTITION p2 VALUES LESS THAN (10,30,50)
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE) 
 );</pre><p>
          When designing tables partitioned by <code class="literal">RANGE
          COLUMNS</code>, you can always test successive partition
          definitions by comparing the desired tuples using the
          <a class="link" href="programs.html#mysql" title="4.5.1. mysql — The MySQL Command-Line Tool"><span class="command"><strong>mysql</strong></span></a> client, like this:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (10,20,100), (10,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (10,20,100) | (10,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        1 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          If a <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
          contains partition definitions that are not in strictly
          increasing order, it fails with an error, as shown in this
          example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE rcf (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,b,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0,25,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20,20,100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10,30,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt;  <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition</span>
</pre><p>
          When you get such an error, you can deduce which partition
          definitions are invalid by making <span class="quote">“<span class="quote">less than</span>”</span>
          comparisons between their column lists. In this case, the
          problem is with the definition of partition
          <code class="literal">p2</code> because the tuple used to define it is
          not less than the tuple used to define partition
          <code class="literal">p3</code>, as shown here:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (20,20,100), (20,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (20,20,100) | (20,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        0 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          It is also possible for <code class="literal">MAXVALUE</code> to appear
          for the same column in more than one <code class="literal">VALUES LESS
          THAN</code> clause when using <code class="literal">RANGE
          COLUMNS</code>. However, the limiting values for individual
          columns in successive partition definitions should otherwise
          be increasing, there should be no more than one partition
          defined where <code class="literal">MAXVALUE</code> is used as the upper
          limit for all column values, and this partition definition
          should appear last in the list of <code class="literal">PARTITION ...
          VALUES LESS THAN</code> clauses. In addition, you cannot
          use <code class="literal">MAXVALUE</code> as the limiting value for the
          first column in more than one partition definition.
        </p><p>
          As stated previously, it is also possible with <code class="literal">RANGE
          COLUMNS</code> partitioning to use non-integer columns as
          partitioning columns. (See
          <a class="xref" href="partitioning.html#partitioning-columns" title="18.2.3. COLUMNS Partitioning">Section 18.2.3, “<code class="literal">COLUMNS</code> Partitioning”</a>, for a complete listing
          of these.) Consider a table named <code class="literal">employees</code>
          (which is not partitioned), created using the following
          statement:
        </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);</pre><p>
          Using <code class="literal">RANGE COLUMNS</code> partitioning, you can
          create a version of this table that stores each row in one of
          four partitions based on the employee's last name, like
          this:
        </p><pre class="programlisting">CREATE TABLE employees_by_lname (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);</pre><p>
          Alternatively, you could cause the
          <code class="literal">employees</code> table as created previously to be
          partitioned using this scheme by executing the following
          <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
          TABLE</code></a> statement:
        </p><pre class="programlisting">ALTER TABLE employees PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);</pre>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
            Because different character sets and collations have
            different sort orders, the character sets and collations in
            use may effect which partition of a table partitioned by
            <code class="literal">RANGE COLUMNS</code> a given row is stored in
            when using string columns as partitioning columns. In
            addition, changing the character set or collation for a
            given database, table, or column after such a table is
            created may cause changes in how rows are distributed. For
            example, when using a case-sensitive collation,
            <code class="literal">'and'</code> sorts before
            <code class="literal">'Andersen'</code>, but when using a collation
            that is case insensitive, the reverse is true.
          </p><p xmlns="">
            For information about how MySQL handles character sets and
            collations, see <a class="xref" href="globalization.html#charset" title="10.1. Character Set Support">Section 10.1, “Character Set Support”</a>.
</p>
</div>
<p>
          Similarly, you can cause the <code class="literal">employees</code>
          table to be partitioned in such a way that each row is stored
          in one of several partitions based on the decade in which the
          corresponding employee was hired using the
          <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
          TABLE</code></a> statement shown here:
        </p><pre class="programlisting">ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired)  (
    PARTITION p0 VALUES LESS THAN ('1970-01-01'),
    PARTITION p1 VALUES LESS THAN ('1980-01-01'),
    PARTITION p2 VALUES LESS THAN ('1990-01-01'),
    PARTITION p3 VALUES LESS THAN ('2000-01-01'),
    PARTITION p4 VALUES LESS THAN ('2010-01-01'),
    PARTITION p5 VALUES LESS THAN (MAXVALUE)
);</pre><p>
          See <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>, for additional information
          about <code class="literal">PARTITION BY RANGE COLUMNS</code> syntax.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="partitioning-columns-list"></a>18.2.3.2. <code class="literal">LIST COLUMNS</code> partitioning</h4>

</div>

</div>

</div>
<p>
          MySQL 5.6 provides support for <code class="literal">LIST
          COLUMNS</code> partitioning. This is a variant of
          <code class="literal">LIST</code> partitioning that enables the use of
          multiple columns as partition keys, and for columns of data
          types other than integer types to be used as partitioning
          columns; you can use string types,
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, and
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns. (For more
          information about permitted data types for
          <code class="literal">COLUMNS</code> partitioning columns, see
          <a class="xref" href="partitioning.html#partitioning-columns" title="18.2.3. COLUMNS Partitioning">Section 18.2.3, “<code class="literal">COLUMNS</code> Partitioning”</a>.)
        </p><p>
          Suppose that you have a business that has customers in 12
          cities which, for sales and marketing purposes, you organize
          into 4 regions of 3 cities each as shown in the following
          table:
</p>
<div class="informaltable">
<table summary="This table illustrates the example described in the
            preceding text of a business with four sales and marketing
regions, with each region having three cities." border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Region</th><th scope="col">Cities</th></tr></thead><tbody><tr><td scope="row">1</td><td>Oskarshamn, Högsby, Mönsterås</td></tr><tr><td scope="row">2</td><td>Vimmerby, Hultsfred, Västervik</td></tr><tr><td scope="row">3</td><td>Nässjö, Eksjö, Vetlanda</td></tr><tr><td scope="row">4</td><td>Uppvidinge, Alvesta, Växjo</td></tr></tbody></table>
</div>
<p>
          With <code class="literal">LIST COLUMNS</code> partitioning, you can
          create a table for customer data that assigns a row to any of
          4 partitions corresponding to these regions based on the name
          of the city where a customer resides, as shown here:
        </p><pre class="programlisting">CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
    PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
    PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
    PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
    PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
);</pre><p>
          As with partitioning by <code class="literal">RANGE COLUMNS</code>, you
          do not need to use expressions in the
          <code class="literal">COLUMNS()</code> clause to convert column values
          into integers. (In fact, the use of expressions other than
          column names is not permitted with
          <code class="literal">COLUMNS()</code>.)
        </p><p>
          It is also possible to use <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>
          and <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns, as shown
          in the following example that uses the same name and columns
          as the <code class="literal">customers_1</code> table shown previously,
          but employs <code class="literal">LIST COLUMNS</code> partitioning based
          on the <code class="literal">renewal</code> column to store rows in one
          of 4 partitions depending on the week in February 2010 the
          customer's account is scheduled to renew:
        </p><pre class="programlisting">CREATE TABLE customers_2 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES IN('2010-02-01', '2010-02-02', '2010-02-03',
        '2010-02-04', '2010-02-05', '2010-02-06', '2010-02-07'),
    PARTITION pWeek_2 VALUES IN('2010-02-08', '2010-02-09', '2010-02-10',
        '2010-02-11', '2010-02-12', '2010-02-13', '2010-02-14'),
    PARTITION pWeek_3 VALUES IN('2010-02-15', '2010-02-16', '2010-02-17',
        '2010-02-18', '2010-02-19', '2010-02-20', '2010-02-21'),
    PARTITION pWeek_4 VALUES IN('2010-02-22', '2010-02-23', '2010-02-24',
        '2010-02-25', '2010-02-26', '2010-02-27', '2010-02-28')
);</pre><p>
          This works, but becomes cumbersome to define and maintain if
          the number of dates involved grows very large; in such cases,
          it is usually more practical to employ
          <code class="literal">RANGE</code> or <code class="literal">RANGE COLUMNS</code>
          partitioning instead. In this case, since the column we wish
          to use as the partitioning key is a
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> column, we use
          <code class="literal">RANGE COLUMNS</code> partitioning, as shown here:
        </p><pre class="programlisting">CREATE TABLE customers_3 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES LESS THAN('2010-02-09'),
    PARTITION pWeek_2 VALUES LESS THAN('2010-02-15'),
    PARTITION pWeek_3 VALUES LESS THAN('2010-02-22'),
    PARTITION pWeek_4 VALUES LESS THAN('2010-03-01')
);</pre><p>
          See <a class="xref" href="partitioning.html#partitioning-columns-range" title="18.2.3.1. RANGE COLUMNS partitioning">Section 18.2.3.1, “<code class="literal">RANGE COLUMNS</code> partitioning”</a>, for more
          information.
        </p><p>
          In addition (as with <code class="literal">RANGE COLUMNS</code>
          partitioning), you can use multiple columns in the
          <code class="literal">COLUMNS()</code> clause.
        </p><p>
          See <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>, for additional information
          about <code class="literal">PARTITION BY LIST COLUMNS()</code> syntax.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-hash"></a>18.2.4. <code class="literal">HASH</code> Partitioning</h3>

</div>

</div>

</div>
<div class="toc">
<dl><dt><span class="section"><a href="partitioning.html#partitioning-linear-hash">18.2.4.1. <code class="literal">LINEAR HASH</code> Partitioning</a></span></dt></dl>
</div>
<a class="indexterm" name="idp127268272"></a><a class="indexterm" name="idp127269760"></a><p>
        Partitioning by <code class="literal">HASH</code> is used primarily to
        ensure an even distribution of data among a predetermined number
        of partitions. With range or list partitioning, you must specify
        explicitly into which partition a given column value or set of
        column values is to be stored; with hash partitioning, MySQL
        takes care of this for you, and you need only specify a column
        value or expression based on a column value to be hashed and the
        number of partitions into which the partitioned table is to be
        divided.
      </p><p>
        To partition a table using <code class="literal">HASH</code> partitioning,
        it is necessary to append to the <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
        TABLE</code></a> statement a <code class="literal">PARTITION BY HASH
        (<em class="replaceable"><code>expr</code></em>)</code> clause, where
        <em class="replaceable"><code>expr</code></em> is an expression that returns an
        integer. This can simply be the name of a column whose type is
        one of MySQL's integer types. In addition, you will most likely
        want to follow this with a <code class="literal">PARTITIONS
        <em class="replaceable"><code>num</code></em></code> clause, where
        <em class="replaceable"><code>num</code></em> is a positive integer
        representing the number of partitions into which the table is to
        be divided.
      </p><p>
        For example, the following statement creates a table that uses
        hashing on the <code class="literal">store_id</code> column and is divided
        into 4 partitions:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;</pre><p>
        If you do not include a <code class="literal">PARTITIONS</code> clause,
        the number of partitions defaults to <code class="literal">1</code>.
      </p><p>
        Using the <code class="literal">PARTITIONS</code> keyword without a number
        following it results in a syntax error.
      </p><a class="indexterm" name="idp127283136"></a><p>
        You can also use an SQL expression that returns an integer for
        <em class="replaceable"><code>expr</code></em>. For instance, you might want to
        partition based on the year in which an employee was hired. This
        can be done as shown here:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH( YEAR(hired) )
PARTITIONS 4;</pre><p>
        <em class="replaceable"><code>expr</code></em> must return a nonconstant,
        nonrandom integer value (in other words, it should be varying
        but deterministic), and must not contain any prohibited
        constructs as described in
        <a class="xref" href="partitioning.html#partitioning-limitations" title="18.6. Restrictions and Limitations on Partitioning">Section 18.6, “Restrictions and Limitations on Partitioning”</a>. You should also keep
        in mind that this expression is evaluated each time a row is
        inserted or updated (or possibly deleted); this means that very
        complex expressions may give rise to performance issues,
        particularly when performing operations (such as batch inserts)
        that affect a great many rows at one time.
      </p><p>
        The most efficient hashing function is one which operates upon a
        single table column and whose value increases or decreases
        consistently with the column value, as this allows for
        <span class="quote">“<span class="quote">pruning</span>”</span> on ranges of partitions. That is, the
        more closely that the expression varies with the value of the
        column on which it is based, the more efficiently MySQL can use
        the expression for hash partitioning.
      </p><p>
        For example, where <code class="literal">date_col</code> is a column of
        type <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, then the expression
        <a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS(date_col)</code></a> is said to vary
        directly with the value of <code class="literal">date_col</code>, because
        for every change in the value of <code class="literal">date_col</code>,
        the value of the expression changes in a consistent manner. The
        variance of the expression
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(date_col)</code></a> with respect to
        <code class="literal">date_col</code> is not quite as direct as that of
        <a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS(date_col)</code></a>, because not
        every possible change in <code class="literal">date_col</code> produces an
        equivalent change in
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(date_col)</code></a>. Even so,
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(date_col)</code></a> is a good
        candidate for a hashing function, because it varies directly
        with a portion of <code class="literal">date_col</code> and there is no
        possible change in <code class="literal">date_col</code> that produces a
        disproportionate change in
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(date_col)</code></a>.
      </p><p>
        By way of contrast, suppose that you have a column named
        <code class="literal">int_col</code> whose type is
        <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>. Now consider the expression
        <a class="link" href="functions.html#function_pow"><code class="literal">POW(5-int_col,3) + 6</code></a>. This would
        be a poor choice for a hashing function because a change in the
        value of <code class="literal">int_col</code> is not guaranteed to produce
        a proportional change in the value of the expression. Changing
        the value of <code class="literal">int_col</code> by a given amount can
        produce by widely different changes in the value of the
        expression. For example, changing <code class="literal">int_col</code>
        from <code class="literal">5</code> to <code class="literal">6</code> produces a
        change of <code class="literal">-1</code> in the value of the expression,
        but changing the value of <code class="literal">int_col</code> from
        <code class="literal">6</code> to <code class="literal">7</code> produces a change
        of <code class="literal">-7</code> in the expression value.
      </p><p>
        In other words, the more closely the graph of the column value
        <span class="foreignphrase"><em class="foreignphrase">versus</em></span> the value of the
        expression follows a straight line as traced by the equation
        <code class="literal">y=<em class="replaceable"><code>c</code></em>x</code> where
        <em class="replaceable"><code>c</code></em> is some nonzero constant, the
        better the expression is suited to hashing. This has to do with
        the fact that the more nonlinear an expression is, the more
        uneven the distribution of data among the partitions it tends to
        produce.
      </p><p>
        In theory, pruning is also possible for expressions involving
        more than one column value, but determining which of such
        expressions are suitable can be quite difficult and
        time-consuming. For this reason, the use of hashing expressions
        involving multiple columns is not particularly recommended.
      </p><p>
        When <code class="literal">PARTITION BY HASH</code> is used, MySQL
        determines which partition of <em class="replaceable"><code>num</code></em>
        partitions to use based on the modulus of the result of the user
        function. In other words, for an expression
        <em class="replaceable"><code>expr</code></em>, the partition in which the
        record is stored is partition number
        <em class="replaceable"><code>N</code></em>, where
        <code class="literal"><em class="replaceable"><code>N</code></em> =
        MOD(<em class="replaceable"><code>expr</code></em>,
        <em class="replaceable"><code>num</code></em>)</code>. Suppose that table
        <code class="literal">t1</code> is defined as follows, so that it has 4
        partitions:
      </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY HASH( YEAR(col3) )
    PARTITIONS 4;</pre><p>
        If you insert a record into <code class="literal">t1</code> whose
        <code class="literal">col3</code> value is
        <code class="literal">'2005-09-15'</code>, then the partition in which it
        is stored is determined as follows:
      </p><pre class="programlisting">MOD(YEAR('2005-09-01'),4)
=  MOD(2005,4)
=  1</pre><p>
        MySQL 5.6 also supports a variant of
        <code class="literal">HASH</code> partitioning known as <em class="firstterm">linear
        hashing</em> which employs a more complex algorithm for
        determining the placement of new rows inserted into the
        partitioned table. See
        <a class="xref" href="partitioning.html#partitioning-linear-hash" title="18.2.4.1. LINEAR HASH Partitioning">Section 18.2.4.1, “<code class="literal">LINEAR HASH</code> Partitioning”</a>, for a description of
        this algorithm.
      </p><p>
        The user function is evaluated each time a record is inserted or
        updated. It may also—depending on the
        circumstances—be evaluated when records are deleted.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          If a table to be partitioned has a <code class="literal">UNIQUE</code>
          key, then any columns supplied as arguments to the
          <code class="literal">HASH</code> user function or to the
          <code class="literal">KEY</code>'s
          <em class="replaceable"><code>column_list</code></em> must be part of that
          key.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="partitioning-linear-hash"></a>18.2.4.1. <code class="literal">LINEAR HASH</code> Partitioning</h4>

</div>

</div>

</div>
<a class="indexterm" name="idp127333056"></a><a class="indexterm" name="idp127334544"></a><p>
          MySQL also supports linear hashing, which differs from regular
          hashing in that linear hashing utilizes a linear powers-of-two
          algorithm whereas regular hashing employs the modulus of the
          hashing function's value.
        </p><p>
          Syntactically, the only difference between linear-hash
          partitioning and regular hashing is the addition of the
          <code class="literal">LINEAR</code> keyword in the <code class="literal">PARTITION
          BY</code> clause, as shown here:
        </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;</pre><p>
          Given an expression <em class="replaceable"><code>expr</code></em>, the
          partition in which the record is stored when linear hashing is
          used is partition number <em class="replaceable"><code>N</code></em> from
          among <em class="replaceable"><code>num</code></em> partitions, where
          <em class="replaceable"><code>N</code></em> is derived according to the
          following algorithm:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
              Find the next power of 2 greater than
              <em class="replaceable"><code>num</code></em>. We call this value
              <em class="replaceable"><code>V</code></em>; it can be calculated as:
            </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = POWER(2, CEILING(LOG(2, <em class="replaceable"><code>num</code></em>)))
</pre><p>
              (Suppose that <em class="replaceable"><code>num</code></em> is 13. Then
              <a class="link" href="functions.html#function_log"><code class="literal">LOG(2,13)</code></a> is
              3.7004397181411.
              <a class="link" href="functions.html#function_ceiling"><code class="literal">CEILING(3.7004397181411)</code></a> is
              4, and <em class="replaceable"><code>V</code></em> =
              <a class="link" href="functions.html#function_power"><code class="literal">POWER(2,4)</code></a>, which is 16.)
            </p></li><li class="listitem"><p>
              Set <em class="replaceable"><code>N</code></em> =
              <em class="replaceable"><code>F</code></em>(<em class="replaceable"><code>column_list</code></em>)
              &amp; (<em class="replaceable"><code>V</code></em> - 1).
            </p></li><li class="listitem"><p>
              While <em class="replaceable"><code>N</code></em> &gt;=
              <em class="replaceable"><code>num</code></em>:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  Set <em class="replaceable"><code>V</code></em> =
                  CEIL(<em class="replaceable"><code>V</code></em> / 2)
                </p></li><li class="listitem"><p>
                  Set <em class="replaceable"><code>N</code></em> =
                  <em class="replaceable"><code>N</code></em> &amp;
                  (<em class="replaceable"><code>V</code></em> - 1)
</p></li></ul>
</div>
</li></ol>
</div>
<p>
          Suppose that the table <code class="literal">t1</code>, using linear
          hash partitioning and having 6 partitions, is created using
          this statement:
        </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR HASH( YEAR(col3) )
    PARTITIONS 6;</pre><p>
          Now assume that you want to insert two records into
          <code class="literal">t1</code> having the <code class="literal">col3</code>
          column values <code class="literal">'2003-04-14'</code> and
          <code class="literal">'1998-10-19'</code>. The partition number for the
          first of these is determined as follows:
        </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = POWER(2, CEILING( LOG(2,6) )) = 8
<em class="replaceable"><code>N</code></em> = YEAR('2003-04-14') &amp; (8 - 1)
   = 2003 &amp; 7
   = 3

(<span class="emphasis"><em>3 &gt;= 6 is FALSE: record stored in partition #3</em></span>)
</pre><p>
          The number of the partition where the second record is stored
          is calculated as shown here:
        </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = 8
<em class="replaceable"><code>N</code></em> = YEAR('1998-10-19') &amp; (8-1)
  = 1998 &amp; 7
  = 6

(<span class="emphasis"><em>6 &gt;= 6 is TRUE: additional step required</em></span>)

<em class="replaceable"><code>N</code></em> = 6 &amp; CEILING(8 / 2)
  = 6 &amp; 3
  = 2

(<span class="emphasis"><em>2 &gt;= 6 is FALSE: record stored in partition #2</em></span>)
</pre><p>
          The advantage in partitioning by linear hash is that the
          adding, dropping, merging, and splitting of partitions is made
          much faster, which can be beneficial when dealing with tables
          containing extremely large amounts (terabytes) of data. The
          disadvantage is that data is less likely to be evenly
          distributed between partitions as compared with the
          distribution obtained using regular hash partitioning.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-key"></a>18.2.5. <code class="literal">KEY</code> Partitioning</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp127371136"></a><a class="indexterm" name="idp127372624"></a><p>
        Partitioning by key is similar to partitioning by hash, except
        that where hash partitioning employs a user-defined expression,
        the hashing function for key partitioning is supplied by the
        MySQL server. MySQL Cluster uses
        <a class="link" href="functions.html#function_md5"><code class="literal">MD5()</code></a> for this purpose; for
        tables using other storage engines, the server employs its own
        internal hashing function which is based on the same algorithm
        as <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a>.
      </p><p>
        The syntax rules for <code class="literal">CREATE TABLE ... PARTITION BY
        KEY</code> are similar to those for creating a table that is
        partitioned by hash. The major differences are listed here:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">KEY</code> is used rather than
            <code class="literal">HASH</code>.
          </p></li><li class="listitem"><p>
            <code class="literal">KEY</code> takes only a list of zero or more
            column names. Any columns used as the partitioning key must
            comprise part or all of the table's primary key, if the
            table has one. Where no column name is specified as the
            partitioning key, the table's primary key is used, if
            there is one. For example, the following
            <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement is
            valid in MySQL 5.6:
          </p><pre class="programlisting">CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;</pre><p>
            If there is no primary key but there is a unique key, then
            the unique key is used for the partitioning key:
          </p><pre class="programlisting">CREATE TABLE k1 (
    id INT NOT NULL,
    name VARCHAR(20),
    UNIQUE KEY (id)
)
PARTITION BY KEY()
PARTITIONS 2;</pre><p>
            However, if the unique key column were not defined as
            <code class="literal">NOT NULL</code>, then the previous statement
            would fail.
          </p><p>
            In both of these cases, the partitioning key is the
            <code class="literal">id</code> column, even though it is not shown in
            the output of <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.12. SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
            TABLE</code></a> or in the
            <code class="literal">PARTITION_EXPRESSION</code> column of the
            <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>
            table.
          </p><p>
            Unlike the case with other partitioning types, columns used
            for partitioning by <code class="literal">KEY</code> are not
            restricted to integer or <code class="literal">NULL</code> values. For
            example, the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement is valid:
          </p><pre class="programlisting">CREATE TABLE tm1 (
    s1 CHAR(32) PRIMARY KEY
)
PARTITION BY KEY(s1)
PARTITIONS 10;</pre><p>
            The preceding statement would <span class="emphasis"><em>not</em></span> be
            valid, were a different partitioning type to be specified.
            (In this case, simply using <code class="literal">PARTITION BY
            KEY()</code> would also be valid and have the same effect
            as <code class="literal">PARTITION BY KEY(s1)</code>, since
            <code class="literal">s1</code> is the table's primary key.)
          </p><p>
            For additional information about this issue, see
            <a class="xref" href="partitioning.html#partitioning-limitations" title="18.6. Restrictions and Limitations on Partitioning">Section 18.6, “Restrictions and Limitations on Partitioning”</a>.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
              Tables using the <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> storage
              engine are implicitly partitioned by
              <code class="literal">KEY</code>, again using the table's
              primary key as the partitioning key. In the event that the
              MySQL Cluster table has no explicit primary key, the
              <span class="quote">“<span class="quote">hidden</span>”</span> primary key generated by the
              <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> storage engine for each
              MySQL Cluster table is used as the partitioning key.
            </p><p xmlns="">
              If you define an explicit partitioning scheme for an
              <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table, the table must
              have an explicit primary key, and any columns used in the
              partitioning expression must be part of this key. However,
              if the table uses an <span class="quote">“<span class="quote">empty</span>”</span> partitioning
              expression—that is, <code class="literal">PARTITION BY
              KEY()</code> with no column references—then no
              explicit primary key is required.
            </p><p xmlns="">
              You can observe this partitioning using the
              <a class="link" href="mysql-cluster.html#mysql-cluster-programs-ndb-desc" title="17.4.10. ndb_desc — Describe NDB Tables"><span class="command"><strong>ndb_desc</strong></span></a> utility (with the
              <code class="option">-p</code> option).
</p>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Important
</div>
<p xmlns="">
              For a key-partitioned table, you cannot execute an
              <code class="literal">ALTER TABLE DROP PRIMARY KEY</code>, as doing
              so generates the error <span class="errortext">ERROR 1466 (HY000):
              Field in list of fields for partition function not found
              in table</span>. This is not an issue for MySQL
              Cluster tables which are partitioned by
              <code class="literal">KEY</code>; in such cases, the table is
              reorganized using the <span class="quote">“<span class="quote">hidden</span>”</span> primary key as
              the table's new partitioning key. See
              <a class="xref" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3">Chapter 17, <i>MySQL Cluster NDB 7.3</i></a>.
</p>
</div>
</li></ul>
</div>
<a class="indexterm" name="idp127410400"></a><a class="indexterm" name="idp127411888"></a><p>
        It is also possible to partition a table by linear key. Here is
        a simple example:
      </p><pre class="programlisting">CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;</pre><p>
        Using <code class="literal">LINEAR</code> has the same effect on
        <code class="literal">KEY</code> partitioning as it does on
        <code class="literal">HASH</code> partitioning, with the partition number
        being derived using a powers-of-two algorithm rather than modulo
        arithmetic. See <a class="xref" href="partitioning.html#partitioning-linear-hash" title="18.2.4.1. LINEAR HASH Partitioning">Section 18.2.4.1, “<code class="literal">LINEAR HASH</code> Partitioning”</a>, for
        a description of this algorithm and its implications.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-subpartitions"></a>18.2.6. Subpartitioning</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp127418688"></a><a class="indexterm" name="idp127419760"></a><p>
        Subpartitioning—also known as <em class="firstterm">composite
        partitioning</em>—is the further division of each
        partition in a partitioned table. Consider the following
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );</pre><p>
        Table <code class="literal">ts</code> has 3 <code class="literal">RANGE</code>
        partitions. Each of these
        partitions—<code class="literal">p0</code>, <code class="literal">p1</code>,
        and <code class="literal">p2</code>—is further divided into 2
        subpartitions. In effect, the entire table is divided into
        <code class="literal">3 * 2 = 6</code> partitions. However, due to the
        action of the <code class="literal">PARTITION BY RANGE</code> clause, the
        first 2 of these store only those records with a value less than
        1990 in the <code class="literal">purchased</code> column.
      </p><a class="indexterm" name="idp127430080"></a><p>
        In MySQL 5.6, it is possible to subpartition tables
        that are partitioned by <code class="literal">RANGE</code> or
        <code class="literal">LIST</code>. Subpartitions may use either
        <code class="literal">HASH</code> or <code class="literal">KEY</code> partitioning.
        This is also known as <em class="firstterm">composite
        partitioning</em>.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          <code class="literal">SUBPARTITION BY HASH</code> and
          <code class="literal">SUBPARTITION BY KEY</code> generally follow the
          same syntax rules as <code class="literal">PARTITION BY HASH</code> and
          <code class="literal">PARTITION BY KEY</code>, respectively. An
          exception to this is that <code class="literal">SUBPARTITION BY
          KEY</code> (unlike <code class="literal">PARTITION BY KEY</code>)
          does not currently support a default column, so the column
          used for this purpose must be specified, even if the table has
          an explicit primary key. This is a known issue which we are
          working to address; see
          <a class="xref" href="partitioning.html#partitioning-limitations-subpartitions" title="Issues with subpartitions">Issues with subpartitions</a>, for
          more information and an example.
</p>
</div>
<a class="indexterm" name="idp127441040"></a><p>
        It is also possible to define subpartitions explicitly using
        <code class="literal">SUBPARTITION</code> clauses to specify options for
        individual subpartitions. For example, a more verbose fashion of
        creating the same table <code class="literal">ts</code> as shown in the
        previous example would be:
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );</pre><p>
        Some syntactical items of note are listed here:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Each partition must have the same number of subpartitions.
          </p></li><li class="listitem"><p>
            If you explicitly define any subpartitions using
            <code class="literal">SUBPARTITION</code> on any partition of a
            partitioned table, you must define them all. In other words,
            the following statement will fail:
          </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s2,
            SUBPARTITION s3
        )
    );</pre><p>
            This statement would still fail even if it included a
            <code class="literal">SUBPARTITIONS 2</code> clause.
          </p></li><li class="listitem"><p>
            Each <code class="literal">SUBPARTITION</code> clause must include (at
            a minimum) a name for the subpartition. Otherwise, you may
            set any desired option for the subpartition or allow it to
            assume its default setting for that option.
          </p></li><li class="listitem"><p>
            Subpartition names must be unique across the entire table.
            For example, the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement is valid in MySQL
            5.6:
          </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
);</pre></li></ul>
</div>
<p>
        Subpartitions can be used with especially large tables to
        distribute data and indexes across many disks. Suppose that you
        have 6 disks mounted as <code class="filename">/disk0</code>,
        <code class="filename">/disk1</code>, <code class="filename">/disk2</code>, and so
        on. Now consider the following example:
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0
                DATA DIRECTORY = '/disk0/data'
                INDEX DIRECTORY = '/disk0/idx',
            SUBPARTITION s1
                DATA DIRECTORY = '/disk1/data'
                INDEX DIRECTORY = '/disk1/idx'
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2
                DATA DIRECTORY = '/disk2/data'
                INDEX DIRECTORY = '/disk2/idx',
            SUBPARTITION s3
                DATA DIRECTORY = '/disk3/data'
                INDEX DIRECTORY = '/disk3/idx'
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4
                DATA DIRECTORY = '/disk4/data'
                INDEX DIRECTORY = '/disk4/idx',
            SUBPARTITION s5
                DATA DIRECTORY = '/disk5/data'
                INDEX DIRECTORY = '/disk5/idx'
        )
    );</pre><p>
        In this case, a separate disk is used for the data and for the
        indexes of each <code class="literal">RANGE</code>. Many other variations
        are possible; another example might be:
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE(YEAR(purchased))
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0a
                DATA DIRECTORY = '/disk0'
                INDEX DIRECTORY = '/disk1',
            SUBPARTITION s0b
                DATA DIRECTORY = '/disk2'
                INDEX DIRECTORY = '/disk3'
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s1a
                DATA DIRECTORY = '/disk4/data'
                INDEX DIRECTORY = '/disk4/idx',
            SUBPARTITION s1b
                DATA DIRECTORY = '/disk5/data'
                INDEX DIRECTORY = '/disk5/idx'
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s2a,
            SUBPARTITION s2b
        )
    );</pre><p>
        Here, the storage is as follows:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Rows with <code class="literal">purchased</code> dates from before
            1990 take up a vast amount of space, so are split up 4 ways,
            with a separate disk dedicated to the data and to the
            indexes for each of the two subpartitions
            (<code class="literal">s0a</code> and <code class="literal">s0b</code>) making
            up partition <code class="literal">p0</code>. In other words:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                The data for subpartition <code class="literal">s0a</code> is
                stored on <code class="filename">/disk0</code>.
              </p></li><li class="listitem"><p>
                The indexes for subpartition <code class="literal">s0a</code> are
                stored on <code class="filename">/disk1</code>.
              </p></li><li class="listitem"><p>
                The data for subpartition <code class="literal">s0b</code> is
                stored on <code class="filename">/disk2</code>.
              </p></li><li class="listitem"><p>
                The indexes for subpartition <code class="literal">s0b</code> are
                stored on <code class="filename">/disk3</code>.
</p></li></ul>
</div>
</li><li class="listitem"><p>
            Rows containing dates ranging from 1990 to 1999 (partition
            <code class="literal">p1</code>) do not require as much room as those
            from before 1990. These are split between 2 disks
            (<code class="filename">/disk4</code> and
            <code class="filename">/disk5</code>) rather than 4 disks as with the
            legacy records stored in <code class="literal">p0</code>:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                Data and indexes belonging to <code class="literal">p1</code>'s
                first subpartition (<code class="literal">s1a</code>) are stored
                on <code class="filename">/disk4</code>—the data in
                <code class="filename">/disk4/data</code>, and the indexes in
                <code class="filename">/disk4/idx</code>.
              </p></li><li class="listitem"><p>
                Data and indexes belonging to <code class="literal">p1</code>'s
                second subpartition (<code class="literal">s1b</code>) are stored
                on <code class="filename">/disk5</code>—the data in
                <code class="filename">/disk5/data</code>, and the indexes in
                <code class="filename">/disk5/idx</code>.
</p></li></ul>
</div>
</li><li class="listitem"><p>
            Rows reflecting dates from the year 2000 to the present
            (partition <code class="literal">p2</code>) do not take up as much
            space as required by either of the two previous ranges.
            Currently, it is sufficient to store all of these in the
            default location.
          </p><p>
            In future, when the number of purchases for the decade
            beginning with the year 2000 grows to a point where the
            default location no longer provides sufficient space, the
            corresponding rows can be moved using an <code class="literal">ALTER
            TABLE ... REORGANIZE PARTITION</code> statement. See
            <a class="xref" href="partitioning.html#partitioning-management" title="18.3. Partition Management">Section 18.3, “Partition Management”</a>, for an
            explanation of how this can be done.
</p></li></ul>
</div>
<p>
        The <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
        DIRECTORY</code> options are not permitted in partition
        definitions when the
        <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a> server SQL
        mode is in effect. In MySQL 5.6, these options are
        also not permitted when defining subpartitions (Bug #42954).
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-handling-nulls"></a>18.2.7. How MySQL Partitioning Handles <code class="literal">NULL</code></h3>

</div>

</div>

</div>
<p>
        Partitioning in MySQL does nothing to disallow
        <code class="literal">NULL</code> as the value of a partitioning
        expression, whether it is a column value or the value of a
        user-supplied expression. Even though it is permitted to use
        <code class="literal">NULL</code> as the value of an expression that must
        otherwise yield an integer, it is important to keep in mind that
        <code class="literal">NULL</code> is not a number. MySQL's
        partitioning implementation treats <code class="literal">NULL</code> as
        being less than any non-<code class="literal">NULL</code> value, just as
        <code class="literal">ORDER BY</code> does.
      </p><p>
        This means that treatment of <code class="literal">NULL</code> varies
        between partitioning of different types, and may produce
        behavior which you do not expect if you are not prepared for it.
        This being the case, we discuss in this section how each MySQL
        partitioning type handles <code class="literal">NULL</code> values when
        determining the partition in which a row should be stored, and
        provide examples for each.
      </p><p><b>Handling of <code class="literal">NULL</code> with <code class="literal">RANGE</code>
          partitioning. </b>
          If you insert a row into a table partitioned by
          <code class="literal">RANGE</code> such that the column value used to
          determine the partition is <code class="literal">NULL</code>, the row is
          inserted into the lowest partition. Consider these two tables
          in a database named <code class="literal">p</code>, created as follows:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)
</pre><p>
        You can see the partitions created by these two
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements using the
        following query against the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table in the
        <code class="literal">INFORMATION_SCHEMA</code> database:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |           0 |
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
| t2         | p0             |          0 |              0 |           0 |
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
</pre><p>
        (For more information about this table, see
        <a class="xref" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table">Section 20.14, “The <code class="literal">INFORMATION_SCHEMA PARTITIONS</code> Table”</a>.) Now let us populate each of
        these tables with a single row containing a
        <code class="literal">NULL</code> in the column used as the partitioning
        key, and verify that the rows were inserted using a pair of
        <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statements:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
</pre><p>
        You can see which partitions are used to store the inserted rows
        by rerunning the previous query against
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a> and
        inspecting the output:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| t1         | p0             |          1 |             20 |          20 |</em></span>
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| t2         | p0             |          1 |             20 |          20 |</em></span>
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        You can also demonstrate that these rows were stored in the
        lowest partition of each table by dropping these partitions, and
        then re-running the <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
        statements:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        (For more information on <code class="literal">ALTER TABLE ... DROP
        PARTITION</code>, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>.)
      </p><p>
        <code class="literal">NULL</code> is also treated in this way for
        partitioning expressions that use SQL functions. Suppose that we
        define a table using a <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
        TABLE</code></a> statement such as this one:
      </p><pre class="programlisting">CREATE TABLE tndate (
    id INT,
    dt DATE
)
PARTITION BY RANGE( YEAR(dt) ) (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);</pre><p>
        As with other MySQL functions,
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(NULL)</code></a> returns
        <code class="literal">NULL</code>. A row with a <code class="literal">dt</code>
        column value of <code class="literal">NULL</code> is treated as though the
        partitioning expression evaluated to a value less than any other
        value, and so is inserted into partition <code class="literal">p0</code>.
      </p><p><b>Handling of <code class="literal">NULL</code> with <code class="literal">LIST</code>
          partitioning. </b>
          A table that is partitioned by <code class="literal">LIST</code> admits
          <code class="literal">NULL</code> values if and only if one of its
          partitions is defined using that value-list that contains
          <code class="literal">NULL</code>. The converse of this is that a table
          partitioned by <code class="literal">LIST</code> which does not
          explicitly use <code class="literal">NULL</code> in a value list rejects
          rows resulting in a <code class="literal">NULL</code> value for the
          partitioning expression, as shown in this example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (0, 3, 6),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (1, 4, 7),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (9, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value 9</span>

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (NULL, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value NULL</span>
</pre><p>
        Only rows having a <code class="literal">c1</code> value between
        <code class="literal">0</code> and <code class="literal">8</code> inclusive can be
        inserted into <code class="literal">ts1</code>. <code class="literal">NULL</code>
        falls outside this range, just like the number
        <code class="literal">9</code>. We can create tables
        <code class="literal">ts2</code> and <code class="literal">ts3</code> having value
        lists containing <code class="literal">NULL</code>, as shown here:
      </p><pre class="programlisting">mysql&gt; CREATE TABLE ts2 (
    -&gt;     c1 INT,
    -&gt;     c2 VARCHAR(20)
    -&gt; )
    -&gt; PARTITION BY LIST(c1) (
    -&gt;     PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;     PARTITION p1 VALUES IN (1, 4, 7),
    -&gt;     PARTITION p2 VALUES IN (2, 5, 8),
    -&gt;     PARTITION p3 VALUES IN (NULL)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE ts3 (
    -&gt;     c1 INT,
    -&gt;     c2 VARCHAR(20)
    -&gt; )
    -&gt; PARTITION BY LIST(c1) (
    -&gt;     PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;     PARTITION p1 VALUES IN (1, 4, 7, NULL),
    -&gt;     PARTITION p2 VALUES IN (2, 5, 8)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)</pre><p>
        When defining value lists for partitioning, you can (and should)
        treat <code class="literal">NULL</code> just as you would any other value.
        For example, both <code class="literal">VALUES IN (NULL)</code> and
        <code class="literal">VALUES IN (1, 4, 7, NULL)</code> are valid, as are
        <code class="literal">VALUES IN (1, NULL, 4, 7)</code>, <code class="literal">VALUES IN
        (NULL, 1, 4, 7)</code>, and so on. You can insert a row
        having <code class="literal">NULL</code> for column <code class="literal">c1</code>
        into each of the tables <code class="literal">ts2</code> and
        <code class="literal">ts3</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO ts2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts3 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)
</pre><p>
        By issuing the appropriate query against
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>, you
        can determine which partitions were used to store the rows just
        inserted (we assume, as in the previous examples, that the
        partitioned tables were created in the <code class="literal">p</code>
        database):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 'ts_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts2        | p0             |          0 |              0 |           0 |
| ts2        | p1             |          0 |              0 |           0 |
| ts2        | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts2        | p3             |          1 |             20 |          20 |</em></span>
| ts3        | p0             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts3        | p1             |          1 |             20 |          20 |</em></span>
| ts3        | p2             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        As shown earlier in this section, you can also verify which
        partitions were used for storing the rows by deleting these
        partitions and then performing a
        <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>.
      </p><p><b>Handling of <code class="literal">NULL</code> with <code class="literal">HASH</code> and
          <code class="literal">KEY</code> partitioning. </b>
          <code class="literal">NULL</code> is handled somewhat differently for
          tables partitioned by <code class="literal">HASH</code> or
          <code class="literal">KEY</code>. In these cases, any partition
          expression that yields a <code class="literal">NULL</code> value is
          treated as though its return value were zero. We can verify
          this behavior by examining the effects on the file system of
          creating a table partitioned by <code class="literal">HASH</code> and
          populating it with a record containing appropriate values.
          Suppose that you have a table <code class="literal">th</code> (also in
          the <code class="literal">p</code> database) created using the following
          statement:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE th (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(c1)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 2;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        The partitions belonging to this table can be viewed using the
        query shown here:
      </p><pre class="programlisting">mysql&gt; SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
     &gt;   FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;   WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |           0 |
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)</pre><p>
        Note that <code class="literal">TABLE_ROWS</code> for each partition is 0.
        Now insert two rows into <code class="literal">th</code> whose
        <code class="literal">c1</code> column values are <code class="literal">NULL</code>
        and 0, and verify that these rows were inserted, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO th VALUES (NULL, 'mothra'), (0, 'gigan');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM th;</code></strong>
+------+---------+
| c1   | c2      |
+------+---------+
| NULL | mothra  |
+------+---------+
|    0 | gigan   |
+------+---------+
2 rows in set (0.01 sec)
</pre><p>
        Recall that for any integer <em class="replaceable"><code>N</code></em>, the
        value of <code class="literal">NULL MOD
        <em class="replaceable"><code>N</code></em></code> is always
        <code class="literal">NULL</code>. For tables that are partitioned by
        <code class="literal">HASH</code> or <code class="literal">KEY</code>, this result
        is treated for determining the correct partition as
        <code class="literal">0</code>. Checking the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a> table
        once again, we can see that both rows were inserted into
        partition <code class="literal">p0</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| th         | p0             |          2 |             20 |          20 |</em></span>
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre><p>
        If you repeat this example using <code class="literal">PARTITION BY
        KEY</code> in place of <code class="literal">PARTITION BY HASH</code>
        in the definition of the table, you can verify easily that
        <code class="literal">NULL</code> is also treated like 0 for this type of
        partitioning.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-management"></a>18.3. Partition Management</h2>

</div>

</div>

</div>
<div class="toc">
<dl><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">18.3.1. Management of <code class="literal">RANGE</code> and <code class="literal">LIST</code>
        Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">18.3.2. Management of <code class="literal">HASH</code> and <code class="literal">KEY</code>
Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">18.3.3. Exchanging Partitions and Subpartitions with Tables</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">18.3.4. Maintenance of Partitions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">18.3.5. Obtaining Information About Partitions</a></span></dt></dl>
</div>
<a class="indexterm" name="idp127638912"></a><a class="indexterm" name="idp127639984"></a><a class="indexterm" name="idp127641472"></a><a class="indexterm" name="idp127642960"></a><a class="indexterm" name="idp127644448"></a><a class="indexterm" name="idp127645936"></a><p>
      MySQL 5.6 provides a number of ways to modify
      partitioned tables. It is possible to add, drop, redefine, merge,
      or split existing partitions. All of these actions can be carried
      out using the partitioning extensions to the
      <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
      TABLE</code></a> statement. There are also ways to obtain
      information about partitioned tables and partitions. We discuss
      these topics in the sections that follow.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          For information about partition management in tables
          partitioned by <code class="literal">RANGE</code> or
          <code class="literal">LIST</code>, see
          <a class="xref" href="partitioning.html#partitioning-management-range-list" title="18.3.1. Management of RANGE and LIST Partitions">Section 18.3.1, “Management of <code class="literal">RANGE</code> and <code class="literal">LIST</code>
        Partitions”</a>.
        </p></li><li class="listitem"><p>
          For a discussion of managing <code class="literal">HASH</code> and
          <code class="literal">KEY</code> partitions, see
          <a class="xref" href="partitioning.html#partitioning-management-hash-key" title="18.3.2. Management of HASH and KEY Partitions">Section 18.3.2, “Management of <code class="literal">HASH</code> and <code class="literal">KEY</code>
        Partitions”</a>.
        </p></li><li class="listitem"><p>
          See <a class="xref" href="partitioning.html#partitioning-info" title="18.3.5. Obtaining Information About Partitions">Section 18.3.5, “Obtaining Information About Partitions”</a>, for a discussion of
          mechanisms provided in MySQL 5.6 for obtaining
          information about partitioned tables and partitions.
        </p></li><li class="listitem"><p>
          For a discussion of performing maintenance operations on
          partitions, see <a class="xref" href="partitioning.html#partitioning-maintenance" title="18.3.4. Maintenance of Partitions">Section 18.3.4, “Maintenance of Partitions”</a>.
</p></li></ul>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Note
</div>
<p xmlns="">
        In MySQL 5.6, all partitions of a partitioned table
        must have the same number of subpartitions, and it is not
        possible to change the subpartitioning once the table has been
        created.
</p>
</div>
<p>
      To change a table's partitioning scheme, it is necessary only to
      use the
      <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
      TABLE</code></a> statement with a
      <em class="replaceable"><code>partition_options</code></em> clause. This clause
      has the same syntax as that as used with
      <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> for creating a
      partitioned table, and always begins with the keywords
      <code class="literal">PARTITION BY</code>. Suppose that you have a table
      partitioned by range using the following
      <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
    </p><pre class="programlisting">CREATE TABLE trb3 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005)
    );</pre><p>
      To repartition this table so that it is partitioned by key into
      two partitions using the <code class="literal">id</code> column value as the
      basis for the key, you can use this statement:
    </p><pre class="programlisting">ALTER TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;</pre><p>
      This has the same effect on the structure of the table as dropping
      the table and re-creating it using <code class="literal">CREATE TABLE trb3
      PARTITION BY KEY(id) PARTITIONS 2;</code>.
    </p><p>
      <code class="literal">ALTER TABLE ... ENGINE = ...</code> changes only the
      storage engine used by the table, and leaves the table's
      partitioning scheme intact. Use <code class="literal">ALTER TABLE ... REMOVE
      PARTITIONING</code> to remove a table's partitioning. See
      <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p xmlns="">
        Only a single <code class="literal">PARTITION BY</code>, <code class="literal">ADD
        PARTITION</code>, <code class="literal">DROP PARTITION</code>,
        <code class="literal">REORGANIZE PARTITION</code>, or <code class="literal">COALESCE
        PARTITION</code> clause can be used in a given
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement. If you (for example) wish to drop a
        partition and reorganize a table's remaining partitions,
        you must do so in two separate
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statements (one using <code class="literal">DROP
        PARTITION</code> and then a second one using
        <code class="literal">REORGANIZE PARTITIONS</code>).
</p>
</div>
<p>
      In MySQL 5.6, it is possible to delete all rows from
      one or more selected partitions using
      <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
      TRUNCATE PARTITION</code></a>.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-management-range-list"></a>18.3.1. Management of <code class="literal">RANGE</code> and <code class="literal">LIST</code>
Partitions</h3>
</div>
</div>
</div>
<a class="indexterm" name="idp127681840"></a><a class="indexterm" name="idp127683328"></a><a class="indexterm" name="idp127684816"></a><a class="indexterm" name="idp127686304"></a><p>
        Range and list partitions are very similar with regard to how
        the adding and dropping of partitions are handled. For this
        reason we discuss the management of both sorts of partitioning
        in this section. For information about working with tables that
        are partitioned by hash or key, see
        <a class="xref" href="partitioning.html#partitioning-management-hash-key" title="18.3.2. Management of HASH and KEY Partitions">Section 18.3.2, “Management of <code class="literal">HASH</code> and <code class="literal">KEY</code>
        Partitions”</a>. Dropping a
        <code class="literal">RANGE</code> or <code class="literal">LIST</code> partition is
        more straightforward than adding one, so we discuss this first.
      </p><p>
        Dropping a partition from a table that is partitioned by either
        <code class="literal">RANGE</code> or by <code class="literal">LIST</code> can be
        accomplished using the
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement with a <code class="literal">DROP
        PARTITION</code> clause. Here is a very basic example, which
        supposes that you have already created a table which is
        partitioned by range and then populated with 10 records using
        the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
        <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statements:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE( YEAR(purchased) ) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (1990),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (1995),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (2000),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (2005)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1, 'desk organiser', '2003-10-15'),</code></strong>
    -&gt;     <strong class="userinput"><code>(2, 'CD player', '1993-11-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(3, 'TV set', '1996-03-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(4, 'bookcase', '1982-01-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(5, 'exercise bike', '2004-05-09'),</code></strong>
    -&gt;     <strong class="userinput"><code>(6, 'sofa', '1987-06-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(7, 'popcorn maker', '2001-11-22'),</code></strong>
    -&gt;     <strong class="userinput"><code>(8, 'aquarium', '1992-08-04'),</code></strong>
    -&gt;     <strong class="userinput"><code>(9, 'study desk', '1984-09-16'),</code></strong>
    -&gt;     <strong class="userinput"><code>(10, 'lava lamp', '1998-12-25');</code></strong>
Query OK, 10 rows affected (0.01 sec)
</pre><p>
        You can see which items should have been inserted into partition
        <code class="literal">p2</code> as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tr</code></strong>
    -&gt; <strong class="userinput"><code>WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
+------+-----------+------------+
| id   | name      | purchased  |
+------+-----------+------------+
|    3 | TV set    | 1996-03-10 |
|   10 | lava lamp | 1998-12-25 |
+------+-----------+------------+
2 rows in set (0.00 sec)
</pre><p>
        To drop the partition named <code class="literal">p2</code>, execute the
        following command:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p2;</code></strong>
Query OK, 0 rows affected (0.03 sec)
</pre>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          The <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> storage engine does not
          support <code class="literal">ALTER TABLE ... DROP PARTITION</code>. It
          does, however, support the other partitioning-related
          extensions to
          <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
          TABLE</code></a> that are described in this chapter.
</p>
</div>
<p>
        It is very important to remember that, <span class="emphasis"><em>when you drop a
        partition, you also delete all the data that was stored in that
        partition</em></span>. You can see that this is the case by
        re-running the previous <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
        query:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
Empty set (0.00 sec)
</pre><p>
        Because of this, you must have the
        <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privilege for a table before
        you can execute <code class="literal">ALTER TABLE ... DROP
        PARTITION</code> on that table.
      </p><p>
        If you wish to drop all data from all partitions while
        preserving the table definition and its partitioning scheme, use
        the <a class="link" href="sql-syntax.html#truncate-table" title="13.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statement.
        (See <a class="xref" href="sql-syntax.html#truncate-table" title="13.1.33. TRUNCATE TABLE Syntax">Section 13.1.33, “<code class="literal">TRUNCATE TABLE</code> Syntax”</a>.)
      </p><p>
        If you intend to change the partitioning of a table
        <span class="emphasis"><em>without</em></span> losing data, use <code class="literal">ALTER
        TABLE ... REORGANIZE PARTITION</code> instead. See below or
        in <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>, for information about
        <code class="literal">REORGANIZE PARTITION</code>.
      </p><p>
        If you now execute a <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.12. SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
        TABLE</code></a> statement, you can see how the partitioning
        makeup of the table has been changed:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE tr\G</code></strong>
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE ( YEAR(purchased) ) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM
)
1 row in set (0.01 sec)
</pre><p>
        When you insert new rows into the changed table with
        <code class="literal">purchased</code> column values between
        <code class="literal">'1995-01-01'</code> and
        <code class="literal">'2004-12-31'</code> inclusive, those rows will be
        stored in partition <code class="literal">p3</code>. You can verify this
        as follows:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES (11, 'pencil holder', '1995-07-12');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
+------+----------------+------------+
| id   | name           | purchased  |
+------+----------------+------------+
|   11 | pencil holder  | 1995-07-12 |
|    1 | desk organiser | 2003-10-15 |
|    5 | exercise bike  | 2004-05-09 |
|    7 | popcorn maker  | 2001-11-22 |
+------+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p3;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
Empty set (0.00 sec)
</pre><p>
        Note that the number of rows dropped from the table as a result
        of <code class="literal">ALTER TABLE ... DROP PARTITION</code> is not
        reported by the server as it would be by the equivalent
        <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a> query.
      </p><p>
        Dropping <code class="literal">LIST</code> partitions uses exactly the
        same <code class="literal">ALTER TABLE ... DROP PARTITION</code> syntax as
        used for dropping <code class="literal">RANGE</code> partitions. However,
        there is one important difference in the effect this has on your
        use of the table afterward: You can no longer insert into the
        table any rows having any of the values that were included in
        the value list defining the deleted partition. (See
        <a class="xref" href="partitioning.html#partitioning-list" title="18.2.2. LIST Partitioning">Section 18.2.2, “<code class="literal">LIST</code> Partitioning”</a>, for an example.)
      </p><p>
        To add a new range or list partition to a previously partitioned
        table, use the <code class="literal">ALTER TABLE ... ADD PARTITION</code>
        statement. For tables which are partitioned by
        <code class="literal">RANGE</code>, this can be used to add a new range to
        the end of the list of existing partitions. Suppose that you
        have a partitioned table containing membership data for your
        organization, which is defined as follows:
      </p><pre class="programlisting">CREATE TABLE members (
    id INT,
    fname VARCHAR(25),
    lname VARCHAR(25),
    dob DATE
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION p0 VALUES LESS THAN (1970),
    PARTITION p1 VALUES LESS THAN (1980),
    PARTITION p2 VALUES LESS THAN (1990)
);</pre><p>
        Suppose further that the minimum age for members is 16. As the
        calendar approaches the end of 2005, you realize that you will
        soon be admitting members who were born in 1990 (and later in
        years to come). You can modify the <code class="literal">members</code>
        table to accommodate new members born in the years 1990 to 1999
        as shown here:
      </p><pre class="programlisting">ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2000));</pre><p>
        With tables that are partitioned by range, you can use
        <code class="literal">ADD PARTITION</code> to add new partitions to the
        high end of the partitions list only. Trying to add a new
        partition in this manner between or before existing partitions
        results in an error as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE members</code></strong>
     &gt;     <strong class="userinput"><code>ADD PARTITION (</code></strong>
     &gt;     <strong class="userinput"><code>PARTITION n VALUES LESS THAN (1960));</code></strong>
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly »
   increasing for each partition
</pre><p>
        You can work around this problem by reorganizing the first
        partition into two new ones that split the range between them,
        like this:
      </p><pre class="programlisting">ALTER TABLE members
    REORGANIZE PARTITION p0 INTO (
        PARTITION n0 VALUES LESS THAN (1960),
        PARTITION n1 VALUES LESS THAN (1970)
);</pre><p>
        Using <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.12. SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> you can
        see that the <code class="literal">ALTER TABLE</code> statement has had
        the desired effect:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE ( YEAR(dob))
(PARTITION n0 VALUES LESS THAN (1960) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2000) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre><p>
        See also <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations">Section 13.1.7.1, “<code class="literal">ALTER TABLE</code> Partition Operations”</a>.
      </p><p>
        You can also use <code class="literal">ALTER TABLE ... ADD
        PARTITION</code> to add new partitions to a table that is
        partitioned by <code class="literal">LIST</code>. Suppose a table
        <code class="literal">tt</code> is defined using the following
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
      </p><pre class="programlisting">CREATE TABLE tt (
    id INT,
    data INT
)
PARTITION BY LIST(data) (
    PARTITION p0 VALUES IN (5, 10, 15),
    PARTITION p1 VALUES IN (6, 12, 18)
);</pre><p>
        You can add a new partition in which to store rows having the
        <code class="literal">data</code> column values <code class="literal">7</code>,
        <code class="literal">14</code>, and <code class="literal">21</code> as shown:
      </p><pre class="programlisting">ALTER TABLE tt ADD PARTITION (PARTITION p2 VALUES IN (7, 14, 21));</pre><p>
        Note that you <span class="emphasis"><em>cannot</em></span> add a new
        <code class="literal">LIST</code> partition encompassing any values that
        are already included in the value list of an existing partition.
        If you attempt to do so, an error will result:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt ADD PARTITION </code></strong>
     &gt;     <strong class="userinput"><code>(PARTITION np VALUES IN (4, 8, 12));</code></strong>
ERROR 1465 (HY000): Multiple definition of same constant »
                    in list partitioning
</pre><p>
        Because any rows with the <code class="literal">data</code> column value
        <code class="literal">12</code> have already been assigned to partition
        <code class="literal">p1</code>, you cannot create a new partition on
        table <code class="literal">tt</code> that includes <code class="literal">12</code>
        in its value list. To accomplish this, you could drop
        <code class="literal">p1</code>, and add <code class="literal">np</code> and then a
        new <code class="literal">p1</code> with a modified definition. However,
        as discussed earlier, this would result in the loss of all data
        stored in <code class="literal">p1</code>—and it is often the case
        that this is not what you really want to do. Another solution
        might appear to be to make a copy of the table with the new
        partitioning and to copy the data into it using
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
        SELECT ...</code></a>, then drop the old table and rename the new
        one, but this could be very time-consuming when dealing with a
        large amounts of data. This also might not be feasible in
        situations where high availability is a requirement.
      </p><p>
        You can add multiple partitions in a single <code class="literal">ALTER TABLE
        ... ADD PARTITION</code> statement as shown here:
      </p><pre class="programlisting">CREATE TABLE employees (
  id INT NOT NULL,
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  hired DATE NOT NULL
)
PARTITION BY RANGE( YEAR(hired) ) (
  PARTITION p1 VALUES LESS THAN (1991),
  PARTITION p2 VALUES LESS THAN (1996),
  PARTITION p3 VALUES LESS THAN (2001),
  PARTITION p4 VALUES LESS THAN (2005)
);

ALTER TABLE employees ADD PARTITION (
    PARTITION p5 VALUES LESS THAN (2010),
    PARTITION p6 VALUES LESS THAN MAXVALUE
);</pre><p>
        Fortunately, MySQL's partitioning implementation provides ways
        to redefine partitions without losing data. Let us look first at
        a couple of simple examples involving <code class="literal">RANGE</code>
        partitioning. Recall the <code class="literal">members</code> table which
        is now defined as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) default NULL,
  `fname` varchar(25) default NULL,
  `lname` varchar(25) default NULL,
  `dob` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE ( YEAR(dob) ) (
  PARTITION p0 VALUES LESS THAN (1970) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1980) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (1990) ENGINE = MyISAM.
  PARTITION p3 VALUES LESS THAN (2000) ENGINE = MyISAM
)
</pre><p>
        Suppose that you would like to move all rows representing
        members born before 1960 into a separate partition. As we have
        already seen, this cannot be done using <code class="literal">ALTER TABLE ...
        ADD PARTITION</code>. However, you can use another
        partition-related extension to
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> to accomplish this:
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION p0 INTO (
    PARTITION s0 VALUES LESS THAN (1960),
    PARTITION s1 VALUES LESS THAN (1970)
);</pre><p>
        In effect, this command splits partition <code class="literal">p0</code>
        into two new partitions <code class="literal">s0</code> and
        <code class="literal">s1</code>. It also moves the data that was stored in
        <code class="literal">p0</code> into the new partitions according to the
        rules embodied in the two <code class="literal">PARTITION ... VALUES
        ...</code> clauses, so that <code class="literal">s0</code> contains
        only those records for which
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(dob)</code></a> is less than 1960 and
        <code class="literal">s1</code> contains those rows in which
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR(dob)</code></a> is greater than or
        equal to 1960 but less than 1970.
      </p><p>
        A <code class="literal">REORGANIZE PARTITION</code> clause may also be
        used for merging adjacent partitions. You can return the
        <code class="literal">members</code> table to its previous partitioning as
        shown here:
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO (
    PARTITION p0 VALUES LESS THAN (1970)
);</pre><p>
        No data is lost in splitting or merging partitions using
        <code class="literal">REORGANIZE PARTITION</code>. In executing the above
        statement, MySQL moves all of the records that were stored in
        partitions <code class="literal">s0</code> and <code class="literal">s1</code> into
        partition <code class="literal">p0</code>.
      </p><p>
        The general syntax for <code class="literal">REORGANIZE PARTITION</code>
        is shown here:
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    REORGANIZE PARTITION <em class="replaceable"><code>partition_list</code></em>
    INTO (<em class="replaceable"><code>partition_definitions</code></em>);
</pre><p>
        Here, <em class="replaceable"><code>tbl_name</code></em> is the name of the
        partitioned table, and <em class="replaceable"><code>partition_list</code></em>
        is a comma-separated list of names of one or more existing
        partitions to be changed.
        <em class="replaceable"><code>partition_definitions</code></em> is a
        comma-separated list of new partition definitions, which follow
        the same rules as for the
        <em class="replaceable"><code>partition_definitions</code></em> list used in
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> (see
        <a class="xref" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax">Section 13.1.17, “<code class="literal">CREATE TABLE</code> Syntax”</a>). It should be noted that you are
        not limited to merging several partitions into one, or to
        splitting one partition into many, when using
        <code class="literal">REORGANIZE PARTITION</code>. For example, you can
        reorganize all four partitions of the <code class="literal">members</code>
        table into two, as follows:
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
    PARTITION m0 VALUES LESS THAN (1980),
    PARTITION m1 VALUES LESS THAN (2000)
);</pre><p>
        You can also use <code class="literal">REORGANIZE PARTITION</code> with
        tables that are partitioned by <code class="literal">LIST</code>. Let us
        return to the problem of adding a new partition to the
        list-partitioned <code class="literal">tt</code> table and failing because
        the new partition had a value that was already present in the
        value-list of one of the existing partitions. We can handle this
        by adding a partition that contains only nonconflicting values,
        and then reorganizing the new partition and the existing one so
        that the value which was stored in the existing one is now moved
        to the new one:
      </p><pre class="programlisting">ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
    PARTITION p1 VALUES IN (6, 18),
    PARTITION np VALUES in (4, 8, 12)
);</pre><p>
        Here are some key points to keep in mind when using
        <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> to
        repartition tables that are partitioned by
        <code class="literal">RANGE</code> or <code class="literal">LIST</code>:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            The <code class="literal">PARTITION</code> clauses used to determine
            the new partitioning scheme are subject to the same rules as
            those used with a <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement.
          </p><p>
            Most importantly, you should remember that the new
            partitioning scheme cannot have any overlapping ranges
            (applies to tables partitioned by <code class="literal">RANGE</code>)
            or sets of values (when reorganizing tables partitioned by
            <code class="literal">LIST</code>).
          </p></li><li class="listitem"><p>
            The combination of partitions in the
            <em class="replaceable"><code>partition_definitions</code></em> list should
            account for the same range or set of values overall as the
            combined partitions named in the
            <em class="replaceable"><code>partition_list</code></em>.
          </p><p>
            For instance, in the <code class="literal">members</code> table used
            as an example in this section, partitions
            <code class="literal">p1</code> and <code class="literal">p2</code> together
            cover the years 1980 through 1999. Therefore, any
            reorganization of these two partitions should cover the same
            range of years overall.
          </p></li><li class="listitem"><p>
            For tables partitioned by <code class="literal">RANGE</code>, you can
            reorganize only adjacent partitions; you cannot skip over
            range partitions.
          </p><p>
            For instance, you could not reorganize the
            <code class="literal">members</code> table used as an example in this
            section using a statement beginning with <code class="literal">ALTER
            TABLE members REORGANIZE PARTITION p0,p2 INTO ...</code>
            because <code class="literal">p0</code> covers the years prior to 1970
            and <code class="literal">p2</code> the years from 1990 through 1999
            inclusive, and thus the two are not adjacent partitions.
          </p></li><li class="listitem"><p>
            You cannot use <code class="literal">REORGANIZE PARTITION</code> to
            change the table's partitioning type; that is, you cannot
            (for example) change <code class="literal">RANGE</code> partitions to
            <code class="literal">HASH</code> partitions or <span class="foreignphrase"><em class="foreignphrase">vice
            versa</em></span>. You also cannot use this command to
            change the partitioning expression or column. To accomplish
            either of these tasks without dropping and re-creating the
            table, you can use
            <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
            TABLE ... PARTITION BY ...</code></a>. For example:
          </p><pre class="programlisting">ALTER TABLE members
    PARTITION BY HASH( YEAR(dob) )
PARTITIONS 8;</pre></li></ul>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-management-hash-key"></a>18.3.2. Management of <code class="literal">HASH</code> and <code class="literal">KEY</code>
Partitions</h3>
</div>
</div>
</div>
<a class="indexterm" name="idp127847520"></a><a class="indexterm" name="idp127849008"></a><a class="indexterm" name="idp127850496"></a><a class="indexterm" name="idp127851984"></a><p>
        Tables which are partitioned by hash or by key are very similar
        to one another with regard to making changes in a partitioning
        setup, and both differ in a number of ways from tables which
        have been partitioned by range or list. For that reason, this
        section addresses the modification of tables partitioned by hash
        or by key only. For a discussion of adding and dropping of
        partitions of tables that are partitioned by range or list, see
        <a class="xref" href="partitioning.html#partitioning-management-range-list" title="18.3.1. Management of RANGE and LIST Partitions">Section 18.3.1, “Management of <code class="literal">RANGE</code> and <code class="literal">LIST</code>
        Partitions”</a>.
      </p><p>
        You cannot drop partitions from tables that are partitioned by
        <code class="literal">HASH</code> or <code class="literal">KEY</code> in the same
        way that you can from tables that are partitioned by
        <code class="literal">RANGE</code> or <code class="literal">LIST</code>. However,
        you can merge <code class="literal">HASH</code> or <code class="literal">KEY</code>
        partitions using the <code class="literal">ALTER TABLE ... COALESCE
        PARTITION</code> statement. Suppose that you have a table
        containing data about clients, which is divided into twelve
        partitions. The <code class="literal">clients</code> table is defined as
        shown here:
      </p><pre class="programlisting">CREATE TABLE clients (
    id INT,
    fname VARCHAR(30),
    lname VARCHAR(30),
    signed DATE
)
PARTITION BY HASH( MONTH(signed) )
PARTITIONS 12;</pre><p>
        To reduce the number of partitions from twelve to eight, execute
        the following
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> command:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
        <code class="literal">COALESCE</code> works equally well with tables that
        are partitioned by <code class="literal">HASH</code>,
        <code class="literal">KEY</code>, <code class="literal">LINEAR HASH</code>, or
        <code class="literal">LINEAR KEY</code>. Here is an example similar to the
        previous one, differing only in that the table is partitioned by
        <code class="literal">LINEAR KEY</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE clients_lk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>signed DATE</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LINEAR KEY(signed)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 12;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE clients_lk COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        Note that the number following <code class="literal">COALESCE
        PARTITION</code> is the number of partitions to merge into
        the remainder—in other words, it is the number of
        partitions to remove from the table.
      </p><p>
        If you attempt to remove more partitions than the table has, the
        result is an error like the one shown:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 18;</code></strong>
ERROR 1478 (HY000): Cannot remove all partitions, use DROP TABLE instead
</pre><p>
        To increase the number of partitions for the
        <code class="literal">clients</code> table from 12 to 18. use
        <code class="literal">ALTER TABLE ... ADD PARTITION</code> as shown here:
</p><pre class="programlisting">ALTER TABLE clients ADD PARTITION PARTITIONS 6;</pre>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-management-exchange"></a>18.3.3. Exchanging Partitions and Subpartitions with Tables</h3>

</div>

</div>

</div>
<p>
        In MySQL 5.6, it is possible to exchange a table
        partition or subpartition with a table using the
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        EXCHANGE PARTITION</code></a> statement—that is, to move
        any existing rows in the partition or subpartition to the
        nonpartitioned table, and any existing rows in the
        nonpartitioned table to the table partition or subpartition.
      </p><p>
        Such operations are subject to the following conditions:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            The table to be exchanged must not be partitioned, but must
            otherwise have the same table structure as the partitioned
            table.
          </p></li><li class="listitem"><p>
            The table to be exchanged must not be a temporary table.
          </p></li><li class="listitem"><p>
            Any rows existing in the nonpartitioned table prior to the
            exchange must lie within the range defined for the partition
            or subpartition.
          </p></li><li class="listitem"><p>
            The table to be exchanged may not have any foreign keys, nor
            may any other tables have foreign keys which reference this
            table.
          </p></li><li class="listitem"><p>
            In addition to the <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a>,
            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a>, and
            <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a> privileges usually
            required for <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            statements, you must have the
            <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privilege to perform
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
            EXCHANGE PARTITION</code></a>.
</p></li></ul>
</div>
<p>
        In addition, you should also be aware of the following effects
        of <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        EXCHANGE PARTITION</code></a>:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Executing this statement does <span class="emphasis"><em>not</em></span>
            invoke any triggers on either the partitioned table or the
            exchanged table.
          </p></li><li class="listitem"><p>
            Any <code class="literal">AUTO_INCREMENT</code> columns in the
            exchanged table are reset.
</p></li></ul>
</div>
<p>
        The complete syntax of the the
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        EXCHANGE PARTITION</code></a> statement is shown here, where
        <em class="replaceable"><code>pt</code></em> is the partitioned table,
        <em class="replaceable"><code>p</code></em> is the partition or subpartition to
        be exchanged, and <em class="replaceable"><code>t</code></em> is the
        nonpartitioned table to be exchanged with
        <em class="replaceable"><code>p</code></em>:
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>pt</code></em> 
    EXCHANGE PARTITION <em class="replaceable"><code>p</code></em> 
    WITH TABLE <em class="replaceable"><code>t</code></em>;
</pre><p>
        One and only one partition or subpartition may be exchanged with
        one and only one nonpartitioned table in a single
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE
        EXCHANGE PARTITION</code></a> statement. To exchange multiple
        partitions or subpartitions, use multiple
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE
        EXCHANGE PARTITION</code></a> statements. <code class="literal">EXCHANGE
        PARTITION</code> may not be combined with other
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> options. The
        partitioning and (if applicable) subpartitioning used by the
        partitioned table may be of any type or types supported in MySQL
        5.6.
      </p><p>
        Suppose that a partitioned table <code class="literal">e</code> has been
        created and populated using the following SQL statements:
      </p><pre class="programlisting">CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (50),
        PARTITION p1 VALUES LESS THAN (100),
        PARTITION p2 VALUES LESS THAN (150),
        PARTITION p3 VALUES LESS THAN (MAXVALUE)
);

INSERT INTO e VALUES 
    (1669, "Jim", "Smith"),
    (337, "Mary", "Jones"),
    (16, "Frank", "White"),
    (2005, "Linda", "Black");</pre><p>
        Now we create a nonpartitioned copy of <code class="literal">e</code>
        named <code class="literal">e2</code>. This can be done using the
        <a class="link" href="programs.html#mysql" title="4.5.1. mysql — The MySQL Command-Line Tool"><span class="command"><strong>mysql</strong></span></a> client as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE e2 LIKE e;</code></strong>
Query OK, 0 rows affected (1.34 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.90 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        You can see which partitions in table <code class="literal">e</code>
        contain rows by querying the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>
        table, like this:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><p>
        To exchange partition <code class="literal">p0</code> in table
        <code class="literal">e</code> with table <code class="literal">e2</code>, you can
        use the
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.28 sec)
</pre><p>
        More precisely, the statement just issued causes any rows found
        in the partition to be swapped with those found in the table.
        You can observe how this has happened by querying the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>
        table, as before. The table row that was previously found in
        partition <code class="literal">p0</code> is no longer present:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><p>
        If you query table <code class="literal">e2</code>, you can see that the
        <span class="quote">“<span class="quote">missing</span>”</span> row can now be found there:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
</pre><p>
        The table to be exchanged with the partition does not
        necessarily have to be empty. To demonstrate this, we first
        insert a new row into table <code class="literal">e</code>, making sure
        that this row is stored in partition <code class="literal">p0</code> by
        choosing an <code class="literal">id</code> column value that is less than
        50, and verifying this afterwards by querying the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table:
      </p><pre class="programlisting">                                                            
mysql&gt; <strong class="userinput"><code>INSERT INTO e VALUES (41, "Michael", "Green");</code></strong>              
Query OK, 1 row affected (0.05 sec)                                

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong> 
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>              
+----------------+------------+               
| PARTITION_NAME | TABLE_ROWS |               
+----------------+------------+               
| p0             |          1 |               
| p1             |          0 |               
| p2             |          0 |               
| p3             |          3 |               
+----------------+------------+               
4 rows in set (0.00 sec)          
</pre><p>
        Now we once again exchange partition <code class="literal">p0</code> with
        table <code class="literal">e2</code> using the same
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement as previously:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.28 sec)
</pre><p>
        The output of the following queries shows that the table row
        that was stored in partition <code class="literal">p0</code> and the table
        row that was stored in table <code class="literal">e2</code>, prior to
        issuing the
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement, have now switched places:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM e;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
</pre><p>
        You should keep in mind that any rows found in the
        nonpartitioned table prior to issuing the
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        EXCHANGE PARTITION</code></a> statement must meet any conditions
        required for them to be stored in the target partition;
        otherwise, the statement fails. To see how this occurs, first
        insert a row into <code class="literal">e2</code> that cannot be stored in
        partition <code class="literal">p0</code> of table <code class="literal">e</code>
        because its <code class="literal">id</code> column value is too large;
        then, try to exchange the table with the partition again:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO e2 VALUES (51, "Ellen", "McDonald");</code></strong>
Query OK, 1 row affected (0.08 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
<span class="errortext">ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre><p>
        The <code class="literal">IGNORE</code> keyword is accepted, but has no
        effect when used with <code class="literal">EXCHANGE PARTITION</code>, as
        shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER IGNORE TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
<span class="errortext">ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre><p>
        You can also exchange a subpartition of a subpartitioned table
        (see <a class="xref" href="partitioning.html#partitioning-subpartitions" title="18.2.6. Subpartitioning">Section 18.2.6, “Subpartitioning”</a>) with a
        nonpartitioned table using an
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        EXCHANGE PARTITION</code></a> statement. In the following
        example, we first create a table <code class="literal">es</code> that is
        partitioned by <code class="literal">RANGE</code> and subpartitioned by
        <code class="literal">KEY</code>, populate this table as we did table
        <code class="literal">e</code>, and then create an empty, nonpartitioned
        copy <code class="literal">es2</code> of the table, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE es (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE (id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (50),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (100),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (150),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (2.76 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO es VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1669, "Jim", "Smith"),</code></strong>
    -&gt;     <strong class="userinput"><code>(337, "Mary", "Jones"),</code></strong>
    -&gt;     <strong class="userinput"><code>(16, "Frank", "White"),</code></strong>
    -&gt;     <strong class="userinput"><code>(2005, "Linda", "Black");</code></strong>
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>CREATE TABLE es2 LIKE es;</code></strong>
Query OK, 0 rows affected (1.27 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.70 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        Although we did not explicitly name any of the subpartitions
        when creating table <code class="literal">es</code>, we can obtain
        generated names for these by including the
        <code class="literal">SUBPARTITION_NAME</code> of the
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table from
        <code class="literal">INFORMATION_SCHEMA</code> when selecting from that
        table, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          3 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)
</pre><p>
        The following
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement exchanges subpartition
        <code class="literal">p3sp0</code> table <code class="literal">es</code> with the
        nonpartitioned table <code class="literal">es2</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;</code></strong>
Query OK, 0 rows affected (0.29 sec)
</pre><p>
        You can verify that the rows were exchanged by issuing the
        following queries:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          0 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM es2;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
3 rows in set (0.00 sec)
</pre><p>
        If a table is subpartitioned, you can exchange only a
        subpartition of the table—not an entire
        partition—with an unpartitioned table, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;</code></strong>
<span class="errortext">ERROR 1704 (HY000): Subpartitioned table, use subpartition instead of partition</span>
</pre><p>
        The comparison of table structures used by MySQL is very strict.
        The number, order, names, and types of columns and indexes of
        the partitioned table and the nonpartitioned table must match
        exactly. In addition, both tables must use the same storage
        engine:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE es3 LIKE e;</code></strong>
Query OK, 0 rows affected (1.31 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.53 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE es3\G</code></strong>
*************************** 1. row ***************************
       Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 ENGINE = MyISAM;</code></strong>
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es3;</code></strong>
<span class="errortext">ERROR 1497 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL</span>
</pre>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-maintenance"></a>18.3.4. Maintenance of Partitions</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp128018000"></a><a class="indexterm" name="idp128019488"></a><a class="indexterm" name="idp128020976"></a><a class="indexterm" name="idp128022464"></a><a class="indexterm" name="idp128023952"></a><a class="indexterm" name="idp128025440"></a><a class="indexterm" name="idp128026928"></a><a class="indexterm" name="idp128028416"></a><p>
        A number of table and partition maintenance tasks can be carried
        out using SQL statements intended for such purposes on
        partitioned tables in MySQL 5.6.
      </p><p>
        Table maintenance of partitioned tables can be accomplished
        using the statements <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2. CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>,
        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4. OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>,
        <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1. ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, and
        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5. REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>, which are supported
        for partitioned tables.
      </p><p>
        You can use a number of extensions to
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> for performing operations of this type on one or
        more partitions directly, as described in the following list:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Rebuilding partitions. </b>
              Rebuilds the partition; this has the same effect as
              dropping all records stored in the partition, then
              reinserting them. This can be useful for purposes of
              defragmentation.
            </p><p>
            Example:
          </p><pre class="programlisting">ALTER TABLE t1 REBUILD PARTITION p0, p1;</pre></li><li class="listitem"><p><b>Optimizing partitions. </b>
              If you have deleted a large number of rows from a
              partition or if you have made many changes to a
              partitioned table with variable-length rows (that is,
              having <code class="literal">VARCHAR</code>,
              <code class="literal">BLOB</code>, or <code class="literal">TEXT</code>
              columns), you can use <code class="literal">ALTER TABLE ... OPTIMIZE
              PARTITION</code> to reclaim any unused space and to
              defragment the partition data file.
            </p><p>
            Example:
          </p><pre class="programlisting">ALTER TABLE t1 OPTIMIZE PARTITION p0, p1;</pre><p>
            Using <code class="literal">OPTIMIZE PARTITION</code> on a given
            partition is equivalent to running <code class="literal">CHECK
            PARTITION</code>, <code class="literal">ANALYZE PARTITION</code>,
            and <code class="literal">REPAIR PARTITION</code> on that partition.
          </p><p>
            Some MySQL storage engines, including
            <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, do not support
            per-partition optimization; in these cases,
            <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
            TABLE ... OPTIMIZE PARTITION</code></a> rebuilds the entire
            table. In MySQL 5.6.9 and later, running this statement on
            such a table causes the entire table to rebuilt and
            analyzed, and an appropriate warning to be issued. (Bug
            #11751825, Bug #42822) Use <code class="literal">ALTER TABLE ... REBUILD
            PARTITION</code> and <code class="literal">ALTER TABLE ... ANALYZE
            PARTITION</code> instead, to avoid this issue.
          </p></li><li class="listitem"><p><b>Analyzing partitions. </b>
              This reads and stores the key distributions for
              partitions.
            </p><p>
            Example:
          </p><pre class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p3;</pre></li><li class="listitem"><p><b>Repairing partitions. </b>
              This repairs corrupted partitions.
            </p><p>
            Example:
          </p><pre class="programlisting">ALTER TABLE t1 REPAIR PARTITION p0,p1;</pre></li><li class="listitem"><p><b>Checking partitions. </b>
              You can check partitions for errors in much the same way
              that you can use <code class="literal">CHECK TABLE</code> with
              nonpartitioned tables.
            </p><p>
            Example:
          </p><pre class="programlisting">ALTER TABLE trb3 CHECK PARTITION p1;</pre><p>
            This command will tell you if the data or indexes in
            partition <code class="literal">p1</code> of table
            <code class="literal">t1</code> are corrupted. If this is the case,
            use <code class="literal">ALTER TABLE ... REPAIR PARTITION</code> to
            repair the partition.
</p></li></ul>
</div>
<p>
        Each of the statements in the list just shown also supports the
        keyword <code class="literal">ALL</code> in place of the list of partition
        names. Using <code class="literal">ALL</code> causes the statement to act
        on all partitions in the table.
      </p><p>
        The use of <a class="link" href="programs.html#mysqlcheck" title="4.5.3. mysqlcheck — A Table Maintenance Program"><span class="command"><strong>mysqlcheck</strong></span></a> and
        <a class="link" href="programs.html#myisamchk" title="4.6.3. myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> is not supported with partitioned
        tables.
      </p><p>
        In MySQL 5.6, you can also truncate partitions
        using <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE
        ... TRUNCATE PARTITION</code></a>. This statement can be used to
        delete all rows from one or more partitions in much the same way
        that <a class="link" href="sql-syntax.html#truncate-table" title="13.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> deletes all
        rows from a table.
      </p><p>
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
        TRUNCATE PARTITION ALL</code></a> truncates all partitions in the
        table.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-info"></a>18.3.5. Obtaining Information About Partitions</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp128073264"></a><a class="indexterm" name="idp128074352"></a><a class="indexterm" name="idp128075440"></a><a class="indexterm" name="idp128076528"></a><p>
        This section discusses obtaining information about existing
        partitions, which can be done in a number of ways. Methods of
        obtaining such information include the following:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Using the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.12. SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>
            statement to view the partitioning clauses used in creating
            a partitioned table.
          </p></li><li class="listitem"><p>
            Using the <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.37. SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>
            statement to determine whether a table is partitioned.
          </p></li><li class="listitem"><p>
            Querying the
            <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">INFORMATION_SCHEMA.PARTITIONS</code></a>
            table.
          </p></li><li class="listitem"><p>
            Using the statement
            <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN PARTITIONS
            SELECT</code></a> to see which partitions are used by a given
            <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>.
</p></li></ul>
</div>
<p>
        As discussed elsewhere in this chapter,
        <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.12. SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> includes in its
        output the <code class="literal">PARTITION BY</code> clause used to create
        a partitioned table. For example:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE trb3\G</code></strong>
*************************** 1. row ***************************
       Table: trb3
Create Table: CREATE TABLE `trb3` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(purchased)) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (2000) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM
)
1 row in set (0.00 sec)
</pre><p>
        The output from <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.37. SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>
        for partitioned tables is the same as that for nonpartitioned
        tables, except that the <code class="literal">Create_options</code> column
        contains the string <code class="literal">partitioned</code>. The
        <code class="literal">Engine</code> column contains the name of the
        storage engine used by all partitions of the table. (See
        <a class="xref" href="sql-syntax.html#show-table-status" title="13.7.5.37. SHOW TABLE STATUS Syntax">Section 13.7.5.37, “<code class="literal">SHOW TABLE STATUS</code> Syntax”</a>, for more information about
        this statement.)
      </p><p>
        You can also obtain information about partitions from
        <code class="literal">INFORMATION_SCHEMA</code>, which contains a
        <a class="link" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table. See
        <a class="xref" href="information-schema.html#partitions-table" title="20.14. The INFORMATION_SCHEMA PARTITIONS Table">Section 20.14, “The <code class="literal">INFORMATION_SCHEMA PARTITIONS</code> Table”</a>.
      </p><a class="indexterm" name="idp128097232"></a><a class="indexterm" name="idp128098720"></a><p>
        It is possible to determine which partitions of a partitioned
        table are involved in a given
        <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> query using
        <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
        PARTITIONS</code></a>. The <code class="literal">PARTITIONS</code> keyword
        adds a <code class="literal">partitions</code> column to the output of
        <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> listing the partitions
        from which records would be matched by the query.
      </p><p>
        Suppose that you have a table <code class="literal">trb1</code> created
        and populated as follows:
      </p><pre class="programlisting">CREATE TABLE trb1 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE(id)
    (
        PARTITION p0 VALUES LESS THAN (3),
        PARTITION p1 VALUES LESS THAN (7),
        PARTITION p2 VALUES LESS THAN (9),
        PARTITION p3 VALUES LESS THAN (11)
    );

INSERT INTO trb1 VALUES
    (1, 'desk organiser', '2003-10-15'),
    (2, 'CD player', '1993-11-05'),
    (3, 'TV set', '1996-03-10'),
    (4, 'bookcase', '1982-01-10'),
    (5, 'exercise bike', '2004-05-09'),
    (6, 'sofa', '1987-06-05'),
    (7, 'popcorn maker', '2001-11-22'),
    (8, 'aquarium', '1992-08-04'),
    (9, 'study desk', '1984-09-16'),
    (10, 'lava lamp', '1998-12-25');</pre><p>
        You can see which partitions are used in a query such as
        <code class="literal">SELECT * FROM trb1;</code>, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1,p2,p3
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using filesort
</pre><p>
        In this case, all four partitions are searched. However, when a
        limiting condition making use of the partitioning key is added
        to the query, you can see that only those partitions containing
        matching values are scanned, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where
</pre><p>
        <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
        PARTITIONS</code></a> provides information about keys used and
        possible keys, just as with the standard
        <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
        SELECT</code></a> statement:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE trb1 ADD PRIMARY KEY (id);</code></strong>
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 7
        Extra: Using where
</pre><p>
        You should take note of the following restrictions and
        limitations on <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
        PARTITIONS</code></a>:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            You cannot use the <code class="literal">PARTITIONS</code> and
            <code class="literal">EXTENDED</code> keywords together in the same
            <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN ...
            SELECT</code></a> statement. Attempting to do so produces a
            syntax error.
          </p></li><li class="listitem"><p>
            If <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
            PARTITIONS</code></a> is used to examine a query against a
            nonpartitioned table, no error is produced, but the value of
            the <code class="literal">partitions</code> column is always
            <code class="literal">NULL</code>.
</p></li></ul>
</div>
<p>
        The <code class="literal">rows</code> column of
        <a class="link" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
        PARTITIONS</code></a> output displays the total number of rows in
        the table.
      </p><p>
        See also <a class="xref" href="sql-syntax.html#explain" title="13.8.2. EXPLAIN Syntax">Section 13.8.2, “<code class="literal">EXPLAIN</code> Syntax”</a>.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-pruning"></a>18.4. Partition Pruning</h2>

</div>

</div>

</div>
<a class="indexterm" name="idp128129504"></a><a class="indexterm" name="idp128130576"></a><p>
      This section discusses an optimization known as
      <em class="firstterm">partition pruning</em>. The core concept behind
      partition pruning is relatively simple, and can be described as
      <span class="quote">“<span class="quote">Do not scan partitions where there can be no matching
      values</span>”</span>. Suppose that you have a partitioned table
      <code class="literal">t1</code> defined by this statement:
    </p><pre class="programlisting">CREATE TABLE t1 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( region_code ) (
    PARTITION p0 VALUES LESS THAN (64),
    PARTITION p1 VALUES LESS THAN (128),
    PARTITION p2 VALUES LESS THAN (192),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);</pre><p>
      Consider the case where you wish to obtain results from a
      <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement such as this one:
    </p><pre class="programlisting">SELECT fname, lname, region_code, dob
    FROM t1
    WHERE region_code &gt; 125 AND region_code &lt; 130;</pre><p>
      It is easy to see that none of the rows which ought to be returned
      will be in either of the partitions <code class="literal">p0</code> or
      <code class="literal">p3</code>; that is, we need to search only in
      partitions <code class="literal">p1</code> and <code class="literal">p2</code> to find
      matching rows. By doing so, it is possible to expend much less
      time and effort in finding matching rows than would be required to
      scan all partitions in the table. This <span class="quote">“<span class="quote">cutting away</span>”</span>
      of unneeded partitions is known as <em class="firstterm">pruning</em>.
      When the optimizer can make use of partition pruning in performing
      this query, execution of the query can be an order of magnitude
      faster than the same query against a nonpartitioned table
      containing the same column definitions and data.
    </p><p>
      The optimizer can perform pruning whenever a
      <code class="literal">WHERE</code> condition can be reduced to either one of
      the following two cases:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> =
          <em class="replaceable"><code>constant</code></em></code>
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> IN
          (<em class="replaceable"><code>constant1</code></em>,
          <em class="replaceable"><code>constant2</code></em>, ...,
          <em class="replaceable"><code>constantN</code></em>)</code>
</p></li></ul>
</div>
<p>
      In the first case, the optimizer simply evaluates the partitioning
      expression for the value given, determines which partition
      contains that value, and scans only this partition. In many cases,
      the equal sign can be replaced with another arithmetic comparison,
      including <code class="literal">&lt;</code>, <code class="literal">&gt;</code>,
      <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>, and
      <code class="literal">&lt;&gt;</code>. Some queries using
      <code class="literal">BETWEEN</code> in the <code class="literal">WHERE</code> clause
      can also take advantage of partition pruning. See the examples
      later in this section.
    </p><p>
      In the second case, the optimizer evaluates the partitioning
      expression for each value in the list, creates a list of matching
      partitions, and then scans only the partitions in this partition
      list.
    </p><p>
      MySQL can apply partition pruning to
      <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>,
      <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a>, and
      <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
      <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statements currently cannot
      be pruned.
    </p><p>
      Pruning can also be applied to short ranges, which the optimizer
      can convert into equivalent lists of values. For instance, in the
      previous example, the <code class="literal">WHERE</code> clause can be
      converted to <code class="literal">WHERE region_code IN (126, 127, 128,
      129)</code>. Then the optimizer can determine that the first
      three values in the list are found in partition
      <code class="literal">p1</code>, the remaining three values in partition
      <code class="literal">p2</code>, and that the other partitions contain no
      relevant values and so do not need to be searched for matching
      rows.
    </p><p>
      In MySQL 5.6, the optimizer can also perform pruning
      for <code class="literal">WHERE</code> conditions that involve comparisons
      of the preceding types on multiple columns for tables that use
      <code class="literal">RANGE COLUMNS</code> or <code class="literal">LIST
      COLUMNS</code> partitioning.
    </p><a class="indexterm" name="idp128165520"></a><p>
      This type of optimization can be applied whenever the partitioning
      expression consists of an equality or a range which can be reduced
      to a set of equalities, or when the partitioning expression
      represents an increasing or decreasing relationship. Pruning can
      also be applied for tables partitioned on a
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
      <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column when the
      partitioning expression uses the
      <a class="link" href="functions.html#function_year"><code class="literal">YEAR()</code></a> or
      <a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS()</code></a> function. In addition, in
      MySQL 5.6, pruning can be applied for such tables
      when the partitioning expression uses the
      <a class="link" href="functions.html#function_to-seconds"><code class="literal">TO_SECONDS()</code></a> function.
    </p><p>
      Suppose that table <code class="literal">t2</code>, defined as shown here,
      is partitioned on a <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> column:
    </p><pre class="programlisting">CREATE TABLE t2 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION d0 VALUES LESS THAN (1970),
    PARTITION d1 VALUES LESS THAN (1975),
    PARTITION d2 VALUES LESS THAN (1980),
    PARTITION d3 VALUES LESS THAN (1985),
    PARTITION d4 VALUES LESS THAN (1990),
    PARTITION d5 VALUES LESS THAN (2000),
    PARTITION d6 VALUES LESS THAN (2005),
    PARTITION d7 VALUES LESS THAN MAXVALUE
);</pre><p>
      The following statements using <code class="literal">t2</code> can make of
      use partition pruning:
    </p><pre class="programlisting">SELECT * FROM t2 WHERE dob = '1982-06-23';

UPDATE t2 SET region_code = 8 WHERE dob BETWEEN '1991-02-15' AND '1997-04-25';

DELETE FROM t2 WHERE dob &gt;= '1984-06-21' AND dob &lt;= '1999-06-21'</pre><p>
      In the case of the last statement, the optimizer can also act as
      follows:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>Find the partition containing the low end of the
          range</em></span>.
        </p><p>
          <a class="link" href="functions.html#function_year"><code class="literal">YEAR('1984-06-21')</code></a> yields the
          value <code class="literal">1984</code>, which is found in partition
          <code class="literal">d3</code>.
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>Find the partition containing the high end of the
          range</em></span>.
        </p><p>
          <a class="link" href="functions.html#function_year"><code class="literal">YEAR('1999-06-21')</code></a> evaluates to
          <code class="literal">1999</code>, which is found in partition
          <code class="literal">d5</code>.
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>Scan only these two partitions and any partitions
          that may lie between them</em></span>.
        </p><p>
          In this case, this means that only partitions
          <code class="literal">d3</code>, <code class="literal">d4</code>, and
          <code class="literal">d5</code> are scanned. The remaining partitions
          may be safely ignored (and are ignored).
</p></li></ol>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Important
</div>
<p xmlns="">
        Invalid <code class="literal">DATE</code> and <code class="literal">DATETIME</code>
        values referenced in the <code class="literal">WHERE</code> condition of a
        statement against a partitioned table are treated as
        <code class="literal">NULL</code>. This means that a query such as
        <code class="literal">SELECT * FROM
        <em class="replaceable"><code>partitioned_table</code></em> WHERE
        <em class="replaceable"><code>date_column</code></em> &lt;
        '2008-12-00'</code> does not return any values (see Bug
        #40972).
</p>
</div>
<p>
      So far, we have looked only at examples using
      <code class="literal">RANGE</code> partitioning, but pruning can be applied
      with other partitioning types as well.
    </p><p>
      Consider a table that is partitioned by <code class="literal">LIST</code>,
      where the partitioning expression is increasing or decreasing,
      such as the table <code class="literal">t3</code> shown here. (In this
      example, we assume for the sake of brevity that the
      <code class="literal">region_code</code> column is limited to values between
      1 and 10 inclusive.)
    </p><pre class="programlisting">CREATE TABLE t3 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY LIST(region_code) (
    PARTITION r0 VALUES IN (1, 3),
    PARTITION r1 VALUES IN (2, 5, 8),
    PARTITION r2 VALUES IN (4, 9),
    PARTITION r3 VALUES IN (6, 7, 10)
);</pre><p>
      For a statement such as <code class="literal">SELECT * FROM t3 WHERE
      region_code BETWEEN 1 AND 3</code>, the optimizer determines in
      which partitions the values 1, 2, and 3 are found
      (<code class="literal">r0</code> and <code class="literal">r1</code>) and skips the
      remaining ones (<code class="literal">r2</code> and <code class="literal">r3</code>).
    </p><p>
      For tables that are partitioned by <code class="literal">HASH</code> or
      <code class="literal">KEY</code>, partition pruning is also possible in
      cases in which the <code class="literal">WHERE</code> clause uses a simple
      <code class="literal">=</code> relation against a column used in the
      partitioning expression. Consider a table created like this:
    </p><pre class="programlisting">CREATE TABLE t4 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY KEY(region_code)
PARTITIONS 8;</pre><p>
      A statement that compares a column value with a constant can be
      pruned:
    </p><pre class="programlisting">UPDATE t4 WHERE region_code = 7;</pre><p>
      Pruning can also be employed for short ranges, because the
      optimizer can turn such conditions into <code class="literal">IN</code>
      relations. For example, using the same table <code class="literal">t4</code>
      as defined previously, queries such as these can be pruned:
    </p><pre class="programlisting">SELECT * FROM t4 WHERE region_code &gt; 2 AND region_code &lt; 6;

SELECT * FROM t4 WHERE region_code BETWEEN 3 AND 5;</pre><p>
      In both these cases, the <code class="literal">WHERE</code> clause is
      transformed by the optimizer into <code class="literal">WHERE region_code IN
      (3, 4, 5)</code>.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p xmlns="">
        This optimization is used only if the range size is smaller than
        the number of partitions. Consider this statement:
      </p><pre class="programlisting">DELETE FROM t4 WHERE region_code BETWEEN 4 AND 12;</pre><p xmlns="">
        The range in the <code class="literal">WHERE</code> clause covers 9 values
        (4, 5, 6, 7, 8, 9, 10, 11, 12), but <code class="literal">t4</code> has
        only 8 partitions. This means that the <code class="literal">DELETE</code>
        cannot be pruned.
</p>
</div>
<p>
      When a table is partitioned by <code class="literal">HASH</code> or
      <code class="literal">KEY</code>, pruning can be used only on integer
      columns. For example, this statement cannot use pruning because
      <code class="literal">dob</code> is a <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>
      column:
    </p><pre class="programlisting">SELECT * FROM t4 WHERE dob &gt;= '2001-04-14' AND dob &lt;= '2005-10-15';</pre><p>
      However, if the table stores year values in an
      <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> column, then a query having
      <code class="literal">WHERE year_col &gt;= 2001 AND year_col &lt;=
      2005</code> can be pruned.
    </p><p>
      In MySQL 5.6.8 and later, partition pruning is disabled for all
      tables using a storage engine that provides automatic
      partitioning, such as the <code class="literal">NDB</code> storage engine
      used by MySQL Cluster (not currently supported in MySQL
      5.6). (Bug #14672885) Beginning with MySQL 5.6.10,
      such tables can be pruned if they are explicitly partitioned. (Bug
      #14827952)
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-selection"></a>18.5. Partition Selection</h2>

</div>

</div>

</div>
<p>
      MySQL 5.6 supports explicit selection of partitions
      and subpartitions that, when executing a statement, should be
      checked for rows matching a given <code class="literal">WHERE</code>
      condition. Partition selection is similar to partition pruning, in
      that only specific partitions are checked for matches, but differs
      in two key respects:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          The partitions to be checked are specified by the issuer of
          the statement, unlike partition pruning, which is automatic.
        </p></li><li class="listitem"><p>
          Whereas partition pruning applies only to queries, explicit
          selection of partitions is supported for both queries and a
          number of DML statements.
</p></li></ol>
</div>
<p>
      SQL statements supporting explicit partition selection are listed
      here:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a>
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a>
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#replace" title="13.2.8. REPLACE Syntax"><code class="literal">REPLACE</code></a>
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a>
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#load-data" title="13.2.6. LOAD DATA INFILE Syntax"><code class="literal">LOAD DATA</code></a>.
        </p></li><li class="listitem"><p>
          <a class="link" href="sql-syntax.html#load-xml" title="13.2.7. LOAD XML Syntax"><code class="literal">LOAD XML</code></a>.
</p></li></ul>
</div>
<p>
      The remainder of this section discusses explicit partition
      selection as it applies generally to the statements just listed,
      and provides some examples.
    </p><p>
      Explicit partition selection is implemented using a
      <code class="literal">PARTITION</code> option. For all supported statements,
      this option uses the syntax shown here:
    </p><pre class="programlisting">      PARTITION (<em class="replaceable"><code>partition_names</code></em>)

      <em class="replaceable"><code>partition_names</code></em>:
          <em class="replaceable"><code>partition_name</code></em>, ...
</pre><p>
      This option always follows the name of the table to which the
      partition or partitions belong.
      <em class="replaceable"><code>partition_names</code></em> is a comma-separated
      list of partitions or subpartitions to be used. Each name in this
      list must be the name of an existing partition or subpartition of
      the specified table; if any of the partitions or subpartitions are
      not found, the statement fails with an error (<span class="errortext">partition
      '<em class="replaceable"><code>partition_name</code></em>' doesn't
      exist</span>). Partitions and subpartitions named in
      <em class="replaceable"><code>partition_names</code></em> may be listed in any
      order, and may overlap.
    </p><p>
      When the <code class="literal">PARTITION</code> option is used, only the
      partitions and subpartitions listed are checked for matching rows.
      This option can be used in a <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
      statement to determine which rows belong to a given partition.
      Consider a partitioned table named <code class="literal">employees</code>,
      created and populated using the statements shown here:
    </p><pre class="programlisting">SET @@SQL_MODE = '';

CREATE TABLE employees  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fname VARCHAR(25) NOT NULL,
    lname VARCHAR(25) NOT NULL,
    store_id INT NOT NULL,
    department_id INT NOT NULL
)   
    PARTITION BY RANGE(id)  (
        PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (10),
        PARTITION p2 VALUES LESS THAN (15),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO employees VALUES
    ('', 'Bob', 'Taylor', 3, 2), ('', 'Frank', 'Williams', 1, 2), 
    ('', 'Ellen', 'Johnson', 3, 4), ('', 'Jim', 'Smith', 2, 4),  
    ('', 'Mary', 'Jones', 1, 1), ('', 'Linda', 'Black', 2, 3),
    ('', 'Ed', 'Jones', 2, 1), ('', 'June', 'Wilson', 3, 1), 
    ('', 'Andy', 'Smith', 1, 3), ('', 'Lou', 'Waters', 2, 4),  
    ('', 'Jill', 'Stone', 1, 4), ('', 'Roger', 'White', 3, 2),
    ('', 'Howard', 'Andrews', 1, 2), ('', 'Fred', 'Goldberg', 3, 3), 
    ('', 'Barbara', 'Brown', 2, 3), ('', 'Alice', 'Rogers', 2, 2),  
    ('', 'Mark', 'Morgan', 3, 3), ('', 'Karen', 'Cole', 3, 2);</pre><p>
      You can see which rows are stored in partition
      <code class="literal">p1</code> like this:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p1);</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  |        1 |             1 |
|  6 | Linda | Black  |        2 |             3 |
|  7 | Ed    | Jones  |        2 |             1 |
|  8 | June  | Wilson |        3 |             1 |
|  9 | Andy  | Smith  |        1 |             3 |
+----+-------+--------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      The result is the same as obtained by the query <code class="literal">SELECT *
      FROM employees WHERE id BETWEEN 5 AND 9</code>.
    </p><p>
      To obtain rows from multiple partitions, supply their names as a
      comma-delimited list. For example, <code class="literal">SELECT * FROM
      employees PARTITION (p1, p2)</code> returns all rows from
      partitions <code class="literal">p1</code> and <code class="literal">p2</code> while
      excluding rows from the remaining partitions.
    </p><p>
      Any valid query against a partitioned table can be rewritten with
      a <code class="literal">PARTITION</code> option to restrict the result to
      one or more desired partitions. You can use
      <code class="literal">WHERE</code> conditions, <code class="literal">ORDER BY</code>
      and <code class="literal">LIMIT</code> options, and so on. You can also use
      aggregate functions with <code class="literal">HAVING</code> and
      <code class="literal">GROUP BY</code> options. Each of the following queries
      produces a valid result when run on the
      <code class="literal">employees</code> table as previously defined:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p0, p2)</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE lname LIKE 'S%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith |        2 |             4 |
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p0) ORDER BY lname;</code></strong>
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT store_id, COUNT(department_id) AS c</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p1,p2,p3)</code></strong> 
    -&gt;     <strong class="userinput"><code>GROUP BY store_id HAVING c &gt; 4;</code></strong>
+---+----------+
| c | store_id |
+---+----------+
| 5 |        2 |
| 5 |        3 |
+---+----------+
2 rows in set (0.00 sec)
</pre><p>
      Statements using partition selection can be employed with tables
      using any of the partitioning types supported in MySQL
      5.6. When a table is created using <code class="literal">[LINEAR]
      HASH</code> or <code class="literal">[LINEAR] KEY</code> partitioning and
      the names of the partitions are not specified, MySQL automatically
      names the partitions <code class="literal">p0</code>, <code class="literal">p1</code>,
      <code class="literal">p2</code>, ...,
      <code class="literal">p<em class="replaceable"><code>N-1</code></em></code>, where
      <em class="replaceable"><code>N</code></em> is the number of partitions. For
      subpartitions not explicitly named, MySQL assigns automatically to
      the subpartitions in each partition
      <code class="literal">p<em class="replaceable"><code>X</code></em></code> the names
      <code class="literal">p<em class="replaceable"><code>X</code></em>sp0</code>,
      <code class="literal">p<em class="replaceable"><code>X</code></em>sp1</code>,
      <code class="literal">p<em class="replaceable"><code>X</code></em>sp2</code>, ...,
      <code class="literal">p<em class="replaceable"><code>X</code></em>sp<em class="replaceable"><code>M-1</code></em></code>,
      where <em class="replaceable"><code>M</code></em> is the number of subpartitions.
      When executing against this table a
      <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> (or other SQL statement for
      which explicit partition selection is allowed), you can use these
      generated names in a <code class="literal">PARTITION</code> option, as shown
      here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_sub  (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>store_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>department_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY pk (id, lname)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>   
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (1.14 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_sub</code></strong>   # re-use data in employees table
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees;</code></strong>
Query OK, 18 rows affected (0.09 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong>
    -&gt;     <strong class="userinput"><code>FROM employees_sub PARTITION (p2sp1);</code></strong>
+----+---------------+
| id | name          |
+----+---------------+
| 10 | Lou Waters    |
| 14 | Fred Goldberg |
+----+---------------+
2 rows in set (0.00 sec)
</pre><p>
      You may also use a <code class="literal">PARTITION</code> option in the
      <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> portion of an
      <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1. INSERT ... SELECT Syntax"><code class="literal">INSERT ...
      SELECT</code></a> statement, as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_copy LIKE employees;</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_copy</code></strong> 
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees PARTITION (p2);</code></strong>
Query OK, 5 rows affected (0.04 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees_copy;</code></strong>
+----+--------+----------+----------+---------------+
| id | fname  | lname    | store_id | department_id |
+----+--------+----------+----------+---------------+
| 10 | Lou    | Waters   |        2 |             4 |
| 11 | Jill   | Stone    |        1 |             4 |
| 12 | Roger  | White    |        3 |             2 |
| 13 | Howard | Andrews  |        1 |             2 |
| 14 | Fred   | Goldberg |        3 |             3 |
+----+--------+----------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      Partition selection can also be used with joins. Suppose we create
      and populate two tables using the statements shown here:
    </p><pre class="programlisting">CREATE TABLE stores (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    city VARCHAR(30) NOT NULL
)
    PARTITION BY HASH(id)
    PARTITIONS 2;
    
INSERT INTO stores VALUES
    ('', 'Nambucca'), ('', 'Uranga'), 
    ('', 'Bellingen'), ('', 'Grafton');
    
CREATE TABLE departments  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30) NOT NULL
)
    PARTITION BY KEY(id)
    PARTITIONS 2;
    
INSERT INTO departments VALUES
    ('', 'Sales'), ('', 'Customer Service'), 
    ('', 'Delivery'), ('', 'Accounting');</pre><p>
      You can explicitly select partitions (or subpartitions, or both)
      from any or all of the tables in a join. (Note that the
      <code class="literal">PARTITION</code> option used to select partitions from
      a given table immediately follows the name of the table, before
      all other options, including any table alias.) For example, the
      following query gets the name, employee ID, department, and city
      of all employees who work in the Sales or Delivery department
      (partition <code class="literal">p1</code> of the
      <code class="literal">departments</code> table) at the stores in either of
      the cities of Nambucca and Bellingen (partition
      <code class="literal">p0</code> of the <code class="literal">stores</code> table):
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;     <strong class="userinput"><code>e.id AS 'Employee ID', CONCAT(e.fname, ' ', e.lname) AS Name,</code></strong>
    -&gt;     <strong class="userinput"><code>s.city AS City, d.name AS department</code></strong>
    -&gt; <strong class="userinput"><code>FROM employees AS e</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN stores PARTITION (p1) AS s ON e.store_id=s.id</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN departments PARTITION (p0) AS d ON e.department_id=d.id</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY e.lname;</code></strong>
+-------------+---------------+-----------+------------+
| Employee ID | Name          | City      | department |
+-------------+---------------+-----------+------------+
|          14 | Fred Goldberg | Bellingen | Delivery   |
|           5 | Mary Jones    | Nambucca  | Sales      |
|          17 | Mark Morgan   | Bellingen | Delivery   |
|           9 | Andy Smith    | Nambucca  | Delivery   |
|           8 | June Wilson   | Bellingen | Sales      |
+-------------+---------------+-----------+------------+
5 rows in set (0.00 sec)
</pre><p>
      For general information about joins in MySQL, see
      <a class="xref" href="sql-syntax.html#join" title="13.2.9.2. JOIN Syntax">Section 13.2.9.2, “<code class="literal">JOIN</code> Syntax”</a>.
    </p><p>
      When the <code class="literal">PARTITION</code> option is used with
      <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a> statements, only those
      partitions (and subpartitions, if any) listed with the option are
      checked for rows to be deleted. Any other partitions are ignored,
      as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  4 | Jim   | Smith  |        2 |             4 |
|  8 | June  | Wilson |        3 |             1 |
| 11 | Jill  | Stone  |        1 |             4 |
+----+-------+--------+----------+---------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM employees PARTITION (p0, p1)</code></strong> 
    -&gt;     <strong class="userinput"><code>WHERE fname LIKE 'j%';</code></strong>
Query OK, 2 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      Only the two rows in partitions <code class="literal">p0</code> and
      <code class="literal">p1</code> matching the <code class="literal">WHERE</code>
      condition were deleted. As you can see from the result when the
      <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> is run a second time, there
      remains a row in the table matching the <code class="literal">WHERE</code>
      condition, but residing in a different partition
      (<code class="literal">p2</code>).
    </p><p>
      <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a> statements using explicit
      partition selection behave in the same way; only rows in the
      partitions referenced by the <code class="literal">PARTITION</code> option
      are considered when determining the rows to be updated, as can be
      seen by executing the following statements:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p0) </code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p2)</code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        2 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      In the same way, when <code class="literal">PARTITION</code> is used with
      <a class="link" href="sql-syntax.html#delete" title="13.2.2. DELETE Syntax"><code class="literal">DELETE</code></a>, only rows in the partition
      or partitions named in the partition list are checked for
      deletion.
    </p><p>
      For statements that insert rows, the behavior differs in that
      failure to find a suitable partition causes the statement to fail.
      This is true for both <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> and
      <a class="link" href="sql-syntax.html#replace" title="13.2.8. REPLACE Syntax"><code class="literal">REPLACE</code></a> statements, as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p2) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
Query OK, 1 row affected (0.07 sec)

mysql&gt; REPLACE INTO employees PARTITION (p0) VALUES (20, 'Jan', 'Jones', 3, 2);
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>

mysql&gt; REPLACE INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 3, 2);
Query OK, 2 rows affected (0.09 sec)
</pre><p>
      For statements that write multiple rows to a partitioned table
      that uses the <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine:
      If any row in the list following <code class="literal">VALUES</code> cannot
      be written to one of the partitions specified in the
      <em class="replaceable"><code>partition_names</code></em> list, the entire
      statement fails and no rows are written. This is shown for
      <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statements in the following
      example, reusing the <code class="literal">employees</code> table created
      previously:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE employees</code></strong>
    -&gt;     <strong class="userinput"><code>REORGANIZE PARTITION p3 INTO (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (25),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p5 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 6 rows affected (2.09 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE employees\G</code></strong>
*************************** 1. row ***************************
       Table: employees
Create Table: CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fname` varchar(25) NOT NULL,
  `lname` varchar(25) NOT NULL,
  `store_id` int(11) NOT NULL,
  `department_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (id)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (15) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (20) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (25) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4) VALUES</code></strong> 
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
ERROR 1729 (HY000): Found a row not matching the given partition set

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4. p5) VALUES</code></strong> 
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
Query OK, 2 rows affected (0.06 sec)
Records: 2  Duplicates: 0  Warnings: 0
</pre><p>
      The preceding is true for both
      <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statements and
      <a class="link" href="sql-syntax.html#replace" title="13.2.8. REPLACE Syntax"><code class="literal">REPLACE</code></a> statements that write
      multiple rows.
    </p><p>
      In MySQL 5.6.10 and later, partition selection is disabled for
      tables employing a storage engine that supplies automatic
      partitioning, such as <code class="literal">NDB</code>. (Bug #14827952)
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="partitioning-limitations"></a>18.6. Restrictions and Limitations on Partitioning</h2>

</div>

</div>

</div>
<div class="toc">
<dl><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">18.6.1. Partitioning Keys, Primary Keys, and Unique Keys</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">18.6.2. Partitioning Limitations Relating to Storage Engines</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">18.6.3. Partitioning Limitations Relating to Functions</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-locking">18.6.4. Partitioning and Locking</a></span></dt></dl>
</div>
<a class="indexterm" name="idp128374528"></a><p>
      This section discusses current restrictions and limitations on
      MySQL partitioning support.
    </p><p><b>Prohibited constructs. </b>
        The following constructs are not permitted in partitioning
        expressions:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Stored procedures, stored functions, UDFs, or plugins.
        </p></li><li class="listitem"><p>
          Declared variables or user variables.
</p></li></ul>
</div>
<p>
      For a list of SQL functions which are permitted in partitioning
      expressions, see
      <a class="xref" href="partitioning.html#partitioning-limitations-functions" title="18.6.3. Partitioning Limitations Relating to Functions">Section 18.6.3, “Partitioning Limitations Relating to Functions”</a>.
    </p><p><b>Arithmetic and logical operators. </b>
        <a class="indexterm" name="idp128381936"></a>

        <a class="indexterm" name="idp128383456"></a>

        Use of the arithmetic operators
        <a class="link" href="functions.html#operator_plus"><code class="literal">+</code></a>,
        <a class="link" href="functions.html#operator_minus"><code class="literal">-</code></a>, and
        <a class="link" href="functions.html#operator_times"><code class="literal">*</code></a> is permitted in
        partitioning expressions. However, the result must be an integer
        value or <code class="literal">NULL</code> (except in the case of
        <code class="literal">[LINEAR] KEY</code> partitioning, as discussed
        elsewhere in this chapter; see
        <a class="xref" href="partitioning.html#partitioning-types" title="18.2. Partitioning Types">Section 18.2, “Partitioning Types”</a>, for more information).
      </p><p>
      The <a class="link" href="functions.html#operator_div"><code class="literal">DIV</code></a> operator is also supported,
      and the <a class="link" href="functions.html#operator_divide"><code class="literal">/</code></a> operator
      is not permitted. (Bug #30188, Bug #33182)
    </p><p>
      The bit operators
      <a class="link" href="functions.html#operator_bitwise-or"><code class="literal">|</code></a>,
      <a class="link" href="functions.html#operator_bitwise-and"><code class="literal">&amp;</code></a>,
      <a class="link" href="functions.html#operator_bitwise-xor"><code class="literal">^</code></a>,
      <a class="link" href="functions.html#operator_left-shift"><code class="literal">&lt;&lt;</code></a>,
      <a class="link" href="functions.html#operator_right-shift"><code class="literal">&gt;&gt;</code></a>, and
      <a class="link" href="functions.html#operator_bitwise-invert"><code class="literal">~</code></a> are not
      permitted in partitioning expressions.
    </p><p><b><code class="literal">HANDLER</code> statements. </b>
        In MySQL 5.6, the
        <a class="link" href="sql-syntax.html#handler" title="13.2.4. HANDLER Syntax"><code class="literal">HANDLER</code></a> statement is not
        supported with partitioned tables.
      </p><p><b>Server SQL mode. </b>
        <a class="indexterm" name="idp128401152"></a>

        <a class="indexterm" name="idp128402640"></a>

        Tables employing user-defined partitioning do not preserve the
        SQL mode in effect at the time that they were created. As
        discussed in <a class="xref" href="server-administration.html#server-sql-mode" title="5.1.7. Server SQL Modes">Section 5.1.7, “Server SQL Modes”</a>, the results of
        many MySQL functions and operators may change according to the
        server SQL mode. Therefore, a change in the SQL mode at any time
        after the creation of partitioned tables may lead to major
        changes in the behavior of such tables, and could easily lead to
        corruption or loss of data. For these reasons, <span class="emphasis"><em>it is
        strongly recommended that you never change the server SQL mode
        after creating partitioned tables</em></span>.
      </p><p><b>Examples. </b>
        The following examples illustrate some changes in behavior of
        partitioned tables due to a change in the server SQL mode:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p><b>Error handling. </b>
            Suppose that you create a partitioned table whose
            partitioning expression is one such as
            <code class="literal"><em class="replaceable"><code>column</code></em> DIV 0</code>
            or <code class="literal"><em class="replaceable"><code>column</code></em> MOD
            0</code>, as shown here:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tn (c1 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY LIST(1 DIV c1) (</code></strong>
    -&gt;       <strong class="userinput"><code>PARTITION p0 VALUES IN (NULL),</code></strong>
    -&gt;       <strong class="userinput"><code>PARTITION p1 VALUES IN (1)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
          The default behavior for MySQL is to return
          <code class="literal">NULL</code> for the result of a division by zero,
          without producing any errors:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)


mysql&gt; <strong class="userinput"><code>INSERT INTO tn VALUES (NULL), (0), (1);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><p>
          However, changing the server SQL mode to treat division by
          zero as an error and to enforce strict error handling causes
          the same <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> statement to
          fail, as shown here:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode='STRICT_ALL_TABLES,ERROR_FOR_DIVISION_BY_ZERO';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO tn VALUES (NULL), (0), (1);</code></strong>
<span class="errortext">ERROR 1365 (22012): Division by 0</span>
</pre></li><li class="listitem"><p><b>Table accessibility. </b>
            Sometimes a change in the server SQL mode can make
            partitioned tables unusable. The following
            <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement can be
            executed successfully only if the
            <a class="link" href="server-administration.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a>
            mode is in effect:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>

mysql&gt; <strong class="userinput"><code>SET sql_mode='NO_UNSIGNED_SUBTRACTION';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
          If you remove the
          <a class="link" href="server-administration.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a>
          server SQL mode after creating <code class="literal">tu</code>, you may
          no longer be able to access this table:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode='';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tu;</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO tu VALUES (20);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
</pre></li></ol>
</div>
<p>
      Server SQL modes also impact replication of partitioned tables.
      Differing SQL modes on master and slave can lead to partitioning
      expressions being evaluated differently; this can cause the
      distribution of data among partitions to be different in the
      master's and slave's copies of a given table, and may
      even cause inserts into partitioned tables that succeed on the
      master to fail on the slave. For best results, you should always
      use the same server SQL mode on the master and on the slave.
    </p><p><b>Performance considerations. </b>
        Some affects of partitioning operations on performance are given
        in the following list:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="partitioning-limitations-file-system-ops"></a><b>File system operations. </b>
            Partitioning and repartitioning operations (such as
            <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
            TABLE</code></a> with <code class="literal">PARTITION BY ...</code>,
            <code class="literal">REORGANIZE PARTITIONS</code>, or <code class="literal">REMOVE
            PARTITIONING</code>) depend on file system operations for
            their implementation. This means that the speed of these
            operations is affected by such factors as file system type
            and characteristics, disk speed, swap space, file handling
            efficiency of the operating system, and MySQL server options
            and variables that relate to file handling. In particular,
            you should make sure that
            <a class="link" href="server-administration.html#sysvar_large_files_support"><code class="literal">large_files_support</code></a> is
            enabled and that
            <a class="link" href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> is set
            properly. For partitioned tables using the
            <code class="literal">MyISAM</code> storage engine, increasing
            <a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size"><code class="literal">myisam_max_sort_file_size</code></a>
            may improve performance; partitioning and repartitioning
            operations involving <code class="literal">InnoDB</code> tables may be
            made more efficient by enabling
            <a class="link" href="storage-engines.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>.
          </p><p>
          See also
          <a class="xref" href="partitioning.html#partitioning-limitations-max-partitions" title="Maximum number of partitions">Maximum number of partitions</a>.
        </p></li><li class="listitem"><p><b>Table locks. </b>
            The process executing a partitioning operation on a table
            takes a write lock on the table. Reads from such tables are
            relatively unaffected; pending
            <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> and
            <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a> operations are
            performed as soon as the partitioning operation has
            completed.
          </p></li><li class="listitem"><p><b>Storage engine. </b>
            Partitioning operations, queries, and update operations
            generally tend to be faster with <code class="literal">MyISAM</code>
            tables than with <code class="literal">InnoDB</code> or
            <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> tables.
          </p></li><li class="listitem"><p><b>Use of indexes and partition pruning. </b>
            As with nonpartitioned tables, proper use of indexes can
            speed up queries on partitioned tables significantly. In
            addition, designing partitioned tables and queries on these
            tables to take advantage of <em class="firstterm">partition
            pruning</em> can improve performance dramatically.
            See <a class="xref" href="partitioning.html#partitioning-pruning" title="18.4. Partition Pruning">Section 18.4, “Partition Pruning”</a>, for more
            information.
          </p></li><li class="listitem"><p><b>Performance with <code class="literal">LOAD DATA</code>. </b>
            In MySQL 5.6, <a class="link" href="sql-syntax.html#load-data" title="13.2.6. LOAD DATA INFILE Syntax"><code class="literal">LOAD
            DATA</code></a> uses buffering to improve performance. You
            should be aware that the buffer uses 130 KB memory per
            partition to achieve this.
</p></li></ul>
</div>
<p><a name="partitioning-limitations-max-partitions"></a><b>Maximum number of partitions. </b><a class="indexterm" name="idp128477872"></a><a class="indexterm" name="idp128479376"></a>
        Prior to MySQL 5.6.7, the maximum possible number of partitions
        for a given table not using the <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a>
        storage engine was 1024. Beginning with MySQL 5.6.7, this limit
        is increased to 8192 partitions. Regardless of the MySQL Server
        version, this maximum includes subpartitions.
      </p><p>
      The maximum possible number of user-defined partitions for a table
      using the <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> storage engine is
      determined according to the version of the MySQL Cluster software
      being used, the number of data nodes, and other factors. See
      <a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB and user-defined partitioning"><code class="literal">NDB</code> and user-defined partitioning</a>,
      for more information.
    </p><p>
      If, when creating tables with a large number of partitions (but
      less than the maximum), you encounter an error message such as
      <span class="errortext">Got error ... from storage engine: Out of resources
      when opening file</span>, you may be able to address the
      issue by increasing the value of the
      <a class="link" href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> system variable.
      However, this is dependent on the operating system, and may not be
      possible or advisable on all platforms; see
      <a class="xref" href="error-handling.html#not-enough-file-handles" title="C.5.2.18. 'File' Not Found and Similar Errors">Section C.5.2.18, “<span class="errortext">'<em class="replaceable"><code>File</code></em>' Not Found</span> and
          Similar Errors”</a>, for more information.
      In some cases, using large numbers (hundreds) of partitions may
      also not be advisable due to other concerns, so using more
      partitions does not automatically lead to better results.
    </p><p>
      See also
      <a class="xref" href="partitioning.html#partitioning-limitations-file-system-ops" title="File system operations">File system operations</a>.
    </p><p><b>Query cache not supported. </b><a class="indexterm" name="idp128489136"></a><a class="indexterm" name="idp128490624"></a>
        The query cache is not supported for partitioned tables.
        Beginning with MySQL 5.6.5, the query cache is automatically
        disabled for queries involving partitioned tables, and cannot be
        enabled for such queries. (Bug #53775)
      </p><p><b>Per-partition key caches. </b><a class="indexterm" name="idp128493584"></a><a class="indexterm" name="idp128495072"></a><a class="indexterm" name="idp128496560"></a>
        In MySQL 5.6, key caches are supported for
        partitioned <a class="link" href="storage-engines.html#myisam-storage-engine" title="14.3. The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables, using
        the <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2. CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> and
        <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5. LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
        CACHE</code></a> statements. Key caches may be defined for one,
        several, or all partitions, and indexes for one, several, or all
        partitions may be preloaded into key caches.
      </p><p><b>Foreign keys not supported for partitioned <code class="literal">InnoDB</code>
        tables. </b><a class="indexterm" name="idp128502816"></a>
        Partitioned tables using the <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
        storage engine do not support foreign keys. More specifically,
        this means that the following two statements are true:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          No definition of an <code class="literal">InnoDB</code> table employing
          user-defined partitioning may contain foreign key references;
          no <code class="literal">InnoDB</code> table whose definition contains
          foreign key references may be partitioned.
        </p></li><li class="listitem"><p>
          No <code class="literal">InnoDB</code> table definition may contain a
          foreign key reference to a user-partitioned table; no
          <code class="literal">InnoDB</code> table with user-defined partitioning
          may contain columns referenced by foreign keys.
</p></li></ol>
</div>
<p>
      The scope of the restrictions just listed includes all tables that
      use the <code class="literal">InnoDB</code> storage engine.
      <a class="link" href="sql-syntax.html#create-table-foreign-keys" title="13.1.17.2. Using FOREIGN KEY Constraints"><code class="literal">CREATE
      TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
      statements that would result in tables violating these
      restrictions are not allowed.
    </p><p><b><code class="literal">ALTER TABLE ... ORDER BY</code>. </b>
        An <code class="literal">ALTER TABLE ... ORDER BY
        <em class="replaceable"><code>column</code></em></code> statement run
        against a partitioned table causes ordering of rows only within
        each partition.
      </p><p><b><code class="literal">FULLTEXT</code> indexes. </b><a class="indexterm" name="idp128518608"></a>
        Partitioned tables do not support <code class="literal">FULLTEXT</code>
        indexes or searches, even for partitioned tables employing the
        <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> or
        <a class="link" href="storage-engines.html#myisam-storage-engine" title="14.3. The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage engine.
      </p><p><b>Spatial columns. </b>
        Columns with spatial data types such as <code class="literal">POINT</code>
        or <code class="literal">GEOMETRY</code> cannot be used in partitioned
        tables.
      </p><p><b>Temporary tables. </b><a class="indexterm" name="idp128526544"></a>
        Temporary tables cannot be partitioned. (Bug #17497)
      </p><p><b>Log tables. </b>
        It is not possible to partition the log tables; an
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... PARTITION BY ...</code></a> statement on such a table
        fails with an error.
      </p><p><b>Data type of partitioning key. </b><a class="indexterm" name="idp128531520"></a>
        A partitioning key must be either an integer column or an
        expression that resolves to an integer. The column or expression
        value may also be <code class="literal">NULL</code>. (See
        <a class="xref" href="partitioning.html#partitioning-handling-nulls" title="18.2.7. How MySQL Partitioning Handles NULL">Section 18.2.7, “How MySQL Partitioning Handles <code class="literal">NULL</code>”</a>.)
      </p><p>
      There are two exceptions to this restriction:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          When partitioning by [<code class="literal">LINEAR</code>]
          <code class="literal">KEY</code>, it is possible to use columns of other
          types as partitioning keys, because MySQL's internal
          key-hashing functions produce the correct data type from these
          types. For example, the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
          TABLE</code></a> statement is valid:
        </p><pre class="programlisting">CREATE TABLE tkc (c1 CHAR)
PARTITION BY KEY(c1)
PARTITIONS 4;</pre></li><li class="listitem"><p>
          When partitioning by <code class="literal">RANGE COLUMNS</code> or
          <code class="literal">LIST COLUMNS</code>, it is possible to use string,
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, and
          <a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns. For example,
          each of the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
          TABLE</code></a> statements is valid:
        </p><pre class="programlisting">CREATE TABLE rc (c1 INT, c2 DATE)
PARTITION BY RANGE COLUMNS(c2) (
    PARTITION p0 VALUES LESS THAN('1990-01-01'),
    PARTITION p1 VALUES LESS THAN('1995-01-01'),
    PARTITION p2 VALUES LESS THAN('2000-01-01'),
    PARTITION p3 VALUES LESS THAN('2005-01-01'),
    PARTITION p4 VALUES LESS THAN(MAXVALUE)
);

CREATE TABLE lc (c1 INT, c2 CHAR(1))
PARTITION BY LIST COLUMNS(c2) (
    PARTITION p0 VALUES IN('a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y'),
    PARTITION p1 VALUES IN('b', 'e', 'h', 'k', 'n', 'q', 't', 'w', 'z'),
    PARTITION p2 VALUES IN('c', 'f', 'i', 'l', 'o', 'r', 'u', 'x', NULL)
);</pre></li></ol>
</div>
<p>
      Neither of the preceding exceptions applies to
      <a class="link" href="data-types.html#blob" title="11.4.3. The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
      <a class="link" href="data-types.html#blob" title="11.4.3. The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column types.
    </p><p><b>Subqueries. </b><a class="indexterm" name="idp128549424"></a>
        A partitioning key may not be a subquery, even if that subquery
        resolves to an integer value or <code class="literal">NULL</code>.
      </p><p><a name="partitioning-limitations-subpartitions"></a><b>Issues with subpartitions. </b><a class="indexterm" name="idp128553248"></a><a class="indexterm" name="idp128554736"></a>
        Subpartitions must use <code class="literal">HASH</code> or
        <code class="literal">KEY</code> partitioning. Only
        <code class="literal">RANGE</code> and <code class="literal">LIST</code> partitions
        may be subpartitioned; <code class="literal">HASH</code> and
        <code class="literal">KEY</code> partitions cannot be subpartitioned.
      </p><p>
      <a class="indexterm" name="idp128561376"></a>

      Currently, <code class="literal">SUBPARTITION BY KEY</code> requires that
      the subpartitioning column or columns be specified explicitly,
      unlike the case with <code class="literal">PARTITION BY KEY</code>, where it
      can be omitted (in which case the table's primary key column
      is used by default). Consider the table created by this statement:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
);</pre><p>
      You can create a table having the same columns, partitioned by
      <code class="literal">KEY</code>, using a statement such as this one:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY() 
PARTITIONS 4;
        </pre><p>
      The previous statement is treated as though it had been written
      like this, with the table's primary key column used as the
      partitioning column:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY(id) 
PARTITIONS 4;
        </pre><p>
      However, the following statement that attempts to create a
      subpartitioned table using the default column as the
      subpartitioning column fails, and the column must be specified for
      the statement to succeed, as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY()</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that 
corresponds to your MySQL server version for the right syntax to use near ')</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.07 sec)
</pre><p>
      This is a known issue (see Bug #51470).
    </p><p><b><code class="literal">DELAYED</code> option not supported. </b>
        Use of <a class="link" href="sql-syntax.html#insert-delayed" title="13.2.5.2. INSERT DELAYED Syntax"><code class="literal">INSERT DELAYED</code></a> to insert
        rows into a partitioned table is not supported. Attempting to do
        so fails with an error.
      </p><p><b><code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX DIRECTORY</code>
        options. </b>
        <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
        DIRECTORY</code> are subject to the following restrictions
        when used with partitioned tables:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Table-level <code class="literal">DATA DIRECTORY</code> and
          <code class="literal">INDEX DIRECTORY</code> options are ignored (see
          Bug #32091).
        </p></li><li class="listitem"><p>
          On Windows, the <code class="literal">DATA DIRECTORY</code> and
          <code class="literal">INDEX DIRECTORY</code> options are not supported
          for individual partitions or subpartitions of
          <a class="link" href="storage-engines.html#myisam-storage-engine" title="14.3. The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables (Bug #30459).
          However, you can use <code class="literal">DATA DIRECTORY</code> for
          individual partitions or subpartitions of
          <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables.
</p></li></ul>
</div>
<p><b>Repairing and rebuilding partitioned tables. </b>
        The statements <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2. CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>,
        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4. OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>,
        <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1. ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, and
        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5. REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> are supported for
        partitioned tables.
      </p><p>
      In addition, you can use <code class="literal">ALTER TABLE ... REBUILD
      PARTITION</code> to rebuild one or more partitions of a
      partitioned table; <code class="literal">ALTER TABLE ... REORGANIZE
      PARTITION</code> also causes partitions to be rebuilt. See
      <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>, for more information about these
      two statements.
    </p><p>
      <a class="link" href="programs.html#mysqlcheck" title="4.5.3. mysqlcheck — A Table Maintenance Program"><span class="command"><strong>mysqlcheck</strong></span></a> and <a class="link" href="programs.html#myisamchk" title="4.6.3. myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> are
      not supported with partitioned tables.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-limitations-partitioning-keys-unique-keys"></a>18.6.1. Partitioning Keys, Primary Keys, and Unique Keys</h3>
</div>
</div>
</div>
<a class="indexterm" name="idp128611648"></a><a class="indexterm" name="idp128612736"></a><a class="indexterm" name="idp128614224"></a><a class="indexterm" name="idp128615312"></a><a class="indexterm" name="idp128616800"></a><p>
        This section discusses the relationship of partitioning keys
        with primary keys and unique keys. The rule governing this
        relationship can be expressed as follows: All columns used in
        the partitioning expression for a partitioned table must be part
        of every unique key that the table may have.
      </p><p>
        In other words, <span class="emphasis"><em>every unique key on the table must use
        every column in the table's partitioning expression</em></span>.
        (This also includes the table's primary key, since it is by
        definition a unique key. This particular case is discussed later
        in this section.) For example, each of the following table
        creation statements is invalid:
      </p><pre class="programlisting">CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1),
    UNIQUE KEY (col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;</pre><p>
        In each case, the proposed table would have at least one unique
        key that does not include all columns used in the partitioning
        expression.
      </p><p>
        Each of the following statements is valid, and represents one
        way in which the corresponding invalid table creation statement
        could be made to work:
      </p><pre class="programlisting">CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2, col3)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;</pre><p>
        This example shows the error produced in such cases:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col1 + col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1491 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        The <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement fails
        because both <code class="literal">col1</code> and <code class="literal">col3</code>
        are included in the proposed partitioning key, but neither of
        these columns is part of both of unique keys on the table. This
        shows one possible fix for the invalid table definition:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2, col3),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
        In this case, the proposed partitioning key
        <code class="literal">col3</code> is part of both unique keys, and the
        table creation statement succeeds.
      </p><p>
        The following table cannot be partitioned at all, because there
        is no way to include in a partitioning key any columns that
        belong to both unique keys:
      </p><pre class="programlisting">CREATE TABLE t4 (
    col1 INT NOT NULL,
    col2 INT NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3),
    UNIQUE KEY (col2, col4)
);</pre><p>
        Since every primary key is by definition a unique key, this
        restriction also includes the table's primary key, if it has
        one. For example, the next two statements are invalid:
      </p><pre class="programlisting">CREATE TABLE t5 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t6 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col3),
    UNIQUE KEY(col2)
)
PARTITION BY HASH( YEAR(col2) )
PARTITIONS 4;</pre><p>
        In both cases, the primary key does not include all columns
        referenced in the partitioning expression. However, both of the
        next two statements are valid:
      </p><pre class="programlisting">CREATE TABLE t7 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;

CREATE TABLE t8 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2, col4),
    UNIQUE KEY(col2, col1)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;</pre><p>
        If a table has no unique keys—this includes having no
        primary key—then this restriction does not apply, and you
        may use any column or columns in the partitioning expression as
        long as the column type is compatible with the partitioning
        type.
      </p><p>
        For the same reason, you cannot later add a unique key to a
        partitioned table unless the key includes all columns used by
        the table's partitioning expression. Consider the partitioned
        table created as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t_no_pk (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (30),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (40)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.12 sec)
</pre><p>
        It is possible to add a primary key to
        <code class="literal">t_no_pk</code> using either of these
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statements:
      </p><pre class="programlisting">#  possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1);</code></strong>
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

#  use another possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1, c2);</code></strong>
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        However, the next statement fails, because <code class="literal">c1</code>
        is part of the partitioning key, but is not part of the proposed
        primary key:
      </p><pre class="programlisting">#  fails with error 1503
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c2);</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        Since <code class="literal">t_no_pk</code> has only <code class="literal">c1</code>
        in its partitioning expression, attempting to adding a unique
        key on <code class="literal">c2</code> alone fails. However, you can add a
        unique key that uses both <code class="literal">c1</code> and
        <code class="literal">c2</code>.
      </p><p>
        These rules also apply to existing nonpartitioned tables that
        you wish to partition using
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... PARTITION BY</code></a>. Consider a table
        <code class="literal">np_pk</code> created as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE np_pk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(50),</code></strong>
    -&gt;     <strong class="userinput"><code>added DATE,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (id)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.08 sec)
</pre><p>
        The following
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statement fails with an error, because the
        <code class="literal">added</code> column is not part of any unique key in
        the table:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH( TO_DAYS(added) )</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        However, this statement using the <code class="literal">id</code> column
        for the partitioning column is valid, as shown here:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH(id)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        In the case of <code class="literal">np_pk</code>, the only column that
        may be used as part of a partitioning expression is
        <code class="literal">id</code>; if you wish to partition this table using
        any other column or columns in the partitioning expression, you
        must first modify the table, either by adding the desired column
        or columns to the primary key, or by dropping the primary key
        altogether.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-limitations-storage-engines"></a>18.6.2. Partitioning Limitations Relating to Storage Engines</h3>

</div>

</div>

</div>
<a class="indexterm" name="idp128690256"></a><p>
        The following limitations apply to the use of storage engines
        with user-defined partitioning of tables.
      </p><p><b><code class="literal">MERGE</code> storage engine. </b>
          User-defined partitioning and the <code class="literal">MERGE</code>
          storage engine are not compatible. Tables using the
          <code class="literal">MERGE</code> storage engine cannot be partitioned.
          Partitioned tables cannot be merged.
        </p><p><b><code class="literal">FEDERATED</code> storage engine. </b>
          Partitioning of <code class="literal">FEDERATED</code> tables is not
          supported; it is not possible to create partitioned
          <code class="literal">FEDERATED</code> tables.
        </p><p><b><code class="literal">CSV</code> storage engine. </b>
          Partitioned tables using the <code class="literal">CSV</code> storage
          engine are not supported; it is not possible to create
          partitioned <code class="literal">CSV</code> tables.
        </p><p><b><code class="literal">InnoDB</code> storage engine. </b>
          <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> foreign keys and MySQL
          partitioning are not compatible. Partitioned
          <code class="literal">InnoDB</code> tables cannot have foreign key
          references, nor can they have columns referenced by foreign
          keys. <code class="literal">InnoDB</code> tables which have or which are
          referenced by foreign keys cannot be partitioned.
        </p><p>
        In addition,
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... OPTIMIZE PARTITION</code></a> does not work correctly
        with partitioned tables that use the <code class="literal">InnoDB</code>
        storage engine. Use <code class="literal">ALTER TABLE ... REBUILD
        PARTITION</code> and <code class="literal">ALTER TABLE ... ANALYZE
        PARTITION</code>, instead, for such tables. For more
        information, see
        <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations">Section 13.1.7.1, “<code class="literal">ALTER TABLE</code> Partition Operations”</a>.
      </p><p><b><code class="literal">NDB</code> storage engine (MySQL Cluster). </b>
          Partitioning by <code class="literal">KEY</code> (including
          <code class="literal">LINEAR KEY</code>) is the only type of
          partitioning supported for the
          <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> storage engine. It is not
          possible in MySQL Cluster NDB 7.3 to create a MySQL Cluster
          table using any partitioning type other than
          [<code class="literal">LINEAR</code>] <code class="literal">KEY</code>, and
          attempting to do so fails with an error.
        </p><p>
        In addition, the maximum number of partitions that can be
        defined for an <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table depends on
        the number of data nodes and node groups in the cluster, the
        version of the MySQL Cluster software in use, and other factors.
        See
        <a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB and user-defined partitioning"><code class="literal">NDB</code> and user-defined partitioning</a>,
        for more information.
      </p><p>
        <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE</code></a> statements that would cause a user-partitioned
        <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table not to meet either or
        both of the following two requirements are not permitted, and
        fail with an error:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
            The table must have an explicit primary key.
          </p></li><li class="listitem"><p>
            All columns listed in the table's partitioning
            expression must be part of the primary key.
</p></li></ol>
</div>
<p><b>Exception. </b>
          If a user-partitioned <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> table
          is created using an empty column-list (that is, using
          <code class="literal">PARTITION BY KEY()</code> or <code class="literal">PARTITION BY
          LINEAR KEY()</code>), then no explicit primary key is
          required.
        </p><p><b>Upgrading partitioned tables. </b>
          When performing an upgrade, tables which are partitioned by
          <code class="literal">KEY</code> and which use any storage engine other
          than <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.3"><code class="literal">NDB</code></a> must be dumped and
          reloaded.
        </p><p><b>Same storage engine for all partitions. </b>
          All partitions of a partitioned table must use the same
          storage engine and it must be the same storage engine used by
          the table as a whole. In addition, if one does not specify an
          engine on the table level, then one must do either of the
          following when creating or altering a partitioned table:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Do <span class="emphasis"><em>not</em></span> specify any engine for
            <span class="emphasis"><em>any</em></span> partition or subpartition
          </p></li><li class="listitem"><p>
            Specify the engine for <span class="emphasis"><em>all</em></span> partitions
            or subpartitions
</p></li></ul>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-limitations-functions"></a>18.6.3. Partitioning Limitations Relating to Functions</h3>

</div>

</div>

</div>
<p>
        This section discusses limitations in MySQL Partitioning
        relating specifically to functions used in partitioning
        expressions.
      </p><a class="indexterm" name="idp128737248"></a><p>
        Only the MySQL functions shown in the following table are
        supported in partitioning expressions.
</p>
<div class="informaltable">
<table summary="This table lists the functions that are supported in
          partitioning expressions as of MySQL 5.1.12. Functions are
          presented in a three column table format and in alphabetical
          order from left to right. " border="1"><colgroup><col><col><col></colgroup><tbody><tr><td scope="row"><a class="link" href="functions.html#function_abs"><code class="literal">ABS()</code></a></td><td><a class="link" href="functions.html#function_ceiling"><code class="literal">CEILING()</code></a> (see
                <a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() and FLOOR()"><code class="literal">CEILING()</code> and
          <code class="literal">FLOOR()</code></a>)</td><td><a class="link" href="functions.html#function_day"><code class="literal">DAY()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_dayofmonth"><code class="literal">DAYOFMONTH()</code></a></td><td><a class="link" href="functions.html#function_dayofweek"><code class="literal">DAYOFWEEK()</code></a></td><td><a class="link" href="functions.html#function_dayofyear"><code class="literal">DAYOFYEAR()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_datediff"><code class="literal">DATEDIFF()</code></a></td><td><a class="link" href="functions.html#function_extract"><code class="literal">EXTRACT()</code></a> (see
                <a class="xref" href="partitioning.html#partitioning-limitations-extract" title="EXTRACT() function with WEEK specifier"><code class="literal">EXTRACT()</code> function with
          <code class="literal">WEEK</code> specifier</a>)</td><td><a class="link" href="functions.html#function_floor"><code class="literal">FLOOR()</code></a> (see
                <a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() and FLOOR()"><code class="literal">CEILING()</code> and
          <code class="literal">FLOOR()</code></a>)</td></tr><tr><td scope="row"><a class="link" href="functions.html#function_hour"><code class="literal">HOUR()</code></a></td><td><a class="link" href="functions.html#function_microsecond"><code class="literal">MICROSECOND()</code></a></td><td><a class="link" href="functions.html#function_minute"><code class="literal">MINUTE()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_mod"><code class="literal">MOD()</code></a></td><td><a class="link" href="functions.html#function_month"><code class="literal">MONTH()</code></a></td><td><a class="link" href="functions.html#function_quarter"><code class="literal">QUARTER()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_second"><code class="literal">SECOND()</code></a></td><td><a class="link" href="functions.html#function_time-to-sec"><code class="literal">TIME_TO_SEC()</code></a></td><td><a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_to-seconds"><code class="literal">TO_SECONDS()</code></a></td><td><a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> (permitted beginning
                with MySQL 5.6.1 and fully supported beginning with
                MySQL 5.6.3, with
<a class="link" href="data-types.html#datetime" title="11.3.1. The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns)</td><td><a class="link" href="functions.html#function_weekday"><code class="literal">WEEKDAY()</code></a></td></tr><tr><td scope="row"><a class="link" href="functions.html#function_year"><code class="literal">YEAR()</code></a></td><td> </td><td><a class="link" href="functions.html#function_yearweek"><code class="literal">YEARWEEK()</code></a></td></tr></tbody></table>
</div>
<p>
        In MySQL 5.6, partition pruning is supported for
        the <a class="link" href="functions.html#function_to-days"><code class="literal">TO_DAYS()</code></a>,
        <a class="link" href="functions.html#function_to-seconds"><code class="literal">TO_SECONDS()</code></a>, and
        <a class="link" href="functions.html#function_year"><code class="literal">YEAR()</code></a> functions. In addition,
        beginning with MySQL 5.6.3,
        <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> is treated as
        monotonic in partitioning expressions. See
        <a class="xref" href="partitioning.html#partitioning-pruning" title="18.4. Partition Pruning">Section 18.4, “Partition Pruning”</a>, for more information.
      </p><p><a name="partitioning-limitations-ceiling-floor"></a><b><code class="literal">CEILING()</code> and
          <code class="literal">FLOOR()</code>. </b>
          Each of these functions returns an integer only if it is
          passed an argument of an exact numeric type, such as one of
          the <a class="link" href="data-types.html#integer-types" title="11.2.1. Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> types or
          <a class="link" href="data-types.html#fixed-point-types" title="11.2.2. Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>. This means, for
          example, that the following <a class="link" href="sql-syntax.html#create-table" title="13.1.17. CREATE TABLE Syntax"><code class="literal">CREATE
          TABLE</code></a> statement fails with an error, as shown here:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c FLOAT) PARTITION BY LIST( FLOOR(c) )(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1490 (HY000): The PARTITION function returns the wrong type</span>
</pre><p><a name="partitioning-limitations-extract"></a><b><code class="literal">EXTRACT()</code> function with
          <code class="literal">WEEK</code> specifier. </b>
          The value returned by the
          <a class="link" href="functions.html#function_extract"><code class="literal">EXTRACT()</code></a> function, when used
          as <a class="link" href="functions.html#function_extract"><code class="literal">EXTRACT(WEEK FROM
          <em class="replaceable"><code>col</code></em>)</code></a>, depends on the
          value of the
          <a class="link" href="server-administration.html#sysvar_default_week_format"><code class="literal">default_week_format</code></a> system
          variable. For this reason, beginning with MySQL 5.6.2,
          <a class="link" href="functions.html#function_extract"><code class="literal">EXTRACT()</code></a> is longer permitted
          as a partitioning function when it specifies the unit as
          <code class="literal">WEEK</code>. (Bug #54483)
        </p><p>
        See <a class="xref" href="functions.html#mathematical-functions" title="12.6.2. Mathematical Functions">Section 12.6.2, “Mathematical Functions”</a>, for more
        information about the return types of these functions, as well
        as <a class="xref" href="data-types.html#numeric-types" title="11.2. Numeric Types">Section 11.2, “Numeric Types”</a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="partitioning-limitations-locking"></a>18.6.4. Partitioning and Locking</h3>

</div>

</div>

</div>
<p>
        In MySQL 5.6.5 and earlier, for storage engines such as
        <a class="link" href="storage-engines.html#myisam-storage-engine" title="14.3. The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that actually execute
        table-level locks when executing DML or DDL statements, such a
        statement affecting a partitioned table imposed a lock on the
        table as a whole; that is, all partitions were locked until the
        statement was finished. MySQL 5.6.6 implements
        <em class="firstterm">partition lock pruning</em>, which eliminates
        unneeded locks in many cases. In MySQL 5.6.6 and later, most
        statements reading from or updating a partitioned
        <code class="literal">MyISAM</code> table cause only the effected
        partitions to be locked. For example, prior to MySQL 5.6.6, a
        <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> from a partitioned
        <code class="literal">MyISAM</code> table caused a lock on the entire
        table; in MySQL 5.6.6 and later, only those partitions actually
        containing rows that satisfy the <code class="literal">SELECT</code>
        statement's <code class="literal">WHERE</code> condition are locked.
        This has the effect of increasing the speed and efficiency of
        concurrent operations on partitioned <code class="literal">MyISAM</code>
        tables. This improvement becomes particularly noticeable when
        working with <code class="literal">MyISAM</code> tables that have many (32
        or more) partitions.
      </p><p>
        This change in behavior does not have any impact on statements
        effecting partitioned tables using storage engines such as
        <a class="link" href="storage-engines.html#innodb-storage-engine" title="14.2. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, that employ row-level
        locking and do not actually perform (or need to perform) the
        locks prior to partition pruning.
      </p><p>
        The next few paragraphs discuss the effects of partition lock
        pruning for various MySQL statements on tables using storage
        engines that employ table-level locks.
</p>
<h4><a name="idp128804848"></a>
        Affects on DML statements
</h4>
<p>
        <a class="link" href="sql-syntax.html#select" title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statements (including
        those containing unions or joins) now lock only those partitions
        that actually need to be read. This also applies to
        <code class="literal">SELECT ... PARTITION</code>.
      </p><p>
        An <a class="link" href="sql-syntax.html#update" title="13.2.11. UPDATE Syntax"><code class="literal">UPDATE</code></a> prunes locks only for
        tables on which no partitioning columns are updated.
      </p><p>
        <a class="link" href="sql-syntax.html#replace" title="13.2.8. REPLACE Syntax"><code class="literal">REPLACE</code></a> and
        <a class="link" href="sql-syntax.html#insert" title="13.2.5. INSERT Syntax"><code class="literal">INSERT</code></a> now lock only those
        partitions having rows to be inserted or replaced. However, if
        an <code class="literal">AUTO_INCREMENT</code> value is generated for any
        partitioning column then all partitions are locked.
      </p><p>
        <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.3. INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
        ON DUPLICATE KEY UPDATE</code></a> is pruned as long as no
        partitioning column is updated.
      </p><p>
        <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1. INSERT ... SELECT Syntax"><code class="literal">INSERT ...
        SELECT</code></a> now locks only those partitions in the source
        table that need to be read, although all partitions in the
        target table are locked.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p xmlns="">
          <a class="link" href="sql-syntax.html#insert-delayed" title="13.2.5.2. INSERT DELAYED Syntax"><code class="literal">INSERT
          DELAYED</code></a> is not supported for partitioned tables.
</p>
</div>
<p>
        Locks imposed by <a class="link" href="sql-syntax.html#load-data" title="13.2.6. LOAD DATA INFILE Syntax"><code class="literal">LOAD
        DATA</code></a> statements on partitioned tables cannot be
        pruned.
      </p><p>
        The presence of <code class="literal">BEFORE INSERT</code> or
        <code class="literal">BEFORE UPDATE</code> triggers using any partitioning
        column of a partitioned table means that locks on
        <code class="literal">INSERT</code> and <code class="literal">UPDATE</code>
        statements updating this table cannot be pruned, since the
        trigger can alter its values: A <code class="literal">BEFORE INSERT</code>
        trigger on any of the table's partitioning columns means
        that locks set by <code class="literal">INSERT</code> or
        <code class="literal">REPLACE</code> cannot be pruned, since the
        <code class="literal">BEFORE INSERT</code> trigger may change a row's
        partitioning columns before the row is inserted, forcing the row
        into a different partition than it would be otherwise. A
        <code class="literal">BEFORE UPDATE</code> trigger on a partitioning
        column means that locks imposed by <code class="literal">UPDATE</code> or
        <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> cannot be
        pruned.
</p>
<h4><a name="idp128826256"></a>
        Affected DDL statements
</h4>
<p>
        <a class="link" href="sql-syntax.html#create-view" title="13.1.20. CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a> no longer causes any
        locks.
      </p><p>
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... EXCHANGE PARTITION</code></a> now prunes locks; only
        the exchanged table and the exchanged partition are locked.
      </p><p>
        <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1. ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... TRUNCATE PARTITION</code></a> now prunes locks; only
        the partitions to be emptied are locked.
      </p><p>
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements still take
        metadata locks on the table level.
</p>
<h4><a name="idp128831952"></a>
        Other statements
</h4>
<p>
        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5. LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> cannot prune
        partition locks.
      </p><p>
        <a class="link" href="sql-syntax.html#call" title="13.2.1. CALL Syntax"><code class="literal">CALL
        stored_procedure(<em class="replaceable"><code>expr</code></em>)</code></a>
        supports lock pruning, but evaluating
        <em class="replaceable"><code>expr</code></em> does not.
      </p><p>
        <a class="link" href="sql-syntax.html#do" title="13.2.3. DO Syntax"><code class="literal">DO</code></a> and
        <a class="link" href="sql-syntax.html#set-statement" title="13.7.4. SET Syntax"><code class="literal">SET</code></a>
        statements do not support partitioning lock pruning.
</p>
</div>

</div>

</div>
<div class="copyright-footer">
    Copyright © 1997, 2013, Oracle and/or its affiliates. All
    rights reserved.
<a href="preface.html#legalnotice">Legal Notices</a>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="mysql-cluster.html">Prev</a></td>
<td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="stored-programs-views.html">Next</a></td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 17. MySQL Cluster NDB 7.3</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">Chapter 19. Stored Programs and Views</td>
</tr>
</table>
</div>
</body>
</html>
